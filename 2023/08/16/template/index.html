<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>acm模板整理（未完） | wrpwrpのBlog</title><meta name="keywords" content="模板"><meta name="author" content="wrpwrp"><meta name="copyright" content="wrpwrp"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="模板">
<meta property="og:type" content="article">
<meta property="og:title" content="acm模板整理（未完）">
<meta property="og:url" content="http://example.com/2023/08/16/template/index.html">
<meta property="og:site_name" content="wrpwrpのBlog">
<meta property="og:description" content="模板">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.c4c52f16cc67c7409eff60a4fce2d152?rik=qBwdq1iz39HyPA&riu=http%3a%2f%2fwww.kutoo8.com%2fupload%2fimage%2f95093231%2f13.jpg&ehk=%2flbRri2PpwfxcQiqdvwcgv76NPhmuhxXUC9lhcyITcw%3d&risl=&pid=ImgRaw&r=0">
<meta property="article:published_time" content="2023-08-15T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-10T11:14:49.269Z">
<meta property="article:author" content="wrpwrp">
<meta property="article:tag" content="模板">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.c4c52f16cc67c7409eff60a4fce2d152?rik=qBwdq1iz39HyPA&riu=http%3a%2f%2fwww.kutoo8.com%2fupload%2fimage%2f95093231%2f13.jpg&ehk=%2flbRri2PpwfxcQiqdvwcgv76NPhmuhxXUC9lhcyITcw%3d&risl=&pid=ImgRaw&r=0"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/08/16/template/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: wrpwrp","link":"链接: ","source":"来源: wrpwrpのBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-09-10 19:14:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://bpic.588ku.com/element_pic/20/07/01/4347f2eea4eebb9a4708ea61636893a7.jpg!/fw/253/quality/90/unsharp/true/compress/true" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ts1.cn.mm.bing.net/th/id/R-C.c4c52f16cc67c7409eff60a4fce2d152?rik=qBwdq1iz39HyPA&amp;riu=http%3a%2f%2fwww.kutoo8.com%2fupload%2fimage%2f95093231%2f13.jpg&amp;ehk=%2flbRri2PpwfxcQiqdvwcgv76NPhmuhxXUC9lhcyITcw%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">wrpwrpのBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">acm模板整理（未完）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-15T16:00:00.000Z" title="发表于 2023-08-16 00:00:00">2023-08-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-10T11:14:49.269Z" title="更新于 2023-09-10 19:14:49">2023-09-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A8%A1%E6%9D%BF/">模板</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">40.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>215分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="acm模板整理（未完）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h2 id="快读快写"><a href="#快读快写" class="headerlink" title="快读快写"></a>快读快写</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span> &#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> MX 1000000</span></span><br><span class="line">	<span class="keyword">private</span> :</span><br><span class="line">		<span class="type">char</span> buf[MX], *p1 = buf, *p2 = buf;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(p1 == p2) p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MX, stdin);</span><br><span class="line">			<span class="keyword">return</span> p1 == p2 ? EOF : *(p1 ++);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="built_in">Input</span>() &#123;</span><br><span class="line">			<span class="meta">#<span class="keyword">ifdef</span> Open_File</span></span><br><span class="line">				<span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">				<span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">			<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">		<span class="keyword">inline</span> Input&amp; <span class="keyword">operator</span> &gt;&gt;(T &amp;x) &#123;</span><br><span class="line">			x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">1</span>; <span class="type">char</span> a = <span class="built_in">gc</span>();</span><br><span class="line">			<span class="keyword">for</span>(; ! <span class="built_in">isdigit</span>(a); a = <span class="built_in">gc</span>()) <span class="keyword">if</span>(a == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span>(; <span class="built_in">isdigit</span>(a); a = <span class="built_in">gc</span>()) </span><br><span class="line">				x = x * <span class="number">10</span> + a - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			x *= f;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">inline</span> Input&amp; <span class="keyword">operator</span> &gt;&gt;(<span class="type">char</span> &amp;ch) &#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">				ch = <span class="built_in">gc</span>();</span><br><span class="line">				<span class="keyword">if</span>(ch != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; ch != <span class="string">&#x27; &#x27;</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">inline</span> Input&amp; <span class="keyword">operator</span> &gt;&gt;(<span class="type">char</span> *s) &#123;</span><br><span class="line">			<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">				s[p] = <span class="built_in">gc</span>();</span><br><span class="line">				<span class="keyword">if</span>(s[p] == <span class="string">&#x27;\n&#x27;</span> || s[p] == <span class="string">&#x27; &#x27;</span> || s[p] == EOF) <span class="keyword">break</span>;</span><br><span class="line">				p ++; </span><br><span class="line">			&#125;</span><br><span class="line">			s[p] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> MX</span></span><br><span class="line">&#125; Fin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Output</span> &#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> MX 1000000</span></span><br><span class="line">	<span class="keyword">private</span> :</span><br><span class="line">		<span class="type">char</span> ouf[MX], *p1 = ouf, *p2 = ouf;</span><br><span class="line">		<span class="type">char</span> Of[<span class="number">105</span>], *o1 = Of, *o2 = Of;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123; <span class="built_in">fwrite</span>(ouf, <span class="number">1</span>, p2 - p1, stdout); p2 = p1; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pc</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">			* (p2 ++) = ch;</span><br><span class="line">			<span class="keyword">if</span>(p2 == p1 + MX) <span class="built_in">flush</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">		<span class="keyword">inline</span> Output&amp; <span class="keyword">operator</span> &lt;&lt; (T n) &#123;</span><br><span class="line">			<span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="built_in">pc</span>(<span class="string">&#x27;-&#x27;</span>), n = -n;</span><br><span class="line">			<span class="keyword">if</span>(n == <span class="number">0</span>) <span class="built_in">pc</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			<span class="keyword">while</span>(n) *(o1 ++) = (n % <span class="number">10</span>) ^ <span class="number">48</span>, n /= <span class="number">10</span>;</span><br><span class="line">			<span class="keyword">while</span>(o1 != o2) <span class="built_in">pc</span>(* (--o1));</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">inline</span> Output &amp; <span class="keyword">operator</span> &lt;&lt; (<span class="type">char</span> ch) &#123;</span><br><span class="line">			<span class="built_in">pc</span>(ch); <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">inline</span> Output &amp; <span class="keyword">operator</span> &lt;&lt;(<span class="type">const</span> <span class="type">char</span> *ch) &#123;</span><br><span class="line">			<span class="type">const</span> <span class="type">char</span> *p = ch;</span><br><span class="line">			<span class="keyword">while</span>( *p != <span class="string">&#x27;\0&#x27;</span> ) <span class="built_in">pc</span>(* p ++);</span><br><span class="line">			<span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">Output</span>() &#123; <span class="built_in">flush</span>(); &#125; </span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> MX</span></span><br><span class="line">&#125; Fout;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cin Fin</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cout Fout</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="常用缺省源"><a href="#常用缺省源" class="headerlink" title="常用缺省源"></a>常用缺省源</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lep(i, l, r) for(int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for(int i = (l); i &gt;= (r); i --)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(...) fprintf (stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mod</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x + (x &gt;&gt; <span class="number">31</span> &amp; P); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span> </span>&#123; x = <span class="built_in">mod</span>(x - y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pls</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span> </span>&#123; x = <span class="built_in">mod</span>(x + y - P); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">mod</span>(x + y - P); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dec</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">mod</span>(x - y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span>; <span class="keyword">if</span> (k &lt; <span class="number">0</span>) k += P - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (k) &#123; <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * x % P; x = <span class="number">1ll</span> * x * x % P; k &gt;&gt;= <span class="number">1</span>; &#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="type">int</span> Case; cin &gt;&gt; Case;</span><br><span class="line">	<span class="keyword">while</span> (Case --) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="gp-hash-table"><a href="#gp-hash-table" class="headerlink" title="gp_hash_table"></a>gp_hash_table</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/extc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> __gnu_pbds :: gp_hash_table;</span><br><span class="line"></span><br><span class="line">gp_hash_table &lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line">mp.<span class="built_in">find</span> (x) != mp.<span class="built_in">end</span>() <span class="comment">// 注意mp[x] 会创建 x 元素</span></span><br></pre></td></tr></table></figure>
<h3 id="朴素实现"><a href="#朴素实现" class="headerlink" title="朴素实现"></a>朴素实现</h3><p>上面这个解决不了基本也得现场写。</p>
<p>用邻接表写比较快。</p>
<h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><h3 id="单哈希"><a href="#单哈希" class="headerlink" title="单哈希"></a>单哈希</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> P&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String_hash</span> &#123; <span class="comment">// s.size() &gt; 1 !!!</span></span><br><span class="line">	std :: vector&lt;<span class="type">int</span>&gt; pw, f;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> bs = <span class="number">233</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">(std :: string s)</span> </span>&#123; <span class="comment">// [0, n - 1]</span></span><br><span class="line">		pw.<span class="built_in">resize</span> (s.<span class="built_in">size</span>() + <span class="number">1</span>); f.<span class="built_in">resize</span> (s.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">		pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (<span class="type">int</span>) s.<span class="built_in">size</span>(); i ++) pw[i] = <span class="number">1ll</span> * pw[i - <span class="number">1</span>] * bs % P;</span><br><span class="line">		f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (<span class="type">int</span>) s.<span class="built_in">size</span>(); i ++) f[i] = (<span class="number">1ll</span> * f[i - <span class="number">1</span>] * bs + s[i - <span class="number">1</span>]) % P;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> (f[r] - <span class="number">1ll</span> * f[l - <span class="number">1</span>] * pw[r - l + <span class="number">1</span>] % P + P) % P; &#125;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<p>这个是单哈希， 双哈希建俩表就行了。</p>
<h3 id="自然溢出"><a href="#自然溢出" class="headerlink" title="自然溢出"></a>自然溢出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">unlimit_hash</span> &#123; <span class="comment">// s.size() &gt; 1 !!!</span></span><br><span class="line">	std :: vector&lt;ull&gt; pw, f;</span><br><span class="line">	<span class="type">const</span> ull bs = <span class="number">233</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">(std :: string s)</span> </span>&#123; <span class="comment">// [0, n - 1]</span></span><br><span class="line">		pw.<span class="built_in">resize</span> (s.<span class="built_in">size</span>() + <span class="number">1</span>); f.<span class="built_in">resize</span> (s.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">		pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (<span class="type">int</span>) s.<span class="built_in">size</span>(); i ++) pw[i] = pw[i - <span class="number">1</span>] * bs;</span><br><span class="line">		f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (<span class="type">int</span>) s.<span class="built_in">size</span>(); i ++) f[i] = f[i - <span class="number">1</span>] * bs + s[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ull <span class="title">get</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> f[r] - f[l - <span class="number">1</span>] * pw[r - l + <span class="number">1</span>]; &#125;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="区间历史最值，-区间取min"><a href="#区间历史最值，-区间取min" class="headerlink" title="区间历史最值， 区间取min"></a>区间历史最值， 区间取min</h3><p>来自洛谷模板。</p>
<p>给出一个长度为 $n$ 的数列 $A$，同时定义一个辅助数组 $B$，$B$ 开始与 $A$ 完全相同。接下来进行了 $m$ 次操作，操作有五种类型，按以下格式给出：</p>
<ul>
<li><code>1 l r k</code>：对于所有的 $i\in[l,r]$，将 $A_i$ 加上 $k$（$k$ 可以为负数）。</li>
<li><code>2 l r v</code>：对于所有的 $i\in[l,r]$，将 $A_i$ 变成 $\min(A_i,v)$。</li>
<li><code>3 l r</code>：求 $\sum_{i=l}^{r}A_i$。</li>
<li><code>4 l r</code>：对于所有的 $i\in[l,r]$，求 $A_i$ 的最大值。</li>
<li><code>5 l r</code>：对于所有的 $i\in[l,r]$，求 $B_i$ 的最大值。</li>
</ul>
<p>在每一次操作后，我们都进行一次更新，让 $B_i\gets\max(B_i,A_i)$。</p>
<p>数据规模与约定</p>
<ul>
<li>对于全部测试数据，保证 $1\leq n,m\leq 5\times 10^5$，$-5\times10^8\leq A_i\leq 5\times10^8$，$op\in[1,5]$，$1 \leq l\leq r \leq n$，$-2000\leq k\leq 2000$，$-5\times10^8\leq v\leq 5\times10^8$。</li>
</ul>
<p>下面是 2log 代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	Node *ls, *rs;</span><br><span class="line">	<span class="type">int</span> l, r;</span><br><span class="line">	<span class="type">int</span> add1, d_add1;</span><br><span class="line">	<span class="type">int</span> add2, d_add2;</span><br><span class="line">	ll sum;</span><br><span class="line">	<span class="type">int</span> mx1, mx2, cmx, d_mx1;</span><br><span class="line">	<span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> _l, <span class="type">int</span> _r) : <span class="built_in">l</span>(_l), <span class="built_in">r</span>(_r), <span class="built_in">ls</span>(<span class="literal">NULL</span>), <span class="built_in">rs</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		sum = ls -&gt; sum + rs -&gt; sum;</span><br><span class="line">		d_mx1 = <span class="built_in">max</span>(ls -&gt; d_mx1, rs -&gt; d_mx1);</span><br><span class="line">		<span class="keyword">if</span>(ls -&gt; mx1 == rs -&gt; mx1) &#123;</span><br><span class="line">			mx1 = ls -&gt; mx1;</span><br><span class="line">			mx2 = <span class="built_in">max</span>(ls -&gt; mx2, rs -&gt; mx2);</span><br><span class="line">			cmx = ls -&gt; cmx + rs -&gt; cmx;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ls -&gt; mx1 &gt; rs -&gt; mx1) &#123;</span><br><span class="line">			mx1 = ls -&gt; mx1;</span><br><span class="line">			mx2 = <span class="built_in">max</span>(ls -&gt; mx2, rs -&gt; mx1);</span><br><span class="line">			cmx = ls -&gt; cmx;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			mx1 = rs -&gt; mx1;</span><br><span class="line">			mx2 = <span class="built_in">max</span>(ls -&gt; mx1, rs -&gt; mx2);</span><br><span class="line">			cmx = rs -&gt; cmx;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pushtag</span><span class="params">(<span class="type">int</span> k1, <span class="type">int</span> d_k1, <span class="type">int</span> k2, <span class="type">int</span> d_k2)</span> </span>&#123;</span><br><span class="line">		sum += <span class="number">1ll</span> * k1 * cmx + <span class="number">1ll</span> * (r - l + <span class="number">1</span> - cmx) * k2;</span><br><span class="line">		d_add1 = <span class="built_in">max</span>(d_add1, add1 + d_k1);</span><br><span class="line">		d_mx1 = <span class="built_in">max</span>(d_mx1, mx1 + d_k1);</span><br><span class="line">		mx1 += k1; add1 += k1;</span><br><span class="line">		d_add2 = <span class="built_in">max</span>(d_add2, add2 + d_k2);</span><br><span class="line">		<span class="keyword">if</span>(mx2 != - INF) mx2 += k2;</span><br><span class="line">		add2 += k2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> mx = <span class="built_in">max</span>(ls -&gt; mx1, rs -&gt; mx1);</span><br><span class="line">		<span class="keyword">if</span>(ls -&gt; mx1 == mx) </span><br><span class="line">			ls -&gt; <span class="built_in">pushtag</span>(add1, d_add1, add2, d_add2);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ls -&gt; <span class="built_in">pushtag</span>(add2, d_add2, add2, d_add2);</span><br><span class="line">		<span class="keyword">if</span>(rs -&gt; mx1 == mx) </span><br><span class="line">			rs -&gt; <span class="built_in">pushtag</span>(add1, d_add1, add2, d_add2);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			rs -&gt; <span class="built_in">pushtag</span>(add2, d_add2, add2, d_add2);</span><br><span class="line">		add1 = d_add1 = add2 = d_add2 = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">modify1</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">			<span class="built_in">pushtag</span>(k, k, k, k);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pushdown</span>();</span><br><span class="line">		<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(L &lt;= mid) ls -&gt; <span class="built_in">modify1</span>(L, R, k);</span><br><span class="line">		<span class="keyword">if</span>(R &gt; mid) rs -&gt; <span class="built_in">modify1</span>(L, R, k);</span><br><span class="line">		<span class="built_in">upd</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">modify2</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(k &gt;= mx1) <span class="keyword">return</span> ;</span><br><span class="line">		<span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R &amp;&amp; k &gt; mx2) &#123;</span><br><span class="line">			<span class="built_in">pushtag</span>(k - mx1, k - mx1, <span class="number">0</span>, <span class="number">0</span>); <span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pushdown</span>();</span><br><span class="line">		<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(L &lt;= mid) ls -&gt; <span class="built_in">modify2</span>(L, R, k);</span><br><span class="line">		<span class="keyword">if</span>(R &gt; mid) rs -&gt; <span class="built_in">modify2</span>(L, R, k);</span><br><span class="line">		<span class="built_in">upd</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">query3</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum;</span><br><span class="line">		<span class="built_in">pushdown</span>();</span><br><span class="line">		ll sum = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(L &lt;= mid) sum += ls -&gt; <span class="built_in">query3</span>(L, R);</span><br><span class="line">		<span class="keyword">if</span>(R &gt; mid) sum += rs -&gt; <span class="built_in">query3</span>(L, R);</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query4</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> mx1;</span><br><span class="line">		<span class="built_in">pushdown</span>();</span><br><span class="line">		<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> ans = -INF;</span><br><span class="line">		<span class="keyword">if</span>(L &lt;= mid) ans = <span class="built_in">max</span>(ans, ls -&gt; <span class="built_in">query4</span>(L, R));</span><br><span class="line">		<span class="keyword">if</span>(R &gt; mid) ans = <span class="built_in">max</span>(ans, rs -&gt; <span class="built_in">query4</span>(L, R));</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query5</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> d_mx1;</span><br><span class="line">		<span class="built_in">pushdown</span>();</span><br><span class="line">		<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> ans = -INF;</span><br><span class="line">		<span class="keyword">if</span>(L &lt;= mid) ans = <span class="built_in">max</span>(ans, ls -&gt; <span class="built_in">query5</span>(L, R));</span><br><span class="line">		<span class="keyword">if</span>(R &gt; mid) ans = <span class="built_in">max</span>(ans, rs -&gt; <span class="built_in">query5</span>(L, R));</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> *a)</span> </span>&#123;</span><br><span class="line">	Node *x = <span class="keyword">new</span> <span class="built_in">Node</span>(l, r);</span><br><span class="line">	x -&gt; add1 = x -&gt; d_add1 = x -&gt; add2 = x -&gt; d_add2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">		x -&gt; sum = x -&gt; mx1 = x -&gt; d_mx1 = a[l];</span><br><span class="line">		x -&gt; mx2 = - INF; x -&gt; cmx = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	x -&gt; ls = <span class="built_in">build</span>(l, mid, a);</span><br><span class="line">	x -&gt; rs = <span class="built_in">build</span>(mid + <span class="number">1</span>, r, a);</span><br><span class="line">	x -&gt; <span class="built_in">upd</span>();</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *root;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i];</span><br><span class="line">	root = <span class="built_in">build</span>(<span class="number">1</span>, n, a);</span><br><span class="line">	<span class="keyword">while</span>(m --) &#123;</span><br><span class="line">		<span class="type">int</span> opt;</span><br><span class="line">		cin &gt;&gt; opt;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> l, r, k;</span><br><span class="line">			cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">			root -&gt; <span class="built_in">modify1</span>(l, r, k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="type">int</span> l, r, k;</span><br><span class="line">			cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">			root -&gt; <span class="built_in">modify2</span>(l, r, k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="type">int</span> l, r;</span><br><span class="line">			cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			cout &lt;&lt; root -&gt; <span class="built_in">query3</span>(l, r) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">4</span>) &#123;</span><br><span class="line">			<span class="type">int</span> l, r;</span><br><span class="line">			cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			cout &lt;&lt; root -&gt; <span class="built_in">query4</span>(l, r) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">5</span>) &#123;</span><br><span class="line">			<span class="type">int</span> l, r;</span><br><span class="line">			cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			cout &lt;&lt; root -&gt; <span class="built_in">query5</span>(l, r) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>如果功能不够， 现场使用矩阵实现即可。</li>
</ul>
<h2 id="左偏树"><a href="#左偏树" class="headerlink" title="左偏树"></a>左偏树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	Node *ls, *rs;</span><br><span class="line">	<span class="type">int</span> val, bh;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> V, <span class="type">int</span> B) &#123;</span><br><span class="line">		val = V; ls = rs = <span class="literal">NULL</span>; bh = B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">merge</span><span class="params">(Node *x, Node *y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(! x) <span class="keyword">return</span> y;</span><br><span class="line">	<span class="keyword">if</span>(! y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">if</span>(x -&gt; val &gt; y -&gt; val || (x -&gt; val == y -&gt; val &amp;&amp; x -&gt; bh &gt; y -&gt; bh))</span><br><span class="line">		<span class="built_in">swap</span>(x, y);</span><br><span class="line">	x -&gt; rs = <span class="built_in">merge</span>(x -&gt; rs, y);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">rand</span>() &amp; <span class="number">1</span>) <span class="built_in">swap</span>(x -&gt; ls, x -&gt; rs);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">	<span class="type">char</span> a = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(; ! <span class="built_in">isdigit</span>(a); a = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(a == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(; <span class="built_in">isdigit</span>(a); a = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + a - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> RandomSeed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">return</span> RandomSeed = ( <span class="number">1LL</span> * RandomSeed * <span class="number">0x66CCFF</span> % Mod + <span class="number">19260817</span>) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">int</span> ls[N], rs[N], val[N], rnd[N], sz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	sz[x] = sz[ls[x]] + sz[rs[x]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">New</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	val[++ tot] = k;</span><br><span class="line">	sz[tot] = <span class="number">1</span>;</span><br><span class="line">	rnd[tot] = <span class="built_in">rand</span>();</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(! x || ! y) <span class="keyword">return</span> x + y;</span><br><span class="line">	<span class="keyword">if</span>(rnd[x] &lt;= rnd[y]) &#123;</span><br><span class="line">		rs[x] = <span class="built_in">merge</span>(rs[x], y);</span><br><span class="line">		<span class="built_in">update</span>(x); <span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		ls[y] = <span class="built_in">merge</span>(x, ls[y]);</span><br><span class="line">		<span class="built_in">update</span>(y); <span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> k, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(! now) &#123;</span><br><span class="line">		x = y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(val[now] &lt;= k) &#123;</span><br><span class="line">		x = now;</span><br><span class="line">		<span class="built_in">split</span>(rs[x], k, rs[x], y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		y = now;</span><br><span class="line">		<span class="built_in">split</span>(ls[y], k, x, ls[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">update</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="built_in">split</span>(rt, k, a, b);</span><br><span class="line">	rt = <span class="built_in">merge</span>(a, <span class="built_in">merge</span>(<span class="built_in">New</span>(k), b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b, c;</span><br><span class="line">	<span class="built_in">split</span>(rt, k - <span class="number">1</span>, a, b);</span><br><span class="line">	<span class="built_in">split</span>(b, k, b, c);</span><br><span class="line">	b = <span class="built_in">merge</span>(ls[b], rs[b]);</span><br><span class="line">	rt = <span class="built_in">merge</span>(a, <span class="built_in">merge</span>(b, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnk</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="built_in">split</span>(rt, k - <span class="number">1</span>, a, b);</span><br><span class="line">	<span class="type">int</span> ans = sz[a] + <span class="number">1</span>;</span><br><span class="line">	rt = <span class="built_in">merge</span>(a, b);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kth</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = root;</span><br><span class="line">	<span class="keyword">while</span>(x) &#123;</span><br><span class="line">		<span class="keyword">if</span>(sz[ls[x]] &gt;= k) &#123; x = ls[x]; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		k -= sz[ls[x]] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">		x = rs[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val[<span class="built_in">Kth</span>(rt, k)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="built_in">split</span>(rt, k - <span class="number">1</span>, a, b);</span><br><span class="line">	<span class="type">int</span> ans = val[<span class="built_in">Kth</span>(a, sz[a])];</span><br><span class="line">	rt = <span class="built_in">merge</span>(a, b);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nxt</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="built_in">split</span>(rt, k, a, b);</span><br><span class="line">	<span class="type">int</span> ans = val[<span class="built_in">Kth</span>(b, <span class="number">1</span>)];</span><br><span class="line">	rt = <span class="built_in">merge</span>(a, b);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(n --) &#123;</span><br><span class="line">		<span class="type">int</span> op = <span class="built_in">read</span>(), x = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(op == <span class="number">1</span>) <span class="built_in">ins</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(op == <span class="number">2</span>) <span class="built_in">erase</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(op == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">rnk</span>(x));</span><br><span class="line">		<span class="keyword">if</span>(op == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">kth</span>(x));</span><br><span class="line">		<span class="keyword">if</span>(op == <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">pre</span>(x));</span><br><span class="line">		<span class="keyword">if</span>(op == <span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">nxt</span>(x));</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常用， 存一个数组版本， 考试如果需要动态开点随便改改就可以了。</p>
<h2 id="KDT"><a href="#KDT" class="headerlink" title="KDT"></a>KDT</h2><p>KDT没有什么封装的意义，因为平衡复杂度的操作往往需要访问内部点， 故直接贴板子。</p>
<p>来自洛谷 TATT</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="type">bool</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>()) <span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>()) x=x*<span class="number">10</span>+(c^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">if</span> (f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200500</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> d[<span class="number">5</span>], val, loc;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;k) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++) </span><br><span class="line">			<span class="keyword">if</span> (d[i] != k.d[i]) <span class="keyword">return</span> d[i] &lt; k.d[i];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N], k;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p[a].d[k] &lt; p[b].d[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls son[x][0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs son[x][1]</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> mx[N][<span class="number">4</span>], mn[N][<span class="number">4</span>], mxa[N], res[N], ans;</span><br><span class="line"><span class="function">I <span class="type">void</span> <span class="title">Mn</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">if</span> (x &gt; y) x = y; &#125;</span><br><span class="line"><span class="function">I <span class="type">void</span> <span class="title">Mx</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">if</span> (x &lt; y) x = y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">		mx[x][i] = mn[x][i] = p[x].d[i+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (ls) <span class="built_in">Mx</span>(mx[x][i], mx[ls][i]), <span class="built_in">Mn</span>(mn[x][i], mn[ls][i]);</span><br><span class="line">		<span class="keyword">if</span> (rs) <span class="built_in">Mx</span>(mx[x][i], mx[rs][i]), <span class="built_in">Mn</span>(mn[x][i], mn[rs][i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	k = d + <span class="number">1</span>, <span class="built_in">nth_element</span>(g + l, g + mid, g + r + <span class="number">1</span>, cmp);</span><br><span class="line">	son[g[mid]][<span class="number">0</span>] = <span class="built_in">build</span>(l, mid - <span class="number">1</span>, (d + <span class="number">1</span>) % <span class="number">4</span>);</span><br><span class="line">	son[g[mid]][<span class="number">1</span>] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r, (d + <span class="number">1</span>) % <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">maintain</span>(g[mid]); <span class="keyword">return</span> g[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断x点是否在y点范围以内 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">in</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>; i++) cnt += (x[i] &lt;= y[i]);</span><br><span class="line">	<span class="keyword">return</span> cnt == <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mxa[x] &lt;= tmp) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">in</span>(mn[x], p[y].d + <span class="number">1</span>)) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">in</span>(mx[x], p[y].d + <span class="number">1</span>)) <span class="keyword">return</span> tmp = mxa[x], <span class="built_in">void</span>();</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">in</span>(p[x].d + <span class="number">1</span>, p[y].d + <span class="number">1</span>)) <span class="built_in">Mx</span>(tmp, res[x]);</span><br><span class="line">	<span class="keyword">if</span> (ls) <span class="built_in">query</span>(ls, y); <span class="keyword">if</span> (rs) <span class="built_in">query</span>(rs, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活操作 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upit</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">		res[x] = tmp, <span class="built_in">Mx</span>(mxa[x], res[x]); <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">in</span>(p[y].d + <span class="number">1</span>, mx[x]) || !<span class="built_in">in</span>(mn[x], p[y].d + <span class="number">1</span>)) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 如果y点不在里面就返回 </span></span><br><span class="line">	<span class="keyword">if</span> (ls) <span class="built_in">upit</span>(ls, y); <span class="keyword">if</span> (rs) <span class="built_in">upit</span>(rs, y);</span><br><span class="line">	<span class="built_in">Mx</span>(mxa[x], mxa[ls]), <span class="built_in">Mx</span>(mxa[x], mxa[rs]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rt, n;</span><br><span class="line"><span class="type">int</span> Ans[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	rt = <span class="number">0</span>;</span><br><span class="line">	tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) g[i] = <span class="number">0</span>, son[i][<span class="number">0</span>] = son[i][<span class="number">1</span>] = <span class="number">0</span>, mxa[i] = <span class="number">0</span>, res[i] = <span class="number">0</span>;</span><br><span class="line">	ans = <span class="number">0</span>;</span><br><span class="line">	n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen (&quot;hs.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(p[i].d[<span class="number">0</span>]), <span class="built_in">read</span>(p[i].d[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">read</span>(p[i].d[<span class="number">2</span>]), <span class="built_in">read</span>(p[i].d[<span class="number">3</span>]);</span><br><span class="line">		<span class="comment">//read(p[i].d[4]), read(p[i].val);</span></span><br><span class="line">		p[i].val = <span class="number">1</span>;</span><br><span class="line">		p[i].loc = i;</span><br><span class="line">		g[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>); rt = <span class="built_in">build</span>(<span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) </span><br><span class="line">		tmp = <span class="number">0</span>, <span class="built_in">query</span>(rt, i), tmp+=p[i].val, <span class="built_in">upit</span>(rt, i), <span class="built_in">Mx</span>(ans, tmp), Ans[p[i].loc] = tmp;</span><br><span class="line">	<span class="comment">//for (int i = 1; i &lt;= n; i ++) printf(&quot;%lld\n&quot;, Ans[i]);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">	<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> Case;</span><br><span class="line">	<span class="comment">//read(Case);</span></span><br><span class="line">	 Case = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (Case --) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="LCT"><a href="#LCT" class="headerlink" title="LCT"></a>LCT</h2><p>来自洛谷模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std :: cin;</span><br><span class="line"><span class="keyword">using</span> std :: cout;</span><br><span class="line"><span class="keyword">using</span> std :: cerr;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lep(i, l, r) for(int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for(int i = (l); i &gt;= (r); i --)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) ch[x][0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) ch[x][1]</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val[N], sum[N], rev[N], ch[N][<span class="number">2</span>], fa[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	sum[x] = sum[<span class="built_in">ls</span>(x)] ^ sum[<span class="built_in">rs</span>(x)] ^ val[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">nroot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == <span class="built_in">ls</span>(fa[x]) || x == <span class="built_in">rs</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == <span class="built_in">rs</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> y = fa[x], z = fa[y], k = <span class="built_in">get</span>(x), w = ch[x][! k];</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">nroot</span>(y)) ch[z][<span class="built_in">get</span>(y)] = x; ch[x][! k] = y; ch[y][k] = w;</span><br><span class="line">	<span class="keyword">if</span> (w) fa[w] = y; fa[y] = x; fa[x] = z; <span class="built_in">upd</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	std :: <span class="built_in">swap</span>(<span class="built_in">ls</span>(x), <span class="built_in">rs</span>(x)); rev[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rev[x]) <span class="built_in">reverse</span>(<span class="built_in">ls</span>(x)), <span class="built_in">reverse</span>(<span class="built_in">rs</span>(x)), rev[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushall</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">if</span> (<span class="built_in">nroot</span>(x)) <span class="built_in">pushall</span>(fa[x]); <span class="built_in">pushdown</span>(x); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">pushall</span>(x);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">nroot</span>(x)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">nroot</span>(fa[x])) <span class="built_in">rotate</span>(<span class="built_in">get</span>(x) ? x : fa[x]);</span><br><span class="line">		<span class="built_in">rotate</span>(x);</span><br><span class="line">	&#125; <span class="built_in">upd</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; x; x = fa[y = x]) </span><br><span class="line">		<span class="built_in">splay</span>(x), <span class="built_in">rs</span>(x) = y, <span class="built_in">upd</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeroot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">access</span>(x); <span class="built_in">splay</span>(x); <span class="built_in">reverse</span>(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">makeroot</span>(x); <span class="built_in">access</span>(y); <span class="built_in">splay</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findroot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">access</span>(x); <span class="built_in">splay</span>(x);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">ls</span>(x)) x = <span class="built_in">ls</span>(x);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">splay</span>(x), x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">makeroot</span>(x);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">findroot</span>(y) != x) fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">makeroot</span>(x);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">findroot</span>(y) == x &amp;&amp; fa[y] == x &amp;&amp; <span class="built_in">ls</span>(y) == <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="built_in">makeroot</span>(x);</span><br><span class="line">		fa[y] = <span class="built_in">rs</span>(x) = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">upd</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); </span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) cin &gt;&gt; val[i], <span class="built_in">upd</span>(i);</span><br><span class="line">	<span class="keyword">while</span> (m --) &#123;</span><br><span class="line">		<span class="type">int</span> opt, x, y;</span><br><span class="line">		cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">0</span>) &#123; <span class="built_in">split</span>(x, y); cout &lt;&lt; sum[y] &lt;&lt; endl; &#125;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">1</span>) <span class="built_in">link</span>(x, y);</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">2</span>) <span class="built_in">cut</span>(x, y);</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">3</span>) &#123; <span class="built_in">splay</span>(x); val[x] = y; <span class="built_in">upd</span>(x); &#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="李超树"><a href="#李超树" class="headerlink" title="李超树"></a>李超树</h2><p>支持合并的李超树模板， 动态开点， 支持查询某个地方最小值， 每次全局加线段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">    LL k, b;</span><br><span class="line">    <span class="built_in">Line</span>(LL K = <span class="number">0</span>, LL B = <span class="number">0</span>) : <span class="built_in">k</span>(K), <span class="built_in">b</span>(B) &#123;&#125;</span><br><span class="line">    <span class="function">LL <span class="title">calc</span><span class="params">(LL x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> k * x + b; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">inter</span><span class="params">(<span class="type">const</span> Line &amp;a)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>) (a.b - b) / (k - a.k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">Line tr[N &lt;&lt; <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> ls[N &lt;&lt; <span class="number">5</span>], rs[N &lt;&lt; <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> Line &amp;lns)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(! x) &#123;</span><br><span class="line">        x = ++ tot;</span><br><span class="line">        tr[x] = lns;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(tr[x].<span class="built_in">calc</span>(l) &gt; lns.<span class="built_in">calc</span>(l) &amp;&amp; tr[x].<span class="built_in">calc</span>(r) &gt; lns.<span class="built_in">calc</span>(r)) &#123;</span><br><span class="line">        tr[x] = lns;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].<span class="built_in">calc</span>(l) &lt; lns.<span class="built_in">calc</span>(l) &amp;&amp; tr[x].<span class="built_in">calc</span>(r) &lt; lns.<span class="built_in">calc</span>(r)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> p = tr[x].<span class="built_in">inter</span>(lns);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].k &lt; lns.k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mid &lt; p) </span><br><span class="line">            <span class="built_in">insert</span>(rs[x], mid + <span class="number">1</span>, r, tr[x]),</span><br><span class="line">            tr[x] = lns;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">insert</span>(ls[x], l, mid, lns);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(mid &gt; p) </span><br><span class="line">            <span class="built_in">insert</span>(ls[x], l, mid, tr[x]), </span><br><span class="line">            tr[x] = lns;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">insert</span>(rs[x], mid + <span class="number">1</span>, r, lns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(! x || ! y) <span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].<span class="built_in">calc</span>(l) &gt; tr[y].<span class="built_in">calc</span>(l))</span><br><span class="line">            tr[x] = tr[y];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ls[x] = <span class="built_in">merge</span>(ls[x], ls[y], l, mid);</span><br><span class="line">    rs[x] = <span class="built_in">merge</span>(rs[x], rs[y], mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">insert</span>(x, l, r, tr[y]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(! x) <span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line">    LL res = tr[x].<span class="built_in">calc</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v &lt;= mid) <span class="keyword">return</span> <span class="built_in">min</span>(res, <span class="built_in">query</span>(ls[x], l, mid, v));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">min</span>(res, <span class="built_in">query</span>(rs[x], mid + <span class="number">1</span>, r, v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><p>返回所有需要修改或者查询的区间， 传入大小， 根节点和存边的vector， 如果需要排序直接按 dfn sort 即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lep(i, l, r) for(int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for(int i = (l); i &gt;= (r); i --)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(...) fprintf (stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std :: cin;</span><br><span class="line"><span class="keyword">using</span> std :: cout;</span><br><span class="line"><span class="keyword">using</span> std :: endl;</span><br><span class="line"><span class="keyword">using</span> std :: cerr;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HLD</span> &#123;</span><br><span class="line">	std :: vector&lt;<span class="type">int</span>&gt; fa, dep, dfn, sz, top, son, loc;</span><br><span class="line">	<span class="type">int</span> n, rt;</span><br><span class="line">	std :: vector&lt;std :: vector&lt;<span class="type">int</span>&gt; &gt; e;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs1</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> fx)</span> </span>&#123;</span><br><span class="line">		sz[x] = <span class="number">1</span>; dep[x] = dep[fx] + <span class="number">1</span>; fa[x] = fx;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> y : e[x]) <span class="keyword">if</span> (y != fx) &#123;</span><br><span class="line">			<span class="built_in">dfs1</span> (y, x), sz[x] += sz[y];</span><br><span class="line">			<span class="keyword">if</span> (sz[y] &gt;= sz[son[x]]) son[x] = y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs2</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> topx)</span> </span>&#123;</span><br><span class="line">		top[x] = topx;</span><br><span class="line">		dfn[x] = ++ dfn[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span> (son[x]) <span class="built_in">dfs2</span> (son[x], topx);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> y : e[x]) <span class="keyword">if</span> (y != fa[x] &amp;&amp; y != son[x]) <span class="built_in">dfs2</span> (y, y);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">(<span class="type">int</span> _n, <span class="type">int</span> _rt, std :: vector&lt;std :: pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; edge)</span> </span>&#123;</span><br><span class="line">		n = _n; rt = _rt;</span><br><span class="line">		fa.<span class="built_in">resize</span>  (n + <span class="number">1</span>);</span><br><span class="line">		dep.<span class="built_in">resize</span> (n + <span class="number">1</span>);</span><br><span class="line">		dfn.<span class="built_in">resize</span> (n + <span class="number">1</span>);</span><br><span class="line">		sz.<span class="built_in">resize</span>  (n + <span class="number">1</span>);</span><br><span class="line">		top.<span class="built_in">resize</span> (n + <span class="number">1</span>);</span><br><span class="line">		son.<span class="built_in">resize</span> (n + <span class="number">1</span>);</span><br><span class="line">		loc.<span class="built_in">resize</span> (n + <span class="number">1</span>);</span><br><span class="line">		e.<span class="built_in">resize</span> (n + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : edge) e[x].<span class="built_in">push_back</span> (y), e[y].<span class="built_in">push_back</span> (x);</span><br><span class="line">		<span class="built_in">dfs1</span> (rt, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">dfs2</span> (rt, rt);</span><br><span class="line">		<span class="built_in">lep</span> (i, <span class="number">1</span>, n) loc[dfn[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	std :: <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">subtree</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123; dfn[x], dfn[x] + sz[x] - <span class="number">1</span> &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	std :: vector&lt;std :: pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; <span class="built_in">chain</span> (<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">		std :: vector&lt;std :: pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; rec;</span><br><span class="line">		<span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) std :: <span class="built_in">swap</span> (x, y);</span><br><span class="line">			rec.<span class="built_in">push_back</span> ( &#123;dfn[top[x]], dfn[x] &#125; );</span><br><span class="line">			x = fa[top[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dep[x] &gt; dep[y]) std :: <span class="built_in">swap</span> (x, y);</span><br><span class="line">		rec.<span class="built_in">push_back</span> ( &#123;dfn[x], dfn[y]&#125; );</span><br><span class="line">		<span class="keyword">return</span> rec;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; hld;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, rt;</span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) (x &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line">i64 tr[N &lt;&lt; <span class="number">2</span>], tg[N &lt;&lt; <span class="number">2</span>], len[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	len[x] = r - l + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l == r) &#123; tr[x] = val[hld.loc[l]]; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(<span class="built_in">ls</span>(x), l, mid);</span><br><span class="line">	<span class="built_in">build</span>(<span class="built_in">rs</span>(x), mid + <span class="number">1</span>, r);</span><br><span class="line">	tr[x] = (tr[<span class="built_in">ls</span>(x)] + tr[<span class="built_in">rs</span>(x)]) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> x, i64 v)</span> </span>&#123;</span><br><span class="line">	tr[x] += v * len[x]; tg[x] += v;</span><br><span class="line">	tr[x] %= P; tg[x] %= P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tg[x]) &#123;</span><br><span class="line">		<span class="built_in">down</span>(<span class="built_in">ls</span>(x), tg[x]);</span><br><span class="line">		<span class="built_in">down</span>(<span class="built_in">rs</span>(x), tg[x]);</span><br><span class="line">		tg[x] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, i64 v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">		<span class="built_in">down</span>(x, v); <span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(x);</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(L &lt;= mid) <span class="built_in">modify</span>(<span class="built_in">ls</span>(x), l, mid, L, R, v);</span><br><span class="line">	<span class="keyword">if</span>(R &gt; mid) <span class="built_in">modify</span>(<span class="built_in">rs</span>(x), mid + <span class="number">1</span>, r, L, R, v);</span><br><span class="line">	tr[x] = (tr[<span class="built_in">ls</span>(x)] + tr[<span class="built_in">rs</span>(x)]) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[x];</span><br><span class="line">	<span class="built_in">pushdown</span>(x);</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	i64 ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L &lt;= mid) ans += <span class="built_in">query</span>(<span class="built_in">ls</span>(x), l, mid, L, R);</span><br><span class="line">	<span class="keyword">if</span>(R &gt; mid) ans += <span class="built_in">query</span>(<span class="built_in">rs</span>(x), mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">	<span class="keyword">return</span> ans % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; rt &gt;&gt; P;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) cin &gt;&gt; val[i];</span><br><span class="line">	std :: vector&lt;std :: pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; edge;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">2</span>, n) &#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		edge.<span class="built_in">push_back</span> ( &#123;x, y&#125; );</span><br><span class="line">	&#125;</span><br><span class="line">	hld.<span class="built_in">init</span> (n, rt, edge);</span><br><span class="line">	<span class="built_in">build</span> (<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">while</span> (m --) &#123;</span><br><span class="line">		<span class="type">int</span> op;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> x, y, z;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">			<span class="keyword">auto</span> vec = hld.<span class="built_in">chain</span> (x, y);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> [l, r] : vec) <span class="built_in">modify</span> (<span class="number">1</span>, <span class="number">1</span>, n, l, r, z);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="type">int</span> x, y, ans = <span class="number">0</span>;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			<span class="keyword">auto</span> vec = hld.<span class="built_in">chain</span> (x, y);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> [l, r] : vec) ans += <span class="built_in">query</span> (<span class="number">1</span>, <span class="number">1</span>, n, l, r), ans %= P;</span><br><span class="line">			cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="type">int</span> x, z;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; z;</span><br><span class="line">			<span class="keyword">auto</span> [l, r] = hld.<span class="built_in">subtree</span> (x);</span><br><span class="line">			<span class="built_in">modify</span> (<span class="number">1</span>, <span class="number">1</span>, n, l, r, z);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">			<span class="type">int</span> x;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			<span class="keyword">auto</span> [l, r] = hld.<span class="built_in">subtree</span> (x);</span><br><span class="line">			cout &lt;&lt; <span class="built_in">query</span> (<span class="number">1</span>, <span class="number">1</span>, n, l, r) % P &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h2><h3 id="ST表求LCA"><a href="#ST表求LCA" class="headerlink" title="ST表求LCA"></a>ST表求LCA</h3><p>一倍的 log 空间的lca求法。</p>
<p>$O(n \log n) - O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LCA</span> &#123;</span><br><span class="line">	std :: vector&lt;std :: vector&lt;<span class="type">int</span>&gt; &gt; e, st;</span><br><span class="line">	std :: vector&lt;<span class="type">int</span>&gt; dep, dfn; </span><br><span class="line">	<span class="type">int</span> tot;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fx)</span> </span>&#123; </span><br><span class="line">		dep[x] = dep[fx] + <span class="number">1</span>;</span><br><span class="line">		dfn[x] = ++ tot;</span><br><span class="line">		st[<span class="number">0</span>][tot] = fx;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> y : e[x]) <span class="keyword">if</span> (y != fx) <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">		x = dfn[x]; y = dfn[y];</span><br><span class="line">		<span class="keyword">if</span> (x &gt; y) std :: <span class="built_in">swap</span>(x, y);</span><br><span class="line">		<span class="type">int</span> d = <span class="built_in">log2</span> (y - x ++);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">upd</span>(st[d][x], st[d][y - (<span class="number">1</span> &lt;&lt; d) + <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">(<span class="type">int</span> n, <span class="type">int</span> rt, std :: vector&lt;std :: pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; edge)</span> </span>&#123;</span><br><span class="line">		e.<span class="built_in">resize</span> (n + <span class="number">1</span>); <span class="type">int</span> lg = <span class="built_in">log2</span> (n) + <span class="number">1</span>; tot = <span class="number">0</span>; </span><br><span class="line">		dep.<span class="built_in">resize</span> (n + <span class="number">1</span>), dfn.<span class="built_in">resize</span> (n + <span class="number">1</span>);</span><br><span class="line">		st.<span class="built_in">resize</span> (lg + <span class="number">1</span>); <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lg; i ++) st[i].<span class="built_in">resize</span> (n + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : edge) e[x].<span class="built_in">push_back</span> (y), e[y].<span class="built_in">push_back</span> (x);</span><br><span class="line">		<span class="built_in">dfs1</span> (rt, <span class="number">0</span>); </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lg; i ++) </span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; j ++)</span><br><span class="line">				st[i][j] = <span class="built_in">upd</span>(st[i - <span class="number">1</span>][j], st[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<h2 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h2><p>考虑到边权问题不进行封装， 使用的时候把lca复制过来直接跑这个就行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dfn[maxn];</span><br><span class="line"><span class="type">bool</span> valid[maxn];</span><br><span class="line"><span class="type">int</span> h[maxn], m, a[maxn], len;  <span class="comment">// 存储关键点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dfn[x] &lt; dfn[y];  <span class="comment">// 按照 dfn 序排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_virtual_tree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(h + <span class="number">1</span>, h + m + <span class="number">1</span>, cmp);  <span class="comment">// 把关键点按照 dfn 序排序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    a[++len] = h[i];</span><br><span class="line">    a[++len] = <span class="built_in">lca</span>(h[i], h[i + <span class="number">1</span>]);  <span class="comment">// 插入 lca</span></span><br><span class="line">  &#125;</span><br><span class="line">  a[++len] = h[m];</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + len + <span class="number">1</span>, cmp);  <span class="comment">// 把所有虚树上的点按照 dfn 序排序</span></span><br><span class="line">  len = <span class="built_in">unique</span>(a + <span class="number">1</span>, a + len + <span class="number">1</span>) - a - <span class="number">1</span>;  <span class="comment">// 去重</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, lc; i &lt; len; ++i) &#123;</span><br><span class="line">    lc = <span class="built_in">lca</span>(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">conn</span>(lc, a[i + <span class="number">1</span>]);  <span class="comment">// 连边，如有边权 就是 distance(lc,a[i+1])</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="dijskra-堆优化"><a href="#dijskra-堆优化" class="headerlink" title="dijskra 堆优化"></a>dijskra 堆优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">std :: vector&lt;std :: pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; e[N];</span><br><span class="line"></span><br><span class="line">i64 dis[N];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijskra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std :: priority_queue&lt;std :: pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; q;</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">	q.<span class="built_in">push</span>( &#123;<span class="number">0</span>, s&#125; ); dis[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> x = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> p : e[x]) &#123;</span><br><span class="line">			<span class="type">int</span> y, w;</span><br><span class="line">			std :: <span class="built_in">tie</span>(y, w) = p;</span><br><span class="line">			<span class="keyword">if</span> (dis[y] &gt; dis[x] + w) &#123;</span><br><span class="line">				dis[y] = dis[x] + w;</span><br><span class="line">				q.<span class="built_in">push</span>( &#123;- dis[y], y&#125; );</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 暴力实现 dijskra 每次暴力找 dis 最小的点即可。</p>
<h3 id="Johnson-全源最短路"><a href="#Johnson-全源最短路" class="headerlink" title="Johnson 全源最短路"></a>Johnson 全源最短路</h3><p>考虑解决负权边问题</p>
<p>构造点权 $val<em>i$，边权 $w</em>{u,v}$ 加上 $val_u-val_v$</p>
<p>则此时 $dis_T=realdis_T+val_S-val_T$</p>
<p>根据 $dis<em>v\leq dis_u+w</em>{u,v}$，则 $w_{u,v}+dis_u-dis_v\geq0$，所以 $val_i=dis_i$（$dis_i$ 可由一遍 SPFA 求出）</p>
<h2 id="欧拉回路-欧拉路"><a href="#欧拉回路-欧拉路" class="headerlink" title="欧拉回路/欧拉路"></a>欧拉回路/欧拉路</h2><h3 id="有向图字典序最小欧拉路"><a href="#有向图字典序最小欧拉路" class="headerlink" title="有向图字典序最小欧拉路"></a>有向图字典序最小欧拉路</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> in[N], out[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> to, next;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt, head[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	e[++ cnt] = (edge) &#123;y, head[x]&#125;; head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> top, stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = head[x]) &#123;</span><br><span class="line">		<span class="type">int</span> y = e[i].to; head[x] = e[i].next;</span><br><span class="line">		<span class="built_in">dfs</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line">	stk[++ top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n); <span class="built_in">read</span>(m);</span><br><span class="line">	vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; vec;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		<span class="built_in">read</span>(x); <span class="built_in">read</span>(y);</span><br><span class="line">		in[y] ++;</span><br><span class="line">		out[x] ++;</span><br><span class="line">		vec.<span class="built_in">pb</span>(&#123;x, y&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [&amp;] (<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> a.fi != b.fi ? a.fi &lt; b.fi : a.se &gt; b.se;&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> p : vec) <span class="built_in">push</span>(p.fi, p.se);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> u = <span class="number">1</span>, pu = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) <span class="keyword">if</span>(<span class="built_in">abs</span>(in[i] - out[i]) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>), <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) <span class="keyword">if</span>(out[i] - in[i] == <span class="number">1</span>) u = i, pu --; <span class="keyword">else</span> <span class="keyword">if</span>(in[i] - out[i] == <span class="number">1</span>) pu ++;</span><br><span class="line">	<span class="keyword">if</span>(pu == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(u);</span><br><span class="line">		<span class="built_in">rep</span> (i, top, <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stk[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h3><p>Case = 1 无向图， Case = 1有向图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> to, next, w;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>, head[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">	e[++ cnt] = (edge) &#123;y, head[x], w&#125;; head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, Case;</span><br><span class="line"><span class="type">int</span> in[N], out[N];</span><br><span class="line"><span class="type">int</span> stk[N &lt;&lt; <span class="number">2</span>], top, vis[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> &amp;i = head[x]; i; i = e[i].next) &#123;</span><br><span class="line">		<span class="type">int</span> y = e[i].to; <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(Case == <span class="number">1</span>) vis[i] = vis[i ^ <span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">else</span> vis[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> w = e[i].w; <span class="built_in">dfs</span>(y);</span><br><span class="line">		stk[++ top] = w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">	Case = <span class="built_in">read</span>();</span><br><span class="line">	n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">		<span class="type">int</span> v = <span class="built_in">read</span>(), u = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(Case == <span class="number">1</span>) &#123;</span><br><span class="line">			in[v] ++; in[u] ++;</span><br><span class="line">			<span class="built_in">add</span>(v, u, i); <span class="built_in">add</span>(u, v, - i);	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			in[u] ++; out[v] ++;</span><br><span class="line">			<span class="built_in">add</span>(v, u, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Case == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">			<span class="keyword">if</span>(in[i] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">			<span class="keyword">if</span>(in[i] != out[i]) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">		<span class="keyword">if</span>(in[i] || out[i]) &#123;</span><br><span class="line">			<span class="built_in">dfs</span>(i);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(top != m) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = top; i &gt;= <span class="number">1</span>; i --) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stk[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="K短路-（可并堆优化）"><a href="#K短路-（可并堆优化）" class="headerlink" title="K短路 （可并堆优化）"></a>K短路 （可并堆优化）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> inf = <span class="number">1e15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">double</span> E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">	<span class="type">int</span> head[N], nxt[M], to[M]; <span class="type">double</span> w[M];</span><br><span class="line">	<span class="type">int</span> cnt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">double</span> W)</span> </span>&#123;</span><br><span class="line">		to[++ cnt] = y; w[cnt] = W; nxt[cnt] = head[x]; head[x] = cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; G[<span class="number">2</span>];</span><br><span class="line">Graph *G1 = &amp;G[<span class="number">0</span>], *G2 = &amp;G[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> dis[N];</span><br><span class="line"><span class="type">int</span> vis[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijskra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> priority_queue&lt;pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; &gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) dis[i] = inf, vis[i] = <span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, n)); dis[n] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> x = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = G2 -&gt; head[x]; i; i = G2 -&gt; nxt[i]) &#123;</span><br><span class="line">			<span class="type">int</span> y = G2 -&gt; to[i];</span><br><span class="line">			<span class="keyword">if</span>(dis[y] &gt; dis[x] + G2 -&gt; w[i]) &#123;</span><br><span class="line">				dis[y] = dis[x] + G2 -&gt; w[i];</span><br><span class="line">				q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(- dis[y], y));</span><br><span class="line">				pre[y] = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].ch[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].ch[1]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> val(x) t[x].val</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> ch[<span class="number">2</span>], dist;</span><br><span class="line">	<span class="type">int</span> to; <span class="type">double</span> val;</span><br><span class="line">&#125;t[M &lt;&lt; <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">New</span><span class="params">(<span class="type">int</span> to, <span class="type">double</span> val)</span> </span>&#123;</span><br><span class="line">	tot ++;</span><br><span class="line">	t[tot] = (Node) &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, to, val&#125;;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(! x || ! y) <span class="keyword">return</span> x | y;</span><br><span class="line">	<span class="type">int</span> z = ++ tot;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">val</span>(x) &gt; <span class="built_in">val</span>(y)) <span class="built_in">swap</span>(x, y);</span><br><span class="line">	t[z] = t[x];</span><br><span class="line">	<span class="built_in">rs</span>(z) = <span class="built_in">merge</span>(<span class="built_in">rs</span>(z), y);</span><br><span class="line">	<span class="keyword">if</span>(t[<span class="built_in">ls</span>(z)].dist &lt; t[<span class="built_in">rs</span>(z)].dist) <span class="built_in">swap</span>(<span class="built_in">ls</span>(z), <span class="built_in">rs</span>(z));</span><br><span class="line">	t[z].dist = t[<span class="built_in">rs</span>(z)].dist + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rt[N];</span><br><span class="line"><span class="type">int</span> pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dis[x] &lt; dis[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; E;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">		<span class="type">int</span> x, y; <span class="type">double</span> w;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">		<span class="keyword">if</span>(x == n) &#123; </span><br><span class="line">			m --; i --; <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		G1 -&gt; <span class="built_in">push</span>(x, y, w);</span><br><span class="line">		G2 -&gt; <span class="built_in">push</span>(y, x, w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dijskra</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x ++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = G1 -&gt; head[x]; i; i = G1 -&gt; nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i == pre[x]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="type">int</span> y = G1 -&gt; to[i]; <span class="comment">// orz tyx</span></span><br><span class="line">			rt[x] = <span class="built_in">merge</span>(rt[x], <span class="built_in">New</span>(y, - dis[x] + dis[y] + G1 -&gt; w[i]));</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) pos[i] = i;</span><br><span class="line">	<span class="built_in">sort</span>(pos + <span class="number">1</span>, pos + <span class="number">1</span> + n, cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		<span class="type">int</span> x = pos[i];</span><br><span class="line">		rt[x] = <span class="built_in">merge</span>(rt[x], rt[G1 -&gt; to[pre[x]]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> priority_queue&lt;pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; &gt;q;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(E &lt; dis[<span class="number">1</span>]) &#123; cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	E -= dis[<span class="number">1</span>]; ans ++;</span><br><span class="line">	<span class="keyword">if</span>(rt[<span class="number">1</span>]) </span><br><span class="line">		q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(- dis[<span class="number">1</span>] - <span class="built_in">val</span>(rt[<span class="number">1</span>]), rt[<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> x = q.<span class="built_in">top</span>().second; <span class="type">double</span> nwval = - q.<span class="built_in">top</span>().first;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(E &lt; nwval) &#123; cout &lt;&lt; ans &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">		E -= nwval; ans ++;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">ls</span>(x)) q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(- nwval + <span class="built_in">val</span>(x) - <span class="built_in">val</span>(<span class="built_in">ls</span>(x)), <span class="built_in">ls</span>(x)));</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">rs</span>(x)) q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(- nwval + <span class="built_in">val</span>(x) - <span class="built_in">val</span>(<span class="built_in">rs</span>(x)), <span class="built_in">rs</span>(x)));</span><br><span class="line">		<span class="keyword">if</span>(rt[t[x].to]) q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(- nwval - <span class="built_in">val</span>(rt[t[x].to]), rt[t[x].to]));</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h2><h3 id="点双"><a href="#点双" class="headerlink" title="点双"></a>点双</h3><p>给出所有割点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> to, next;</span><br><span class="line">&#125; e[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt, head[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	e[++ cnt] = (edge) &#123;y, head[x]&#125;; head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[N], low[N], bj[N], num;</span><br><span class="line"><span class="type">int</span> rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fx)</span> </span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++ num;</span><br><span class="line">	<span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = e[i].next) &#123;</span><br><span class="line">		<span class="type">int</span> y = e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y == fx) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(! dfn[y]) &#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(y, x), low[x] = <span class="built_in">min</span>(low[x], low[y]), sz ++;</span><br><span class="line">			<span class="keyword">if</span>(low[y] &gt;= dfn[x] &amp;&amp; x != rt) bj[x] = <span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x == rt &amp;&amp; sz &gt;= <span class="number">2</span>) bj[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">	n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">add</span>(x, y); <span class="built_in">add</span>(y, x);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">		<span class="keyword">if</span>(! dfn[i]) rt = i, <span class="built_in">tarjan</span>(i, <span class="number">0</span>);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">		<span class="keyword">if</span>(bj[i]) ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="built_in">print</span>(ans.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i : ans) <span class="built_in">print</span>(i, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="边双"><a href="#边双" class="headerlink" title="边双"></a>边双</h3><p>给出所有割边</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> low[MAXN], dfn[MAXN], dfs_clock;</span><br><span class="line"><span class="type">bool</span> isbridge[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="type">int</span> cnt_bridge;</span><br><span class="line"><span class="type">int</span> father[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">  father[u] = fa;</span><br><span class="line">  low[u] = dfn[u] = ++dfs_clock;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="type">int</span> v = G[u][i];</span><br><span class="line">    <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v, u);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">      <span class="keyword">if</span> (low[v] &gt; dfn[u]) &#123;</span><br><span class="line">        isbridge[v] = <span class="literal">true</span>;</span><br><span class="line">        ++cnt_bridge;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dfn[v] &lt; dfn[u] &amp;&amp; v != fa) &#123;</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h3><h4 id="tarjan"><a href="#tarjan" class="headerlink" title="tarjan"></a>tarjan</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;edge;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[N], low[N], co[N], col, sum[N];</span><br><span class="line"><span class="type">int</span> stk[N], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	stk[++ top] = x;</span><br><span class="line">	dfn[x] = low[x] = ++ dfn[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> y : e[x]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(! dfn[y]) &#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(y);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(! co[y]) low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[x] == dfn[x]) &#123;</span><br><span class="line">		co[x] = ++ col;</span><br><span class="line">		sum[col] = a[x];</span><br><span class="line">		<span class="keyword">while</span>(stk[top] != x) &#123;</span><br><span class="line">			co[stk[top]] = col;</span><br><span class="line">			sum[col] += a[stk[top]];</span><br><span class="line">			top --;</span><br><span class="line">		&#125;</span><br><span class="line">		top --;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="kosoraju"><a href="#kosoraju" class="headerlink" title="kosoraju"></a>kosoraju</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// g 是原图，g2 是反图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v : g[u])</span><br><span class="line">    <span class="keyword">if</span> (!vis[v]) <span class="built_in">dfs1</span>(v);</span><br><span class="line">  s.<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  color[u] = sccCnt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v : g2[u])</span><br><span class="line">    <span class="keyword">if</span> (!color[v]) <span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sccCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) <span class="built_in">dfs1</span>(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (!color[s[i]]) &#123;</span><br><span class="line">      ++sccCnt;</span><br><span class="line">      <span class="built_in">dfs2</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小割树"><a href="#最小割树" class="headerlink" title="最小割树"></a>最小割树</h2><p>给定一个 $n$ 个点 $m$ 条边的无向连通图，多次询问两点之间的最小割</p>
<p>$n = 500, m = 1500, Q = 10^5$ 复杂度很高但是很快。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lep(i, l, r) for(int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for(int i = (l); i &gt;= (r); i --)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">3000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node_Edge</span> &#123; <span class="type">int</span> x, y, w; &#125; ;</span><br><span class="line">vector&lt;Node_Edge&gt; edge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">	vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; e[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">		e[x].<span class="built_in">push_back</span>( &#123;y, w&#125; );</span><br><span class="line">		e[y].<span class="built_in">push_back</span>( &#123;x, w&#125; );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> lg[N], dep[N];</span><br><span class="line">	<span class="type">int</span> fa[N][<span class="number">20</span>], jp[N][<span class="number">20</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fx, <span class="type">int</span> fw)</span> </span>&#123;</span><br><span class="line">		fa[x][<span class="number">0</span>] = fx;</span><br><span class="line">		jp[x][<span class="number">0</span>] = fw; </span><br><span class="line">		dep[x] = dep[fx] + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">lep</span> (i, <span class="number">1</span>, lg[dep[x]]) fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>], jp[x][i] = <span class="built_in">min</span>(jp[x][i - <span class="number">1</span>], jp[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> p : e[x]) <span class="keyword">if</span>(p.first != fx) <span class="built_in">dfs</span>(p.first, x, p.second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">qry</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">		<span class="type">int</span> ans = INF;</span><br><span class="line">		<span class="keyword">while</span>(dep[x] &gt; dep[y]) &#123;</span><br><span class="line">			<span class="type">int</span> i = lg[dep[x] - dep[y]];</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, jp[x][i]);</span><br><span class="line">			x = fa[x][i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x == y) <span class="keyword">return</span> ans;</span><br><span class="line">		<span class="built_in">rep</span> (i, lg[dep[x]], <span class="number">0</span>) <span class="keyword">if</span>(fa[x][i] ^ fa[y][i]) &#123;</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, jp[x][i]);</span><br><span class="line">			x = fa[x][i];</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, jp[y][i]);</span><br><span class="line">			y = fa[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, jp[x][<span class="number">0</span>]);</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, jp[y][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">lep</span> (i, <span class="number">2</span>, n) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Flow_Solution</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">		<span class="type">int</span> to, next, f;</span><br><span class="line">	&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> cnt;</span><br><span class="line">	<span class="type">int</span> cur[N], head[N], dep[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">		e[++ cnt] = (edge) &#123;y, head[x], f&#125;; head[x] = cnt;</span><br><span class="line">		e[++ cnt] = (edge) &#123;x, head[y], <span class="number">0</span>&#125;; head[y] = cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> S, T;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">		<span class="built_in">lep</span> (x, <span class="number">0</span>, n) dep[x] = INF, cur[x] = head[x];</span><br><span class="line">		q.<span class="built_in">push</span>(S); dep[S] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			<span class="type">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = e[i].next) &#123;</span><br><span class="line">				<span class="keyword">if</span>(e[i].f &amp;&amp; dep[e[i].to] == INF) &#123;</span><br><span class="line">					dep[e[i].to] = dep[x] + <span class="number">1</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(e[i].to); </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dep[T] != INF;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> lim)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x == T || lim == <span class="number">0</span>) <span class="keyword">return</span> lim;</span><br><span class="line">		<span class="type">int</span> flow = <span class="number">0</span>, tmp; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> &amp;i = cur[x]; i; i = e[i].next) </span><br><span class="line">			<span class="keyword">if</span>(dep[e[i].to] == dep[x] + <span class="number">1</span> &amp;&amp; (tmp = <span class="built_in">dfs</span>(e[i].to, <span class="built_in">min</span>(lim, e[i].f)))) &#123;</span><br><span class="line">				e[i].f -= tmp;</span><br><span class="line">				e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">				flow += tmp;</span><br><span class="line">				lim -= tmp;</span><br><span class="line">				<span class="keyword">if</span>(lim == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> _S, <span class="type">int</span> _T, vector&lt;<span class="type">int</span>&gt; &amp;node)</span> </span>&#123;</span><br><span class="line">		cnt = <span class="number">1</span>; S = _S; T = _T;</span><br><span class="line">		<span class="built_in">lep</span> (i, <span class="number">0</span>, n) head[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> p : :: edge) <span class="built_in">push</span>(p.x, p.y, p.w), <span class="built_in">push</span>(p.y, p.x, p.w);</span><br><span class="line">		<span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">bfs</span>()) flow += <span class="built_in">dfs</span>(S, INF);</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; Flow;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> SS = node[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> TT = node[<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> flow = Flow.<span class="built_in">solve</span>(SS, TT, node);</span><br><span class="line">	T.<span class="built_in">push</span>(SS, TT, flow);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; lnode, rnode;</span><br><span class="line">	vector&lt;Node_Edge&gt; ledge, redge;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x : node) </span><br><span class="line">		<span class="keyword">if</span>(Flow.dep[x] != INF) lnode.<span class="built_in">push_back</span>(x);</span><br><span class="line">		<span class="keyword">else</span> rnode.<span class="built_in">push_back</span>(x);</span><br><span class="line">	<span class="built_in">solve</span>(lnode);</span><br><span class="line">	<span class="built_in">solve</span>(rnode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; node;</span><br><span class="line">	n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), w = <span class="built_in">read</span>();</span><br><span class="line">		edge.<span class="built_in">push_back</span>( &#123;x, y, w&#125; );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) node.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="built_in">solve</span>(node);</span><br><span class="line">	T.<span class="built_in">build</span>();</span><br><span class="line">	<span class="type">int</span> q = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(q --) &#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, T.<span class="built_in">qry</span>(x, y));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="斯坦纳树"><a href="#斯坦纳树" class="headerlink" title="斯坦纳树"></a>斯坦纳树</h2><p>花费最小代价连通给定的 K 个点。<br>复杂度 $O (n \times 3^k + m \log m \times 2^k)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std :: cin;</span><br><span class="line"><span class="keyword">using</span> std :: cout;</span><br><span class="line"><span class="keyword">using</span> std :: cerr;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">std :: vector&lt;std :: pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; e[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">1</span> &lt;&lt; <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">std :: priority_queue&lt;std :: pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, x, y, w; i &lt;= m; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">		e[x].<span class="built_in">push_back</span>( &#123;y, w&#125; );</span><br><span class="line">		e[y].<span class="built_in">push_back</span>( &#123;x, w&#125; );</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) &#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		f[x][(<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> dijksra = [&amp;] (<span class="type">int</span> s) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> vis[N];</span><br><span class="line">		<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">		<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			<span class="type">int</span> x = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> p : e[x]) &#123;</span><br><span class="line">				<span class="type">int</span> y, w;</span><br><span class="line">				std :: <span class="built_in">tie</span>(y, w) = p;</span><br><span class="line">				<span class="keyword">if</span>(f[y][s] &gt; f[x][s] + w) &#123;</span><br><span class="line">					f[y][s] = f[x][s] + w;</span><br><span class="line">					q.<span class="built_in">push</span>( &#123;- f[y][s], y&#125; );</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; k); s ++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> t = s &amp; (s - <span class="number">1</span>); t; t = s &amp; (t - <span class="number">1</span>)) </span><br><span class="line">				f[i][s] = std :: <span class="built_in">min</span>(f[i][s], f[i][t] + f[i][s ^ t]);</span><br><span class="line">			<span class="keyword">if</span>(f[i][s] != <span class="number">0x3f3f3f3f</span>) q.<span class="built_in">push</span>( &#123;- f[i][s], i&#125; );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dijksra</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) ans = std :: <span class="built_in">min</span>(ans, f[i][(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>]);</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="竞赛图相关"><a href="#竞赛图相关" class="headerlink" title="竞赛图相关"></a>竞赛图相关</h2><h3 id="竞赛图哈密顿回路"><a href="#竞赛图哈密顿回路" class="headerlink" title="竞赛图哈密顿回路"></a>竞赛图哈密顿回路</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/TheRoadToTheGold/p/8439160.html">A Blog</a></p>
<p>在求回路之前， 先求哈密顿路。</p>
<h4 id="竞赛图哈密顿路"><a href="#竞赛图哈密顿路" class="headerlink" title="竞赛图哈密顿路"></a>竞赛图哈密顿路</h4><p>考虑增量法， 假如当前已经有了路径$v<em>1\rightarrow v_2 \rightarrow \cdots \rightarrow v_3 \rightarrow v_k$， 考虑增加一个点 $v</em>{k + 1}$ 。</p>
<ul>
<li>若存在$v<em>k \rightarrow v</em>{k + 1}$， 那么直接把 $v_{k + 1}$ 接在 $v_k$ 后面即可。</li>
<li>若存在$v<em>{k + 1} \rightarrow v_1$， 那么直接把$v</em>{k + 1}$接在前面即可。</li>
<li>否则从前往后找一个点$v<em>i$， 使得存在边$v</em>{k + 1} \rightarrow v<em>{i + 1}$， 然后把$v</em>{k + 1}$放在$v_i$后面即可。</li>
</ul>
<h4 id="竞赛图哈密顿回路-1"><a href="#竞赛图哈密顿回路-1" class="headerlink" title="竞赛图哈密顿回路"></a>竞赛图哈密顿回路</h4><p>定理：竞赛图的任意强连通子图必存在哈密顿回路。</p>
<ul>
<li>枚举起点，求哈密顿通路，判断是否首尾相连</li>
</ul>
<p>上面这个虽然不知道为什么是对的， 但是很好记对吧， <del>不记得下面这个了就用上面那个， 反正常数应该不大</del></p>
<ul>
<li>找到第一个能连回1号点的点， 设其为$L$, $1$号点为$R$， 得到了一个环， 现在扩充这个环， 使其包含所有点。</li>
<li>从$L$往后枚举每个点$i$，表示现在要把点$i$加入环中.</li>
<li>从$R$开始枚举已求出的环上的每个点，找到第一个存在边$i\rightarrow j$ 的点$j$.</li>
<li>如果找不到这样的点$j$，继续枚举$i$的下一个点。</li>
</ul>
<p><del>虽然并不知道为啥对</del></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">paint</span><span class="params">(<span class="type">int</span> ID)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; &amp;vec = blk[ID];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; &amp;ans = road[ID];</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> nxt[N], l, r;</span><br><span class="line">    <span class="built_in">memset</span>(nxt, <span class="number">0</span>, <span class="built_in">sizeof</span>(nxt));</span><br><span class="line">    l = r = vec[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">lep</span> (p, <span class="number">1</span>, vec.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> x = vec[p];</span><br><span class="line">        <span class="keyword">if</span>(e[x][l]) nxt[x] = l, l = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e[r][x]) nxt[r] = x, r = x;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> u = l; ; u = nxt[u]) <span class="keyword">if</span>(e[x][nxt[u]]) &#123;</span><br><span class="line">                nxt[x] = nxt[u];</span><br><span class="line">                nxt[u] = x; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = l; x; x = nxt[x]) <span class="keyword">if</span>(r) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = r, v = l; ; u = v, v = nxt[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(e[x][v]) &#123;</span><br><span class="line">                nxt[u] = nxt[r];</span><br><span class="line">                <span class="keyword">if</span>(u != r) nxt[r] = l;</span><br><span class="line">                l = v; r = x; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v == r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e[x][l]) r = x;</span><br><span class="line">    <span class="type">int</span> x = l;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x != <span class="number">0</span>) ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(x == r) <span class="keyword">break</span>;</span><br><span class="line">        x = nxt[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="支配树"><a href="#支配树" class="headerlink" title="支配树"></a>支配树</h2><p>返回每个点在支配树上的父亲。</p>
<p>单 log 复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> DominateTree &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> M = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> to, next;</span><br><span class="line">    &#125; e[M * <span class="number">3</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> head[<span class="number">3</span>][N], cnt;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Ins</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        e[++ cnt] = (edge) &#123;y, head[id][x]&#125;; head[id][x] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> dfn[N], stk[N], co;</span><br><span class="line">    <span class="type">int</span> fa[N];</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        stk[dfn[x] = ++ co] = x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[<span class="number">0</span>][x]; i; i = e[i].next) &#123;</span><br><span class="line">            <span class="type">int</span> y = e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(! dfn[y]) &#123;</span><br><span class="line">                fa[y] = x;</span><br><span class="line">                <span class="built_in">Tarjan</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> idom[N], sdom[N];</span><br><span class="line">    <span class="type">int</span> Fa[N], mn[N];</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == Fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">Find</span>(Fa[x]);</span><br><span class="line">        <span class="keyword">if</span>(dfn[sdom[mn[Fa[x]]]] &lt; dfn[sdom[mn[x]]]) mn[x] = mn[Fa[x]];</span><br><span class="line">        <span class="keyword">return</span> Fa[x] = res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Contract</span><span class="params">(<span class="type">int</span> st)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Tarjan</span>(st);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) sdom[i] = Fa[i] = mn[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = co; i &gt;= <span class="number">2</span>; i --) &#123;</span><br><span class="line">            <span class="type">int</span> x = stk[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = head[<span class="number">1</span>][x]; i; i = e[i].next) &#123;</span><br><span class="line">                <span class="type">int</span> y = e[i].to;</span><br><span class="line">                <span class="keyword">if</span>(! dfn[y]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">Find</span>(y);</span><br><span class="line">                <span class="keyword">if</span>(dfn[sdom[mn[y]]] &lt; dfn[sdom[x]])</span><br><span class="line">                    sdom[x] = sdom[mn[y]];</span><br><span class="line">            &#125;</span><br><span class="line">            Fa[x] = fa[x];</span><br><span class="line">            <span class="built_in">Ins</span>(<span class="number">2</span>, sdom[x], x);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = head[<span class="number">2</span>][x = fa[x]]; i; i = e[i].next) &#123;</span><br><span class="line">                <span class="type">int</span> y = e[i].to;</span><br><span class="line">                <span class="built_in">Find</span>(y);</span><br><span class="line">                idom[y] = x == sdom[mn[y]] ? x : mn[y];</span><br><span class="line">            &#125;</span><br><span class="line">            head[<span class="number">2</span>][x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= co; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> x = stk[i];</span><br><span class="line">            <span class="keyword">if</span>(idom[x] ^ sdom[x]) idom[x] = idom[idom[x]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">lep</span> (i, <span class="number">0</span>, <span class="number">2</span>) <span class="built_in">lep</span> (j, <span class="number">1</span>, n) head[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">lep</span> (i, <span class="number">1</span>, n) dfn[i] = stk[i] = fa[i] = idom[i] = sdom[i] = Fa[i] = mn[i] = <span class="number">0</span>;</span><br><span class="line">        co = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    std :: <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">solve</span><span class="params">(<span class="type">int</span> _n, <span class="type">int</span> _m, std :: vector&lt;std :: pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &amp;edge)</span> </span>&#123;</span><br><span class="line">        n = _n;</span><br><span class="line">        m = _m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y] : edge) <span class="built_in">Ins</span>(<span class="number">0</span>, x, y), <span class="built_in">Ins</span>(<span class="number">1</span>, y, x);</span><br><span class="line">        <span class="built_in">Contract</span>(<span class="number">1</span>);</span><br><span class="line">        std :: <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fa</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) fa[i] = idom[i];</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> fa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h2><p>连边条件就是如果不满足某个某个条件就向必要的那个条件连边。</p>
<p>比如 “如果是a是0， 则b是1， 那么a0 -&gt; b1 连边”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[N], low[N], stk[N], top, co[N], col;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++ dfn[<span class="number">0</span>];</span><br><span class="line">	stk[++ top] = x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> y : e[x]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(! dfn[y]) &#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(y);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(! co[y]) low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[x] == dfn[x]) &#123;</span><br><span class="line">		co[x] = ++ col;</span><br><span class="line">		<span class="keyword">while</span>(stk[top] != x) &#123;</span><br><span class="line">			co[stk[top]] = col;</span><br><span class="line">			top --;</span><br><span class="line">		&#125;</span><br><span class="line">		top --;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n); <span class="built_in">read</span>(m);</span><br><span class="line">	<span class="built_in">lep</span> (o, <span class="number">1</span>, m) &#123;</span><br><span class="line">		<span class="type">int</span> i, a, j, b;</span><br><span class="line">		<span class="built_in">read</span>(i); <span class="built_in">read</span>(a); <span class="built_in">read</span>(j); <span class="built_in">read</span>(b);</span><br><span class="line">		<span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; b == <span class="number">1</span>)</span><br><span class="line">			e[i + n].<span class="built_in">pb</span>(j), e[j + n].<span class="built_in">pb</span>(i);</span><br><span class="line">		<span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">1</span>)</span><br><span class="line">			e[i].<span class="built_in">pb</span>(j), e[j + n].<span class="built_in">pb</span>(i + n);</span><br><span class="line">		<span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; b == <span class="number">0</span>)</span><br><span class="line">			e[j].<span class="built_in">pb</span>(i), e[i + n].<span class="built_in">pb</span>(j + n);</span><br><span class="line">		<span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>)</span><br><span class="line">			e[i].<span class="built_in">pb</span>(j + n), e[j].<span class="built_in">pb</span>(i + n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n * <span class="number">2</span>) <span class="keyword">if</span>(! dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) <span class="keyword">if</span>(co[i] == co[i + n]) <span class="built_in">printf</span>(<span class="string">&quot;IMPOSSIBLE\n&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;POSSIBLE\n&quot;</span>);</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, co[i] &lt; co[i + n], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><p>直接复制最短路。</p>
<h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, next, f;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[N];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _push(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> f) &#123;</span><br><span class="line">    e[++ cnt] = (edge) &#123;y, head[x], f&#125;; head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    _push(x, y, f); _push(y, x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dep[N], cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="built_in">lep</span> (i, <span class="number">1</span>, n) cur[i] = head[i], dep[i] = INF;</span><br><span class="line">    dep[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = e[i].next) <span class="keyword">if</span>(e[i].f &amp;&amp; dep[e[i].to] == INF) &#123;</span><br><span class="line">           dep[e[i].to] = dep[x] + <span class="number">1</span>;</span><br><span class="line">           q.<span class="built_in">push</span>(e[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t] != INF;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == t || lim == <span class="number">0</span>) <span class="keyword">return</span> lim;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;i = cur[x]; i; i = e[i].next) <span class="keyword">if</span>(dep[e[i].to] == dep[x] + <span class="number">1</span> &amp;&amp; (tmp = <span class="built_in">dfs</span>(e[i].to, <span class="built_in">min</span>(lim, e[i].f)))) &#123;</span><br><span class="line">        flow += tmp;</span><br><span class="line">        e[i].f -= tmp;</span><br><span class="line">        e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">        lim -= tmp;</span><br><span class="line">        <span class="keyword">if</span>(lim == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, u, v, f; i &lt;= m; i ++) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; f;</span><br><span class="line">        <span class="built_in">push</span>(u, v, f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) ans += <span class="built_in">dfs</span>(s, INF);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Net</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">		<span class="type">int</span> to, next, f, w;</span><br><span class="line">	&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> cnt, head[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> f, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">		e[++ cnt] = (edge) &#123;y, head[x], f, w&#125;; head[x] = cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> f, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">Add</span>(x, y, f, w); <span class="built_in">Add</span>(y, x, <span class="number">0</span>, -w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> S, T;</span><br><span class="line">	<span class="type">int</span> flow, cost;</span><br><span class="line">	<span class="type">int</span> vis[N], dis[N], cur[N];</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">		<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">		<span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">		<span class="built_in">memcpy</span>(cur, head, <span class="built_in">sizeof</span>(cur));</span><br><span class="line">		q.<span class="built_in">push</span>(S); dis[S] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			<span class="type">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			vis[x] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = e[i].next) &#123;</span><br><span class="line">				<span class="type">int</span> y = e[i].to;</span><br><span class="line">				<span class="keyword">if</span>(dis[y] &gt; dis[x] + e[i].w &amp;&amp; e[i].f) &#123;</span><br><span class="line">					dis[y] = dis[x] + e[i].w;</span><br><span class="line">					<span class="keyword">if</span>(! vis[y]) &#123; vis[y] = <span class="number">1</span>; q.<span class="built_in">push</span>(y); &#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dis[T] != <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x == T) &#123;</span><br><span class="line">			flow += f;</span><br><span class="line">			cost += f * dis[T];</span><br><span class="line">			<span class="keyword">return</span> f;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> res = <span class="number">0</span>, tmp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> &amp;i = cur[x]; i; i = e[i].next) &#123;</span><br><span class="line">			<span class="type">int</span> y = e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(e[i].f &amp;&amp; dis[y] == dis[x] + e[i].w) &#123;</span><br><span class="line">				tmp = <span class="built_in">dfs</span>(y, <span class="built_in">min</span>(f - res, e[i].f));</span><br><span class="line">				e[i].f -= tmp;</span><br><span class="line">				e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">				res += tmp;</span><br><span class="line">				<span class="keyword">if</span>(res == f) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MCMF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">spfa</span>()) <span class="built_in">dfs</span>(S, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">		cout &lt;&lt; flow &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cost &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Net</span>() &#123;</span><br><span class="line">		cnt = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; net;</span><br></pre></td></tr></table></figure>
<h3 id="无源汇有上下界可行流"><a href="#无源汇有上下界可行流" class="headerlink" title="无源汇有上下界可行流"></a>无源汇有上下界可行流</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, next, f;</span><br><span class="line">&#125; e[M * <span class="number">2</span> + N * <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> low[M], upp[M];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>, head[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    e[++ cnt] = &#123;y, head[x], z&#125;;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> U[M], V[M], LOW[M], UPP[M];</span><br><span class="line"><span class="type">int</span> du[N];</span><br><span class="line"><span class="type">int</span> S, T;</span><br><span class="line"><span class="type">int</span> dep[N], cur[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, inf, <span class="built_in">sizeof</span>(dep));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (R <span class="type">int</span> i = <span class="number">1</span>; i &lt;= T; i ++)</span><br><span class="line">        cur[i] = head[i];</span><br><span class="line"></span><br><span class="line">    dep[S] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(S);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (R <span class="type">int</span> i = head[x]; i; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[i].f == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> y = e[i].to;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dep[y] &lt; inf)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dep[T] &lt; inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lim == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == T)</span><br><span class="line">        <span class="keyword">return</span> lim;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (R <span class="type">int</span> i = cur[x]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> y = e[i].to, tmp;</span><br><span class="line">        cur[x] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dep[y] == dep[x] + <span class="number">1</span> &amp;&amp; (tmp = <span class="built_in">dfs</span>(y, <span class="built_in">min</span>(lim, e[i].f)))) &#123;</span><br><span class="line">            res += tmp;</span><br><span class="line">            lim -= tmp;</span><br><span class="line">            e[i].f -= tmp;</span><br><span class="line">            e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;2.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (R <span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        U[i] = <span class="built_in">read</span>(), V[i] = <span class="built_in">read</span>(), LOW[i] = <span class="built_in">read</span>(), UPP[i] = <span class="built_in">read</span>();</span><br><span class="line">        du[U[i]] -= LOW[i];</span><br><span class="line">        du[V[i]] += LOW[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    S = n + <span class="number">1</span>;</span><br><span class="line">    T = n + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (R <span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="built_in">add</span>(U[i], V[i], UPP[i] - LOW[i]);</span><br><span class="line">        <span class="built_in">add</span>(V[i], U[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (R <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">if</span> (du[i] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">add</span>(S, i, du[i]), <span class="built_in">add</span>(i, S, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (du[i] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">add</span>(i, T, -du[i]), <span class="built_in">add</span>(T, i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>())</span><br><span class="line">        <span class="built_in">dfs</span>(S, inf);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (R <span class="type">int</span> i = head[S]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            f = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! f) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (R <span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, UPP[i] - LOW[i] - e[i * <span class="number">2</span>].f + LOW[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有源汇有上下界最大流"><a href="#有源汇有上下界最大流" class="headerlink" title="有源汇有上下界最大流"></a>有源汇有上下界最大流</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std :: cin;</span><br><span class="line"><span class="keyword">using</span> std :: cout;</span><br><span class="line"><span class="keyword">using</span> std :: cerr;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lep(i, l, r) for(int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for(int i = (l); i &gt;= (r); i --)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>, M = <span class="number">125003</span> * <span class="number">3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> S, T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, next, f, w;</span><br><span class="line">&#125; e[M];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>, head[N];</span><br><span class="line"><span class="type">void</span> _push(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> f, <span class="type">int</span> w) &#123;</span><br><span class="line">    e[++ cnt] = (edge) &#123;</span><br><span class="line">        y, head[x], f, w</span><br><span class="line">    &#125;;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> f, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;x = %d y = %d f = %d w = %d\n&quot;</span>, x, y, f, w);</span><br><span class="line">    _push(x, y, f, w);</span><br><span class="line">    _push(y, x, <span class="number">0</span>, - w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i64 dis[N];</span><br><span class="line"><span class="type">int</span> pre[N], flow[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std :: queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(S);</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="built_in">sizeof</span>(pre));</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line">    flow[S] = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].f) &#123;</span><br><span class="line">                <span class="type">int</span> y = e[i].to;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dis[y] &gt; dis[x] + e[i].w) &#123;</span><br><span class="line">                    dis[y] = dis[x] + e[i].w;</span><br><span class="line">                    pre[y] = i;</span><br><span class="line">                    flow[y] = std :: <span class="built_in">min</span>(flow[x], e[i].f);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (! vis[y])</span><br><span class="line">                        q.<span class="built_in">push</span>(y), vis[y] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre[T] != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std :: <span class="function">pair&lt;<span class="type">int</span>, i64&gt; <span class="title">ssp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">    i64 cost = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>()) &#123;</span><br><span class="line">        f += flow[T];</span><br><span class="line">        cost += dis[T] * flow[T];</span><br><span class="line">        <span class="type">int</span> tmp = T;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> i = pre[tmp];</span><br><span class="line">            e[i].f -= flow[T];</span><br><span class="line">            e[i ^ <span class="number">1</span>].f += flow[T];</span><br><span class="line">            tmp = e[i ^ <span class="number">1</span>].to;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp == S)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;f, cost&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s, t;</span><br><span class="line">std :: vector&lt;std :: tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; edge;</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    edge.<span class="built_in">resize</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edge) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, u, d;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; u &gt;&gt; d;</span><br><span class="line">        e = &#123;x, y, u, d&#125;;</span><br><span class="line">        <span class="comment">// out - in</span></span><br><span class="line">        deg[x] -= u;</span><br><span class="line">        deg[y] += u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ds = n + <span class="number">1</span>, dt = n + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">lep</span>(i, <span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deg[i] &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">push</span>(i, dt, - deg[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">push</span>(ds, i, deg[i], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edge) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, u, d;</span><br><span class="line">        std :: <span class="built_in">tie</span>(x, y, u, d) = e;</span><br><span class="line">        <span class="built_in">push</span>(x, y, d - u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push</span>(t, s, <span class="number">1e9</span>, <span class="number">0</span>);</span><br><span class="line">    S = ds;</span><br><span class="line">    T = dt;</span><br><span class="line">    <span class="type">int</span> fl = <span class="number">0</span>;</span><br><span class="line">    i64 cost = <span class="number">0</span>;</span><br><span class="line">    std :: <span class="built_in">tie</span>(fl, cost) = <span class="built_in">ssp</span>();</span><br><span class="line">    <span class="built_in">debug</span>(<span class="string">&quot;flow = %d, cost = %lld\n&quot;</span>, fl, cost);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[S]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].f) &#123;</span><br><span class="line">            f = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;please go home to sleep&quot;</span> &lt;&lt; endl, <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = e[cnt].f;</span><br><span class="line">    e[cnt].f = e[cnt ^ <span class="number">1</span>].f = <span class="number">0</span>;</span><br><span class="line">    S = s;</span><br><span class="line">    T = t;</span><br><span class="line">    std :: <span class="built_in">tie</span>(fl, cost) = <span class="built_in">ssp</span>();</span><br><span class="line">    ans += fl;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有源汇有上下界最小流"><a href="#有源汇有上下界最小流" class="headerlink" title="有源汇有上下界最小流"></a>有源汇有上下界最小流</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R register</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50000</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">125000</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> a = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; a &gt; <span class="string">&#x27;9&#x27;</span> || a &lt; <span class="string">&#x27;0&#x27;</span>; a = <span class="built_in">getchar</span>())</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; a &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; a &lt;= <span class="string">&#x27;9&#x27;</span>; a = <span class="built_in">getchar</span>())</span><br><span class="line">        x = x * <span class="number">10</span> + a - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, next, f;</span><br><span class="line">&#125; e[M * <span class="number">2</span> + N * <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> low[M], upp[M];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>, head[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    e[++ cnt] = &#123;y, head[x], z&#125;;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> U[M], V[M], LOW[M], UPP[M];</span><br><span class="line"><span class="type">int</span> du[N];</span><br><span class="line"><span class="type">int</span> S, T, s, t;</span><br><span class="line"><span class="type">int</span> dep[N], cur[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> st, <span class="type">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, inf, <span class="built_in">sizeof</span>(dep));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (R <span class="type">int</span> i = <span class="number">1</span>; i &lt;= T; i ++)</span><br><span class="line">        cur[i] = head[i];</span><br><span class="line"></span><br><span class="line">    dep[st] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (R <span class="type">int</span> i = head[x]; i; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[i].f == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> y = e[i].to;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dep[y] &lt; inf)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dep[ed] &lt; inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> lim, <span class="type">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lim == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == ed)</span><br><span class="line">        <span class="keyword">return</span> lim;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (R <span class="type">int</span> i = cur[x]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> y = e[i].to, tmp;</span><br><span class="line">        cur[x] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dep[y] == dep[x] + <span class="number">1</span> &amp;&amp; (tmp = <span class="built_in">dfs</span>(y, <span class="built_in">min</span>(lim, e[i].f), ed))) &#123;</span><br><span class="line">            res += tmp;</span><br><span class="line">            lim -= tmp;</span><br><span class="line">            e[i].f -= tmp;</span><br><span class="line">            e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;2.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="built_in">read</span>();</span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">50003</span> &amp;&amp; m == <span class="number">125003</span> &amp;&amp; s == <span class="number">50002</span> &amp;&amp; t == <span class="number">50003</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">25000</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (R <span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        U[i] = <span class="built_in">read</span>(), V[i] = <span class="built_in">read</span>(), LOW[i] = <span class="built_in">read</span>(), UPP[i] = <span class="built_in">read</span>();</span><br><span class="line">        du[U[i]] -= LOW[i];</span><br><span class="line">        du[V[i]] += LOW[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    S = n + <span class="number">1</span>;</span><br><span class="line">    T = n + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (R <span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="built_in">add</span>(U[i], V[i], UPP[i] - LOW[i]);</span><br><span class="line">        <span class="built_in">add</span>(V[i], U[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (R <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">if</span> (du[i] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">add</span>(S, i, du[i]), <span class="built_in">add</span>(i, S, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (du[i] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">add</span>(i, T, -du[i]), <span class="built_in">add</span>(T, i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">add</span>(t, s, inf);</span><br><span class="line">    <span class="built_in">add</span>(s, t, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>(S, T))</span><br><span class="line">        <span class="built_in">dfs</span>(S, inf, T);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (R <span class="type">int</span> i = head[S]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            f = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! f) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please go home to sleep\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p = head[t] ^ <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = e[cnt].f;</span><br><span class="line">    e[cnt].f = e[cnt ^ <span class="number">1</span>].f = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>(t, s))</span><br><span class="line">        ans -= <span class="built_in">dfs</span>(t, inf, s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小树形图"><a href="#最小树形图" class="headerlink" title="最小树形图"></a>最小树形图</h2><p>$O (n ^ 2)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, _rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zl</span><span class="params">(<span class="type">int</span> rt, std :: vector&lt;std :: tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; &gt; &amp;edge)</span> </span>&#123;</span><br><span class="line">	std :: <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lp</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">tp</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">fa</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">mn</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	i64 ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) mn[i] = <span class="number">0x3f3f3f3f</span>, fa[i] = tp[i] = lp[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;o : edge) &#123;</span><br><span class="line">			<span class="type">int</span> x, y, w;</span><br><span class="line">			std :: <span class="built_in">tie</span>(x, y, w) = o;</span><br><span class="line">			<span class="keyword">if</span>(x != y &amp;&amp; w &lt; mn[y]) &#123;</span><br><span class="line">				mn[y] = w; fa[y] = x;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		mn[rt] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">			ans += mn[i];</span><br><span class="line">			<span class="keyword">if</span>(mn[i] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">				<span class="keyword">return</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>; x &lt;= n; x ++, y = x) &#123;</span><br><span class="line">			<span class="keyword">while</span>(y != rt &amp;&amp; tp[y] != x &amp;&amp; ! lp[y]) </span><br><span class="line">				tp[y] = x, y = fa[y];</span><br><span class="line">			<span class="keyword">if</span>(y != rt &amp;&amp; ! lp[y]) &#123;</span><br><span class="line">				lp[y] = ++ tot;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k = fa[y]; k != y; k = fa[k]) lp[k] = tot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tot == <span class="number">0</span>) </span><br><span class="line">			<span class="keyword">return</span> cout &lt;&lt; ans &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">			<span class="keyword">if</span>(! lp[i]) lp[i] = ++ tot;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;o : edge) &#123;</span><br><span class="line">			<span class="type">int</span> x, y, w;</span><br><span class="line">			std :: <span class="built_in">tie</span>(x, y, w) = o;</span><br><span class="line">			w -= mn[y];</span><br><span class="line">			x = lp[x];</span><br><span class="line">			y = lp[y];</span><br><span class="line">			o = &#123;x, y, w&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		n = tot; rt = lp[rt]; tot = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; _rt;</span><br><span class="line">	std :: vector&lt;std :: tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; &gt; <span class="built_in">edge</span>(m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;o : edge)</span><br><span class="line">		cin &gt;&gt; std :: <span class="built_in">get</span>&lt;<span class="number">0</span>&gt; (o) &gt;&gt; std :: <span class="built_in">get</span>&lt;<span class="number">1</span>&gt; (o) &gt;&gt; std :: <span class="built_in">get</span>&lt;<span class="number">2</span>&gt; (o); </span><br><span class="line">	<span class="built_in">zl</span>(_rt, edge);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一般图最大匹配-带花树"><a href="#一般图最大匹配-带花树" class="headerlink" title="一般图最大匹配(带花树)"></a>一般图最大匹配(带花树)</h2><p>$O (n^3)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std :: cin;</span><br><span class="line"><span class="keyword">using</span> std :: cout;</span><br><span class="line"><span class="keyword">using</span> std :: cerr;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lep(i, l, r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for (int i = (l); i &gt;= (r); i --)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">std :: vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> match[N], pre[N], vis[N], fa[N], dfn[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (++ cnt, x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y); dfn[x] != cnt; ) &#123;</span><br><span class="line">		dfn[x] = cnt; </span><br><span class="line">		x = <span class="built_in">find</span>(pre[match[x]]);</span><br><span class="line">		<span class="keyword">if</span> (y) std :: <span class="built_in">swap</span>(x, y);</span><br><span class="line">	&#125; <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">blossom</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, std :: queue&lt;<span class="type">int</span>&gt; &amp;q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">find</span>(x) != w) &#123;</span><br><span class="line">		pre[x] = y; y = match[x];</span><br><span class="line">		<span class="keyword">if</span> (vis[y] == <span class="number">2</span>) vis[y] = <span class="number">1</span>, q.<span class="built_in">push</span>(y);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">find</span>(x) == x) fa[x] = w;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">find</span>(y) == y) fa[y] = w;</span><br><span class="line">		x = pre[y];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) fa[i] = i, pre[i] = vis[i] = <span class="number">0</span>;</span><br><span class="line">	std :: queue&lt;<span class="type">int</span>&gt; q; q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u = q.<span class="built_in">front</span>(), t;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> v : e[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">find</span>(u) == <span class="built_in">find</span>(v) || vis[v] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (vis[v] == <span class="number">0</span>) &#123;</span><br><span class="line">				vis[v] = <span class="number">2</span>; pre[v] = u;</span><br><span class="line">				<span class="keyword">if</span> (match[v] == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> x = v, lst; x; x = lst) </span><br><span class="line">						lst = match[pre[x]], match[x] = pre[x], match[pre[x]] = x;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				vis[match[v]] = <span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(match[v]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">blossom</span>(u, v, t = <span class="built_in">lca</span>(u, v), q), <span class="built_in">blossom</span>(v, u, t, q);</span><br><span class="line">		&#125;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		e[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		e[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="keyword">if</span> (match[i] == <span class="number">0</span>) ans += <span class="built_in">search</span>(i);</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cout &lt;&lt; match[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图最大权完美匹配（KM）"><a href="#二分图最大权完美匹配（KM）" class="headerlink" title="二分图最大权完美匹配（KM）"></a>二分图最大权完美匹配（KM）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std :: cin;</span><br><span class="line"><span class="keyword">using</span> std :: cout;</span><br><span class="line"><span class="keyword">using</span> std :: cerr;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lep(i, l, r) for(int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for(int i = (l); i &gt;= (r); i --)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Lep(i, l, r) for(int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(...) fprintf (stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> i64 inf = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">i64 mp[N][N];</span><br><span class="line"><span class="type">int</span> match[N], pre[N], vis[N];</span><br><span class="line">i64 ex[N], ey[N], slack[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x, y = <span class="number">0</span>, o;</span><br><span class="line">	<span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="built_in">sizeof</span>(pre));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) slack[i] = inf;</span><br><span class="line">	match[<span class="number">0</span>] = u;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		i64 d = inf; x = match[y]; vis[y] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="keyword">if</span>(! vis[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(slack[i] &gt; ex[x] + ey[i] - mp[x][i]) </span><br><span class="line">				slack[i] = ex[x] + ey[i] - mp[x][i], pre[i] = y;</span><br><span class="line">			<span class="keyword">if</span>(slack[i] &lt; d) d = slack[i], o = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) </span><br><span class="line">			<span class="keyword">if</span>(vis[i]) ex[match[i]] -= d, ey[i] += d;</span><br><span class="line">			<span class="keyword">else</span> slack[i] -= d;</span><br><span class="line">		y = o; </span><br><span class="line">		<span class="keyword">if</span>(match[y] == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(y) match[y] = match[pre[y]], y = pre[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">km</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(match, <span class="number">-1</span>, <span class="built_in">sizeof</span>(match));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)), <span class="built_in">bfs</span>(i);</span><br><span class="line">	i64 ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="keyword">if</span>(match[i] != <span class="number">-1</span>) ans += mp[match[i]][i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) <span class="built_in">lep</span> (j, <span class="number">1</span>, n) mp[i][j] = - inf;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">		<span class="type">int</span> x, y, w;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">		mp[x][y] = w;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">km</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cout &lt;&lt; match[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图的绝对中心（最小直径生成树）"><a href="#图的绝对中心（最小直径生成树）" class="headerlink" title="图的绝对中心（最小直径生成树）"></a>图的绝对中心（最小直径生成树）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lep</span> (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">       <span class="built_in">sort</span>(rnk[i] + <span class="number">1</span>, rnk[i] + <span class="number">1</span> + n, [&amp;] (<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> dis[i][a] &gt; dis[i][b]; &#125; );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> ans = <span class="number">2e9</span>;</span><br><span class="line">   <span class="built_in">lep</span> (i, <span class="number">1</span>, n) <span class="built_in">lep</span> (j, <span class="number">1</span>, n) <span class="keyword">if</span>(j != i) &#123;</span><br><span class="line">       ans = <span class="built_in">min</span>(ans, dis[i][rnk[i][<span class="number">1</span>]] + dis[i][rnk[i][<span class="number">2</span>]]);</span><br><span class="line">       ans = <span class="built_in">min</span>(ans, dis[j][rnk[j][<span class="number">1</span>]] + dis[j][rnk[j][<span class="number">2</span>]]);</span><br><span class="line">       <span class="type">int</span> las = <span class="number">1</span>;</span><br><span class="line">       <span class="built_in">lep</span> (nw, <span class="number">2</span>, n) <span class="keyword">if</span>(dis[j][rnk[i][las]] &lt; dis[j][rnk[i][nw]])</span><br><span class="line">           ans = <span class="built_in">min</span>(ans, dis[j][rnk[i][las]] + dis[i][rnk[i][nw]] + dis[i][j]), las = nw;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>找到绝对中心以后， 跑最短路树即可。</p>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="EXCRT"><a href="#EXCRT" class="headerlink" title="EXCRT"></a>EXCRT</h2><p>使用 pair 存式子。第一个是 $a$， 第二个是 $b$ ， 表示 $x \equiv b \pmod a$ 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">i64 <span class="title">gcd</span><span class="params">(i64 x, i64 y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> y ? <span class="built_in">gcd</span>(y, x % y) : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">lcm</span><span class="params">(i64 x, i64 y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x / <span class="built_in">gcd</span>(x, y) * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(i64 a, i64 b, i64 &amp;x, i64 &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (! b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, <span class="built_in">void</span>();</span><br><span class="line">	<span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">	i64 t = x; x = y; y = t - a / b * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std :: <span class="function">pair&lt;i64, i64&gt; <span class="title">merge</span><span class="params">(std :: pair&lt;i64, i64&gt; f1, std :: pair&lt;i64, i64&gt; f2)</span> </span>&#123;</span><br><span class="line">	i64 a1 = f1.first, a2 = f2.first, b1 = f1.second, b2 = f2.second;</span><br><span class="line">	i64 k1, k2;</span><br><span class="line">	<span class="built_in">exgcd</span>(a1, - a2, k1, k2);</span><br><span class="line">	<span class="comment">// gcd (a1, - a2)</span></span><br><span class="line">	i64 d = (b2 - b1);</span><br><span class="line">	<span class="keyword">if</span> (d % <span class="built_in">gcd</span>(a1, - a2) != <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">	i64 r = (__int128) a1 * k1 - (__int128) a2 * k2;</span><br><span class="line">	d /= r;</span><br><span class="line">	k1 *= d;</span><br><span class="line">	k2 *= d;</span><br><span class="line">	i64 lc = <span class="built_in">lcm</span>(a1, a2);</span><br><span class="line">	i64 b = (b1 + (__int128) (k1 % lc + lc) % lc * a1 % lc) % lc;</span><br><span class="line">	<span class="keyword">return</span> &#123;lc, b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	n --;</span><br><span class="line">	i64 a, b;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">while</span> (n --) &#123;</span><br><span class="line">		i64 c, d;</span><br><span class="line">		cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">		std :: <span class="built_in">tie</span>(a, b) = <span class="built_in">merge</span>( &#123;a, b&#125;, &#123;c, d&#125; );</span><br><span class="line">		<span class="comment">//cerr &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="扩展lulas"><a href="#扩展lulas" class="headerlink" title="扩展lulas"></a>扩展lulas</h2><p>$O(P) $ .<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL __int128</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k, <span class="type">int</span> P)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span>; x %= P;</span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL) res * x % P;</span><br><span class="line">		x = (LL) x * x % P; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> y ? <span class="built_in">gcd</span>(y, x % y) : x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(! b) &#123; x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	<span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">	<span class="type">int</span> t = x; x = y; y = t - a / b * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inv</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">	x = (x % p + p) % p;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> P, <span class="type">int</span> PK)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= PK; i ++)</span><br><span class="line">		<span class="keyword">if</span>(i % P) a = a * i % PK;</span><br><span class="line"></span><br><span class="line">	a = <span class="built_in">power</span>(a, n / PK, PK); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n / PK * PK; i &lt;= n; i ++)	</span><br><span class="line">		<span class="keyword">if</span>(i % P) b = b * (i % PK) % PK;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">F</span>(n / P, P, PK) * a % PK * b % PK; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">G</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> P)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt; P) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">G</span>(n / P, P) + (n / P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C_PK</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> P, <span class="type">int</span> PK)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> fz = <span class="built_in">F</span>(n, P, PK);</span><br><span class="line">	<span class="type">int</span> fm1 = <span class="built_in">inv</span>(<span class="built_in">F</span>(m, P, PK), PK);</span><br><span class="line">	<span class="type">int</span> fm2 = <span class="built_in">inv</span>(<span class="built_in">F</span>(n - m, P, PK), PK);</span><br><span class="line">	<span class="type">int</span> res = <span class="built_in">power</span>(P, <span class="built_in">G</span>(n, P) - <span class="built_in">G</span>(m, P) - <span class="built_in">G</span>(n - m, P), PK);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; F(n, P, PK) &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">return</span> fz * fm1 % PK * fm2 % PK * res % PK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exlucas</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> P)</span> </span>&#123;</span><br><span class="line">	vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; factor;</span><br><span class="line">	<span class="type">int</span> t = P;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= t; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(t % i == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(t % i == <span class="number">0</span>) tmp *= i, t /= i;</span><br><span class="line">			<span class="comment">//cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; tmp  &lt;&lt; endl;</span></span><br><span class="line">			factor.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(tmp, <span class="built_in">C_PK</span>(n, m, i, tmp) ));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t &gt; <span class="number">1</span>) factor.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(t, <span class="built_in">C_PK</span>(n, m, t, t)));</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pp : factor) &#123;</span><br><span class="line">		<span class="type">int</span> a = pp.first, b = pp.second;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">		<span class="type">int</span> M = P / a, in = <span class="built_in">inv</span>(M, a);</span><br><span class="line">		ans = (ans + b * M % P * in % P) % P;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><blockquote>
<p>用来在非线性时间内求积性函数前缀和</p>
</blockquote>
<p>设现在要求积性函数 $f$ 的前缀和， 设  $\sum \limits_{i=1}^{n} f(i) = S(n)$。</p>
<p>再找一个积性函数 $g$ ，则考虑它们的狄利克雷卷积的前缀和</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^{n}(f*g)(i)</script><script type="math/tex; mode=display">
\begin{aligned} &= \sum\limits_{i=1}^{n} \sum \limits _{d|i} f(d)g(\frac{i}{d}) \\ &= \sum \limits _{d=1}^{n} g(d)\sum\limits _{i=1}^{\lfloor \frac{n}{d}\rfloor } f(i) \\ &= \sum \limits _{d=1}^{n} g(d) S(\lfloor \frac{n}{d} \rfloor) \end{aligned}</script><p>再考虑一个式子</p>
<script type="math/tex; mode=display">
g(1)S(n)=\sum \limits _{i=1}^{n} g(i) S(\lfloor \frac{n}{i} \rfloor) - \sum \limits _{i=2}^{n} g(i) S(\lfloor \frac{n}{i} \rfloor)</script><p>所以得到杜教筛的核心式子：</p>
<script type="math/tex; mode=display">
g(1)S(n)=\sum\limits_{i=1}^{n}(f*g)(i) - \sum \limits _{i=2}^{n} g(i) S(\lfloor \frac{n}{i} \rfloor)</script><p>找到一个合适的积性函数 $g$ ，使得可以快速算出 $\sum\limits_{i=1}^{n}(f*g)(i)$ 和 $g$ 的前缀和，便可以用数论分块递归地求解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">F_sum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">5e6</span>) <span class="keyword">return</span> f[n];</span><br><span class="line">	<span class="type">int</span> &amp;sum = n &lt;= m ? F[n] : F[m + ::n / n];</span><br><span class="line">	<span class="keyword">if</span>(sum) <span class="keyword">return</span> sum; sum = <span class="built_in">FG_sum</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">l</span>(<span class="number">2</span>), r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">		r = n / (n / l), sum -= (<span class="built_in">G_sum</span>(r) - <span class="built_in">G_sum</span>(l - <span class="number">1</span>)) * <span class="built_in">F_sum</span>(n / l);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul>
<li><p>记忆化：</p>
<p>  上面的求和过程中出现的都是 $\lfloor \frac{n}{i} \rfloor$ 。开一个大小为两倍 $\sqrt n$ 的数组 $dp$ 记录答案。</p>
<p>  若 $x \leq \sqrt n$ ，返回 <code>dp[x]</code> ，否则返回 <code>dp[sqrt n + n / x]</code> 即可。</p>
</li>
<li><p>杜教筛的重点是对于要求的 $f$，找到 $(f<em>g)$，满足 $g,(f</em>g)$ 的前缀和都很好求出，如果没办法背下常见的狄利克雷卷积结果，不妨直接枚举几个情况试试，来两例子： </p>
<ul>
<li>$f(n)=\mu(n)n^2,g(n)=n^2,(f*g)(n)=[n=1]$；</li>
<li>$f(n)=\varphi(n)n^2,g(n)=n^2,(f*g)(n)=n^3$；</li>
</ul>
</li>
</ul>
<p>下面是$\varphi$ 和 $\mu$ 的前缀和。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[N], p[N], tot;</span><br><span class="line">LL mu[N], phi[N];</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, LL&gt; smu, sphi;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Smu</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt; N) <span class="keyword">return</span> mu[n];</span><br><span class="line">	<span class="keyword">if</span>(smu.<span class="built_in">count</span>(n)) <span class="keyword">return</span> smu[n];</span><br><span class="line">	LL res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(R LL i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		<span class="type">int</span> nx = (n / (n / i));</span><br><span class="line">		res -= (LL) <span class="built_in">Smu</span>(n / i) * (nx - i + <span class="number">1</span>);</span><br><span class="line">		i = nx;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> smu[n] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Sphi</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt; N) <span class="keyword">return</span> phi[n];</span><br><span class="line">	<span class="keyword">if</span>(sphi.<span class="built_in">count</span>(n)) <span class="keyword">return</span> sphi[n];</span><br><span class="line">	LL res = (LL) n * ((LL) n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(R LL i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		<span class="type">int</span> nx = (n / (n / i));</span><br><span class="line">		res -= (LL) <span class="built_in">Sphi</span>(n / i) * (nx - i + <span class="number">1</span>);</span><br><span class="line">		i = nx;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sphi[n] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> IN</span></span><br><span class="line">	<span class="comment">//freopen(&quot;.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	mu[<span class="number">1</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(R <span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			p[++ tot] = i; mu[i] = <span class="number">-1</span>; phi[i] = i - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(R <span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; p[j] * i &lt; N; j ++) &#123;</span><br><span class="line">			vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">				mu[i * p[j]] = <span class="number">0</span>;</span><br><span class="line">				phi[i * p[j]] = phi[i] * p[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mu[i * p[j]] = - mu[i];</span><br><span class="line">			phi[i * p[j]] = phi[i] * (p[j] - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(R <span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++) mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(R <span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++) phi[i] += phi[i - <span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(T --) &#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, <span class="built_in">Sphi</span>(x), <span class="built_in">Smu</span>(x));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Min25"><a href="#Min25" class="headerlink" title="Min25"></a>Min25</h2><p><strong>用途</strong></p>
<ul>
<li>求积性函数前缀和。</li>
<li>要求该积性函数在质数点的取值为关于$p$的多项式或者可以用完全积性函数模拟出来。</li>
</ul>
<p><strong>简介</strong></p>
<p>$\text{Min25}$筛还有一个本质上等价的筛法叫洲阁筛， 其本质来源于扩展的线性筛法。<br>不妨考虑一下线性筛法的复杂度瓶颈， 其统计答案利用的是枚举每个质因子去贡献其倍数的答案， 然后利用每个数被最小质因子筛去一次的性质进行答案计算。但是事实上在线性筛的过程中在大于$\sqrt{n}$的质因子的贡献方式相当劣， 实际上只贡献了自己的答案， 考虑根号分治优化这个过程， 然后就有了$\text{Min25}$和洲阁筛两个基于根号分治的筛法。</p>
<p><strong>求解</strong></p>
<p>大体分三个步骤。</p>
<ul>
<li>筛出$1\dots\sqrt{n}$中的质数。</li>
<li>求解质数处函数的取值。</li>
<li>求解合数处函数的取值。</li>
</ul>
<p>不妨设答案为：</p>
<script type="math/tex; mode=display">\sum_{i = 1}^nf(i)</script><p><strong>求质数点</strong></p>
<p>为了后文的推导， 使用多个完全积性函数代替原来的$f$函数。不妨将这个函数记作$f_0$。<br>考虑设数组$g$， 其意义为：</p>
<script type="math/tex; mode=display">g(n, j) = \sum_{i = 1} ^ nf_0(i)[i是质数或者i的最小质因子大于P_j]</script><p>那么显然$g(n, 0) = \sum_{i = 2}^nf_0(i)$是容易求出的， 考虑递推$g(n, j)$。</p>
<script type="math/tex; mode=display">g(n, j) = g(n, j - 1) - f_0(P_j) \times (g(\lfloor \frac{n}{P_j} \rfloor, j - 1) - \sum_{i = 1}^{j - 1}f_0(P_i)[P_i\leq \lfloor \frac{n}{P_j} \rfloor)</script><p>意义就是对于所有最小质因子为$P<em>j$的数提取到外面， 那么只要剩下的在$\lfloor \frac{n}{P_j} \rfloor$的这一部分中的数没有被$P_1\dots P</em>{j - 1}$这些质数筛除掉，答案中就会计入贡献，但是其中可能会有小于$\lfloor \frac{n}{P<em>j} \rfloor$的$P_1\dots P</em>{j - 1}$这些质数会计算到答案里面， 但是根据我们的状态这一部分是重复贡献的， 所以需要减掉。考虑放缩掉$P_i$，那么总的转移式就是：</p>
<script type="math/tex; mode=display">g(n, j) = g(n, j - 1) \ \ \ \ \ \ \ n \leq P_j ^ 2 \\ g(n, j) = g(n, j - 1) - f_0(P_j) \times (g(\lfloor \frac{n}{P_j} \rfloor, j - 1) - \sum_{i = 1}^{j - 1}f_0(P_i)) \ \ \ \ n > P_j^2</script><p>由于第一维只有$\sqrt{n}$种状态， 第二维的数代表的质数的平方不得超过$\sqrt{n}$, 所以复杂度约为$\frac{n ^{\frac{3}{4}}}{\log_n}$。</p>
<p><strong>求合数点</strong></p>
<p>设数组$s$， 其意义为:</p>
<script type="math/tex; mode=display">S(n, j) = \sum_{i = 1}^ nf(i)[i是合数且i的最小质因子大于等于P_j]</script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意质数处是或， 此处是且， 且要求为大于等于某个数。</span><br></pre></td></tr></table></figure>
<p>同样考虑递推， 考虑枚举当前考虑到的质因子的次数并分类讨论。</p>
<script type="math/tex; mode=display">S(n, j) = 0 \ \ \ \ \  P_j^2 > n \\ S(n, j) = S(n, j + 1)+\sum_{e = 1}( f(P_j^e) \times (S(\lfloor\frac{n}{p_j^e}\rfloor, j + 1) + \sum_{i = j + 1}f(P_i)[P_iP_j^e\leq n]) + f(P_j^{e + 1}) \  \ \ \  P_j^2 \leq n</script><p>实际上就是一次性除完最小质因子来递推。</p>
<ul>
<li>除完后为合数， 由积性函数的性质即可。</li>
<li>除完以后为质数， 考虑计算大于$P_j$的质数贡献。</li>
<li>除完以后为$1$， 直接加上即可， 为了是合数将$e$增加$1$。</li>
</ul>
<p>可以发现这三种转移$P<em>j^{e + 1} \leq n$, 于是$e$的上限就知道了。<br>考虑快速计算$\sum</em>{i = j + 1}f(P_i) [P_iP_j^e\leq n]$。差分一下就可以得到下式：</p>
<script type="math/tex; mode=display">\sum_{i = j + 1}f(P_i) [P_iP_j^e\leq n] = g(\lfloor\frac{n}{p^e}\rfloor, m) - \sum_{i = 1}^jf(P_i)[P_iP_j^e\leq n]</script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m 是筛出来的最大的质数的标号。</span><br></pre></td></tr></table></figure>
<p>答案就是$g(n, m) + S(n, 1) + f(1)$。</p>
<p><strong>一点理解</strong></p>
<p>实质上似乎是先有对于合数的推导， 然后为了解决其中一个求质数点前缀和的问题才引入了质数部分的求解。<br>这其实也启示我们， 质数部分的求解我们要求的只有那$\sqrt{n}$个前缀和， <strong>我们完全可以先求出标准的完全积性函数再对那些前缀和进行修正！</strong></p>
<p><strong>代码实现</strong></p>
<ul>
<li>在写代码的时候对于第一维离散化， 具体地， 先整除分块求出会有哪些点， 然后对于小于$\sqrt{n}$的和大于的分别开数组$id_0$和$id_1$记录标号。</li>
<li>求质数点的时候可以把函数拆成很多完全积性函数。</li>
<li>递推$g, S$的时候使用滚动数组。</li>
<li>递推的时候把第二维放外面， 第一维从$1 -&gt; num$枚举标号也就是从大到小枚举， 第二维求$g$的时候从小到大， 求$S$的时候从大到小枚举。</li>
</ul>
<p><strong>模板(Luogu 5325)</strong></p>
<p>定义积性函数$f(x)$，且$f(p^k)=p^k(p^k-1)$（$p$是一个质数），求</p>
<script type="math/tex; mode=display">\sum_{i=1}^n f(i)</script><p>对$10^9+7$取模。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inv6 = (P + <span class="number">1</span>) / <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>  res = <span class="number">1</span>; x %= P;</span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = res * x % P;</span><br><span class="line">		x =  x * x % P; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> sqr, id0[N], id1[N];</span><br><span class="line"><span class="type">int</span> val[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pos</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v &lt;= sqr) <span class="keyword">return</span> id0[v];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> id1[n / v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[N], pri[N], tot;</span><br><span class="line"><span class="type">int</span> g1[N &lt;&lt; <span class="number">1</span>], g2[N &lt;&lt; <span class="number">1</span>], s[N &lt;&lt; <span class="number">1</span>], g[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">	ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin &gt;&gt; n; sqr = <span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= sqr; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(! vis[i]) pri[++ tot] = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * pri[j] &lt;= sqr; j ++) &#123;</span><br><span class="line">			vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>; l &lt;= n; l = r = r + <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> tmp = n / l;</span><br><span class="line">		r = n / tmp;</span><br><span class="line">		val[++ num] = tmp;</span><br><span class="line">		<span class="keyword">if</span>(tmp &lt;= sqr) id0[tmp] = num;</span><br><span class="line">		<span class="keyword">else</span> id1[n / tmp] = num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i ++) &#123;</span><br><span class="line">		g1[i] = val[i] % P;</span><br><span class="line">		g1[i] = g1[i] * (g1[i] + <span class="number">1</span>) / <span class="number">2</span> % P;</span><br><span class="line">		g1[i] = (g1[i] + P - <span class="number">1</span>) % P;</span><br><span class="line">		</span><br><span class="line">		g2[i] = val[i] % P;</span><br><span class="line">		g2[i] = g2[i] * (g2[i] + <span class="number">1</span>) % P * (g2[i] * <span class="number">2</span> + <span class="number">1</span>) % P * inv6 % P;</span><br><span class="line">		g2[i] = (g2[i] + P - <span class="number">1</span>) % P;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sm1 = <span class="number">0</span>, sm2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot; j ++) &#123;</span><br><span class="line">		<span class="type">int</span> pj = pri[j];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= num; k ++) &#123;</span><br><span class="line">			<span class="type">int</span> va = val[k];</span><br><span class="line">			<span class="keyword">if</span>(va / pj &lt; pj) <span class="keyword">break</span>;</span><br><span class="line">			g1[k] = (P - pj * (P - sm1 + g1[<span class="built_in">pos</span>(va / pj)] % P) % P + g1[k]) % P;</span><br><span class="line">			g2[k] = (P - pj * pj % P * (P - sm2 + g2[<span class="built_in">pos</span>(va / pj)]) % P + g2[k]) % P;</span><br><span class="line">		&#125;</span><br><span class="line">		sm1 = (sm1 + pj) % P;</span><br><span class="line">		sm2 = (sm2 + pj * pj % P) % P;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sm = (sm2 - sm1 + P) % P;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i ++) g[i] = (P - g1[i] + g2[i]) % P;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = tot; j &gt;= <span class="number">1</span>; j --) &#123;</span><br><span class="line">		<span class="type">int</span> pj = pri[j];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= num; k ++) &#123;</span><br><span class="line">			<span class="type">int</span> va = val[k], pje = pj;</span><br><span class="line">			<span class="keyword">if</span>(va &lt; pje * pj) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> e = <span class="number">1</span>; pje &lt;= va / pj; e ++, pje *= pj) &#123;</span><br><span class="line">				<span class="type">int</span> v = pje % P * ( (pje - <span class="number">1</span>) % P ) % P;</span><br><span class="line">				v = v * ( s[<span class="built_in">pos</span>(va / pje)] + g[<span class="built_in">pos</span>(va / pje)] + P - sm) % P;</span><br><span class="line">				v = (v + (pje * pj) % P * ( (pje * pj - <span class="number">1</span>) % P ) )% P;</span><br><span class="line">				s[k] = (s[k] + v) % P;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sm = (P - pj * (pj - <span class="number">1</span>) % P + sm) % P;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; (s[<span class="number">1</span>] + g[<span class="number">1</span>] + <span class="number">1</span>) % P &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>习题</strong></p>
<p><strong>$\text{Loj 6235}$</strong></p>
<ul>
<li>题意：<ul>
<li>求$1\dots n$的素数个数。</li>
<li>$n\leq 10^{11}$</li>
</ul>
</li>
<li>题解<ul>
<li>设$f_0(i) = 1$然后做素数部分的筛法即可。</li>
</ul>
</li>
</ul>
<p><strong>$\text{Loj 572}$</strong></p>
<ul>
<li>题意<ul>
<li><script type="math/tex; mode=display">\sum_{i = 1}^n\sum_{j = 1}^nf(gcd(i, j))^k \mod 2^{32}</script></li>
<li>$f(x)$表示$x$次大的质因子， 重复的质因子多次计算。规定$f(1) = 0, f(prime) = 1$。</li>
<li>$n, k\leq 2\times 10^9$。</li>
</ul>
</li>
<li>题解<ul>
<li>显然先对这个式子莫比乌斯反演。</li>
<li><script type="math/tex; mode=display">\sum_{i = 1}^n\sum_{j = 1}^nf(gcd(i, j))^k = \sum_{d = 1}^nf(d) ^k\sum_{i = 1}^{\frac{n}{d}}\sum_{j = 1}^{\frac{n}{d}}[gcd(i, j)== 1] \\ = \sum_{d = 1}^nf(d)^k(2\sum_{i = 1}^{\frac{n}{d}}\varphi(i) - 1) = \sum_{d =1}^nf(d)^k g(\lfloor \frac{n}{d} \rfloor)</script></li>
<li>显然右边可以整除分块了， 考虑左边怎么算。</li>
<li>虽然那个$f$不是积性函数， <strong>但是由于其在质数处的特殊取值以及其和质因子相关的特性</strong>， 我们可以考虑一下使用$\text{Min25}$筛。</li>
<li>显然质数处的求值就是直接求素数个数就好了，我们考虑合数处的求值。</li>
<li>同样考虑分类讨论除掉最小质因子的过程。<ul>
<li>如果除掉以后是合数， 那就递归下去。</li>
<li>如果除掉以后是质数， 那就会贡献一次答案。</li>
<li>如果除掉以后是$1$，那当前点也会贡献一下答案。</li>
</ul>
</li>
<li>写出式子来就是:<ul>
<li><script type="math/tex; mode=display">S(n, j) = S(n, j + 1)+\sum_{e = 1}S(\lfloor\frac{n}{P_j^e}\rfloor, j+ 1)+P_j^k\times CountPrime(P_j, \frac{n}{P_j^{e}})</script></li>
<li>直接递推就好了。后面那个显然我们会在之前处理掉。</li>
</ul>
</li>
<li><strong>$\text{Min25}$不只能筛积性函数！</strong></li>
<li>通过观察函数的性质调整合数和质数部分的求法可以得到奇奇怪怪的函数。</li>
</ul>
</li>
</ul>
<p><strong>$\text{BZOJ 5234}$</strong></p>
<ul>
<li>题意<ul>
<li>求$1\dots n$中$\sigma_1$(约数和函数）整除$p$的所有数之和。</li>
<li>$p = \text{2 or 2017}$。</li>
<li>$n\leq 10^{10}$。</li>
</ul>
</li>
<li>题解<ul>
<li>考虑变成所有数减去不整除的部分。</li>
<li>那么其约数和函数不整除$p$的部分我们用一个函数$f$来描述， 如果整除了就是$0$， 否则就是原来那个数。那么我们就是要求这个东西的前缀和。</li>
<li>显然这是个积性函数。</li>
<li>当$p = 2$的时候质数点除了$2$都是$0$， 直接筛就好了。</li>
<li>当$p = 2017$的时候可能为$0$的点不多, 由于我们筛积性函数的时候对于质数的部分只需要那几个前缀和， 我们可以暴力枚举$2017$的约数，用$\text{Miller_Rabbin}$判断质数， 并维护那些前缀和就好了。</li>
</ul>
</li>
</ul>
<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) <span class="built_in">lep</span> (j, <span class="number">1</span>, n + <span class="number">1</span>) cin &gt;&gt; a[i][j];</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">abs</span>(a[i][i]) &lt;= <span class="number">1e-9</span>) &#123;</span><br><span class="line">			<span class="built_in">lep</span> (j, i, n) <span class="keyword">if</span>(<span class="built_in">abs</span>(a[j][i]) &gt;= <span class="number">1e-9</span>) &#123; <span class="built_in">swap</span>(a[i], a[j]); <span class="keyword">break</span>; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">abs</span>(a[i][i]) &lt;= <span class="number">1e-9</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">lep</span> (j, <span class="number">1</span>, n) <span class="keyword">if</span>(j != i) &#123;</span><br><span class="line">			<span class="type">double</span> t = a[j][i] / a[i][i];</span><br><span class="line">			<span class="built_in">lep</span> (k, <span class="number">1</span>, n + <span class="number">1</span>) a[j][k] -= a[i][k] * t;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) a[i][i] = a[i][n + <span class="number">1</span>] / a[i][i];</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; a[i][i] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a>矩阵求逆</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">400</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> A[N][N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i][i] == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">lep</span> (j, i + <span class="number">1</span>, n) <span class="keyword">if</span>(A[j][i] != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(A[i], A[j]);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(A[i][i] == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;No Solution\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">lep</span> (j, <span class="number">1</span>, n) &#123; <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="type">int</span> p = <span class="number">1ll</span> * A[j][i] * <span class="built_in">power</span>(A[i][i], P - <span class="number">2</span>) % P;</span><br><span class="line">			<span class="built_in">lep</span> (k, <span class="number">1</span>, n * <span class="number">2</span>) &#123;</span><br><span class="line">				A[j][k] = (A[j][k] - <span class="number">1ll</span> * A[i][k] * p % P + P) % P;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> v = A[i][i];</span><br><span class="line">		v = <span class="built_in">power</span>(v, P - <span class="number">2</span>);</span><br><span class="line">		<span class="built_in">lep</span> (j, <span class="number">1</span>, n * <span class="number">2</span>) A[i][j] = <span class="number">1ll</span> * A[i][j] * v % P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) <span class="built_in">lep</span> (j, <span class="number">1</span>, n) <span class="built_in">read</span>(A[i][j]);</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) A[i][i + n] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">gauss</span>();</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n) <span class="built_in">lep</span> (j, <span class="number">1</span>, n) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, A[i][j + n], <span class="string">&quot; \n&quot;</span>[j == n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h2><p>$b ^ l \equiv n \pmod p$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std :: cin;</span><br><span class="line"><span class="keyword">using</span> std :: cout;</span><br><span class="line"><span class="keyword">using</span> std :: cerr;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lep(i, l, r) for(int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for(int i = (l); i &gt;= (r); i --)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FastMod</span> &#123;</span><br><span class="line">	i64 mod; __int128 mu;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(i64 _mod)</span> </span>&#123;</span><br><span class="line">		mod = _mod;</span><br><span class="line">		mu = <span class="number">-1ull</span> / mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">i64 <span class="title">reduce</span><span class="params">(i64 x)</span> </span>&#123;</span><br><span class="line">		i64 r = x - ((x * mu) &gt;&gt; <span class="number">64</span>) * mod;</span><br><span class="line">		<span class="keyword">return</span> r &gt;= mod ? r - mod : r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; mod;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p, b, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); </span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; p &gt;&gt; b &gt;&gt; n;</span><br><span class="line">	mod.<span class="built_in">init</span>(p);	</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> bl = <span class="built_in">sqrt</span>(p) + <span class="number">1</span>, mul = <span class="number">1</span>;</span><br><span class="line">	std :: unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">	mp[mod.<span class="built_in">reduce</span>(<span class="number">1ll</span> * mul * n)] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, bl) &#123;</span><br><span class="line">		mul = mod.<span class="built_in">reduce</span>(<span class="number">1ll</span> * mul * b);</span><br><span class="line">		mp[mod.<span class="built_in">reduce</span>(<span class="number">1ll</span> * mul * n)] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> nowmul = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, bl) &#123;</span><br><span class="line">		nowmul = mod.<span class="built_in">reduce</span>(<span class="number">1ll</span> * nowmul * mul);</span><br><span class="line">		<span class="keyword">if</span> (mp[nowmul]) &#123;</span><br><span class="line">			cout &lt;&lt; i * bl - mp[nowmul] &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;no solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="exbsgs"><a href="#exbsgs" class="headerlink" title="exbsgs"></a>exbsgs</h2><p>$a^x \equiv b \pmod p$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">std :: unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (! b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, <span class="built_in">void</span>();</span><br><span class="line">	<span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">	<span class="type">int</span> t = x; x = y; y = t - a / b * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getinv</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(std :: __gcd(x, p) == <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> y, k;</span><br><span class="line">	<span class="built_in">exgcd</span>(x, p, y, k);</span><br><span class="line">	y = (y % p + p) % p;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (k) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * x % p;</span><br><span class="line">		x = <span class="number">1ll</span> * x * x % p; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, p, b;</span><br><span class="line"><span class="type">int</span> cs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	a %= p; b %= p; ++ cs;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="number">1</span> - (p == <span class="number">1</span>) &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b &gt; <span class="number">1</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">1</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> ta = a, tp = p, tb = b;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">lep</span> (x, <span class="number">0</span>, <span class="number">30</span>) <span class="keyword">if</span> (<span class="built_in">power</span>(ta, x, tp) == tb) <span class="keyword">return</span> cout &lt;&lt; x &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (std :: __gcd(a, p) != <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> d = std :: __gcd(a, p); ++ cnt;</span><br><span class="line">		<span class="keyword">if</span> (b % d != <span class="number">0</span>) <span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">		b /= d; p /= d; </span><br><span class="line">		b = <span class="number">1ll</span> * b * <span class="built_in">getinv</span>(a / d, p) % p;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	a %= p; </span><br><span class="line">	</span><br><span class="line">	<span class="built_in">lep</span> (x, <span class="number">0</span>, cnt) <span class="keyword">if</span> (<span class="built_in">power</span>(ta, x, tp) == tb) <span class="keyword">return</span> cout &lt;&lt; x &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> bl = <span class="built_in">sqrt</span>(p) + <span class="number">1</span>, mul = b, dmul = <span class="number">1</span>; mp.<span class="built_in">reserve</span>(bl);</span><br><span class="line">	mp[mul] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, bl) &#123;</span><br><span class="line">		mul = <span class="number">1ll</span> * mul * a % p;</span><br><span class="line">		dmul = <span class="number">1ll</span> * dmul * a % p;</span><br><span class="line">		mp[mul] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	mul = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, bl) &#123;</span><br><span class="line">		mul = <span class="number">1ll</span> * mul * dmul % p;</span><br><span class="line">		<span class="keyword">if</span> (mp.<span class="built_in">count</span>(mul)) &#123;</span><br><span class="line">			<span class="keyword">return</span> cout &lt;&lt; i * bl - mp[mul] + cnt &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; endl, <span class="built_in">void</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); </span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; p &gt;&gt; b) &#123;</span><br><span class="line">		mp.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">if</span> (a + b + p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">		<span class="comment">//cerr &lt;&lt; ++ tot &lt;&lt; endl;</span></span><br><span class="line">		<span class="comment">//if (tot &gt;= 10) break;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h2><p>若$gcd(a, m) = 1$ 使得$a^l\equiv1(mod \  m)$成立的最小的$l$， 称为$a$关于$m$的阶。记作$ord_ma$。</p>
<h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p>当$gcd(g, m) = 1$, 如果$ord_mg=\phi(m)$, 则$g$是$m$的一个原根。<br>换句话说， 在这个剩余系内， 原根的小于$\phi(m)$的幂次全部不等。</p>
<h3 id="求原根"><a href="#求原根" class="headerlink" title="求原根"></a>求原根</h3><ul>
<li>直接枚举， 判定上述条件是否成立。</li>
<li>分解$P - 1$<ul>
<li>枚举一个数$a$</li>
<li>对于每一个质因子， 判断$a^{(P - 1)/ i}$是否为$1$</li>
<li>如果对于每一个质因子上面的测试都不是$1$， 那就找到了一个原根。</li>
<li>2的原根是$1$。</li>
<li>原根的所有幂次在剩余系下的取值给出所有原根。</li>
</ul>
</li>
</ul>
<h2 id="Miller-Rabin-amp-amp-Pollard-Rho"><a href="#Miller-Rabin-amp-amp-Pollard-Rho" class="headerlink" title="Miller_Rabin &amp;&amp; Pollard_Rho"></a>Miller_Rabin &amp;&amp; Pollard_Rho</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RI register int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Mul</span><span class="params">(LL x, LL y, LL p)</span> </span>&#123;</span><br><span class="line">	LL res = x * y - (LL) ( (<span class="type">long</span> <span class="type">double</span>) x / p * y + <span class="number">0.5</span> ) * p;</span><br><span class="line">	<span class="keyword">return</span> res &lt; <span class="number">0</span> ? res + p : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">power</span><span class="params">(LL x, LL k, LL p)</span> </span>&#123;</span><br><span class="line">	LL res = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = <span class="built_in">Mul</span>(res, x, p);</span><br><span class="line">		x = <span class="built_in">Mul</span>(x, x, p); k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> y ? <span class="built_in">gcd</span>(y, x % y) : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Miller</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> Pri[<span class="number">9</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">61</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++) <span class="keyword">if</span>(n % Pri[i] == <span class="number">0</span>) <span class="keyword">return</span> n == Pri[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++) &#123;</span><br><span class="line">		LL r = n - <span class="number">1</span>, s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(! (r &amp; <span class="number">1</span>) ) r &gt;&gt;= <span class="number">1</span>, s ++;</span><br><span class="line">		LL w = <span class="built_in">power</span>(Pri[i], r, n), p = w;</span><br><span class="line">		<span class="keyword">for</span>(LL j = <span class="number">1</span>; j &lt;= s; j ++) &#123;</span><br><span class="line">			w = <span class="built_in">Mul</span>(w, w, n);</span><br><span class="line">			<span class="keyword">if</span>(w == <span class="number">1</span> &amp;&amp; p != n - <span class="number">1</span> &amp;&amp; p != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			p = w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(w != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">run</span><span class="params">(LL x, LL n, LL c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ( <span class="built_in">Mul</span>(x, x, n) + c ) % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Pollard</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">4</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	LL c = <span class="built_in">rand</span>() % (n - <span class="number">1</span>) + <span class="number">1</span>, a = <span class="number">0</span>, b = <span class="number">0</span>, d;</span><br><span class="line">	a = <span class="built_in">run</span>(a, n, c); b = <span class="built_in">run</span>(b, n, c); b = <span class="built_in">run</span>(b, n, c);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">rand</span>() % <span class="number">5</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> lim = <span class="number">1</span>; a ^ b; lim = <span class="built_in">min</span>(<span class="number">128</span>, lim &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">			LL cnt = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) &#123;</span><br><span class="line">				cnt = <span class="built_in">Mul</span>(cnt, <span class="built_in">abs</span>(a - b), n);</span><br><span class="line">				<span class="keyword">if</span>(! cnt) <span class="keyword">break</span>;</span><br><span class="line">				a = <span class="built_in">run</span>(a, n, c); </span><br><span class="line">				b = <span class="built_in">run</span>(b, n, c); b = <span class="built_in">run</span>(b, n, c);</span><br><span class="line">			&#125;</span><br><span class="line">			d = <span class="built_in">gcd</span>(cnt, n);</span><br><span class="line">			<span class="keyword">if</span>(d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(a ^ b) &#123;</span><br><span class="line">			d = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(a - b), n); </span><br><span class="line">			<span class="keyword">if</span>(d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">			a = <span class="built_in">run</span>(a, n, c);</span><br><span class="line">			b = <span class="built_in">run</span>(b, n, c); b = <span class="built_in">run</span>(b, n, c);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Pollard_Rho</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">Miller</span>(n)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	LL d;</span><br><span class="line">	<span class="keyword">while</span>((d = <span class="built_in">Pollard</span>(n)) == n); </span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">Miller</span>(n)) &#123;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, n);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	LL res = <span class="built_in">Pollard_Rho</span>(n);</span><br><span class="line">	<span class="keyword">if</span>(res &gt; ans) <span class="built_in">dfs</span>(res);</span><br><span class="line">	<span class="keyword">if</span>(n / res &gt; ans) <span class="built_in">dfs</span>(n / res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">Miller</span>(n)) &#123; cout &lt;&lt; <span class="string">&quot;Prime&quot;</span> &lt;&lt; endl; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(n);</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="type">int</span> Case; cin &gt;&gt; Case;</span><br><span class="line">	<span class="keyword">while</span>(Case --) &#123;</span><br><span class="line">		LL n; cin &gt;&gt; n;</span><br><span class="line">		<span class="built_in">solve</span>(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exgcd-（放了一个洛谷板子，-记得造一个有说明的）"><a href="#exgcd-（放了一个洛谷板子，-记得造一个有说明的）" class="headerlink" title="exgcd （放了一个洛谷板子， 记得造一个有说明的）"></a>exgcd （放了一个洛谷板子， 记得造一个有说明的）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123; <span class="type">int</span> x; cin &gt;&gt; x; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> y ? <span class="built_in">gcd</span>(y, x % y) : x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(! b) &#123; x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">	<span class="type">int</span> t = x; x = y; y = t - a / b * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>(), c = <span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> g = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">	<span class="keyword">if</span>(c % g != <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> tx, ty;</span><br><span class="line">	<span class="built_in">exgcd</span>(a, b, tx, ty);</span><br><span class="line">	LL x0 = (LL)tx * (c / g);</span><br><span class="line">	LL y0 = (LL)ty * (c / g);</span><br><span class="line">	LL tb = b / g;</span><br><span class="line">	LL ta = a / g;</span><br><span class="line">	<span class="type">int</span> L = <span class="built_in">ceil</span>(- <span class="number">1.0</span> * x0 / tb );</span><br><span class="line">	<span class="type">int</span> R = <span class="built_in">floor</span>(<span class="number">1.0</span> * y0 / ta);</span><br><span class="line">	<span class="keyword">if</span>(x0 + (LL)L * tb == <span class="number">0</span>) L ++;</span><br><span class="line">	<span class="keyword">if</span>(y0 - (LL)R * ta == <span class="number">0</span>) R --;</span><br><span class="line">	<span class="keyword">if</span>(L &gt; R) &#123;</span><br><span class="line">		cout &lt;&lt; x0 + (LL)L * tb &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y0 - (LL)R * ta &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		LL vx0 = x0 + (LL)L * tb, vx1 = x0 + (LL)R * tb, vy0 =y0 - (LL)R * ta, vy1 = y0 - (LL)L * ta;</span><br><span class="line">		<span class="keyword">if</span>(vx0 &gt; vx1) <span class="built_in">swap</span>(vx0, vx1);</span><br><span class="line">		<span class="keyword">if</span>(vy0 &gt; vy1) <span class="built_in">swap</span>(vy0, vy1);</span><br><span class="line">		cout &lt;&lt; R - L + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; vx0 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; vy0 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; vx1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; vy1 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="type">int</span> Case = <span class="built_in">read</span>();<span class="comment">// Case = 1;</span></span><br><span class="line">	<span class="keyword">while</span>(Case --) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="O-1-gcd"><a href="#O-1-gcd" class="headerlink" title="O(1) gcd"></a>O(1) gcd</h2><p>基于值域预处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5000</span>, v = <span class="number">1000000</span>, radio = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> a[maxn + <span class="number">10</span>], b[maxn + <span class="number">10</span>], n, ans;</span><br><span class="line"><span class="type">int</span> np[v + <span class="number">10</span>], prime[v + <span class="number">10</span>], cnt;</span><br><span class="line"><span class="type">int</span> k[v + <span class="number">10</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> _gcd[radio + <span class="number">10</span>][radio + <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> g = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> tmp, i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k[a][i] &gt; radio) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b % k[a][i] == <span class="number">0</span>) tmp = k[a][i];</span><br><span class="line">            <span class="keyword">else</span> tmp = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> tmp = _gcd[k[a][i]][b % k[a][i]];</span><br><span class="line">        b /= tmp;</span><br><span class="line">        g *= tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    k[<span class="number">1</span>][<span class="number">0</span>] = k[<span class="number">1</span>][<span class="number">1</span>] = k[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    np[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= v; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) prime[++cnt] = i, k[i][<span class="number">2</span>] = i, k[i][<span class="number">1</span>] = k[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; prime[j] * i &lt;= v; j++) &#123;</span><br><span class="line">            np[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> *tmp = k[i * prime[j]];</span><br><span class="line">            tmp[<span class="number">0</span>] = k[i][<span class="number">0</span>] * prime[j];</span><br><span class="line">            tmp[<span class="number">1</span>] = k[i][<span class="number">1</span>];</span><br><span class="line">            tmp[<span class="number">2</span>] = k[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(tmp[<span class="number">1</span>] &lt; tmp[<span class="number">0</span>]) <span class="built_in">swap</span>(tmp[<span class="number">1</span>], tmp[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(tmp[<span class="number">2</span>] &lt; tmp[<span class="number">1</span>]) <span class="built_in">swap</span>(tmp[<span class="number">2</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= radio; i++) _gcd[i][<span class="number">0</span>] = _gcd[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> _max = <span class="number">1</span>; _max &lt;= radio; _max++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= _max; i++)</span><br><span class="line">            _gcd[i][_max] = _gcd[_max][i] = _gcd[_max % i][i];</span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt;= 10; i++)</span></span><br><span class="line">        <span class="comment">// for(int j = 1; j &lt;= 10; j++) printf(&quot;gcd(%d, %d) = %d\n&quot;, i, j, _gcd[i][j]);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            now = <span class="number">1ll</span> * now * i % mod;</span><br><span class="line">            ans = (ans + <span class="number">1ll</span> * <span class="built_in">gcd</span>(a[i], b[j]) * now) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h1><h2 id="fwt"><a href="#fwt" class="headerlink" title="fwt"></a>fwt</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> a = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(; a &gt; <span class="string">&#x27;9&#x27;</span> || a &lt; <span class="string">&#x27;0&#x27;</span>; a = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(a == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(; a &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; a &gt;= <span class="string">&#x27;0&#x27;</span>; a = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + a - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL) res * x % P;</span><br><span class="line">		x = (LL) x * x % P; k &gt;&gt;= <span class="number">1</span>;		</span><br><span class="line">	&#125; <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inv2 = <span class="built_in">power</span>(<span class="number">2</span>, P - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> :</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y &gt;= P ? x + y - P : x + y; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Del</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y &lt; <span class="number">0</span> ? x - y + P : x - y; &#125;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="built_in">Int</span>(<span class="type">int</span> _n = <span class="number">0</span>) &#123; n = _n; &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(<span class="type">char</span> c = <span class="string">&#x27;\n&#x27;</span>)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, n, c); &#125;</span><br><span class="line">		Int <span class="keyword">operator</span> =(<span class="type">int</span> x) &#123; <span class="built_in">return</span> (Int) (n = x); &#125;</span><br><span class="line">		Int <span class="keyword">operator</span> =(Int x) &#123; <span class="built_in">return</span> (Int) (n = x.n); &#125;</span><br><span class="line">		Int <span class="keyword">operator</span> +(Int x) &#123; <span class="keyword">return</span> (Int) (<span class="built_in">Add</span>(n, x.n)); &#125;</span><br><span class="line">		Int <span class="keyword">operator</span> +(<span class="type">int</span> x) &#123; <span class="keyword">return</span> (Int) (<span class="built_in">Add</span>(n, x)); &#125;</span><br><span class="line">		Int <span class="keyword">operator</span> -(Int x) &#123; <span class="keyword">return</span> (Int) (<span class="built_in">Del</span>(n, x.n)); &#125;</span><br><span class="line">		Int <span class="keyword">operator</span> -(<span class="type">int</span> x) &#123; <span class="keyword">return</span> (Int) (<span class="built_in">Del</span>(n, x)); &#125;</span><br><span class="line">		Int <span class="keyword">operator</span> *(Int x) &#123; <span class="keyword">return</span> (Int) ( (LL) n * x.n % P ); &#125;</span><br><span class="line">		Int <span class="keyword">operator</span> *(<span class="type">int</span> x) &#123; <span class="keyword">return</span> (Int) ( (LL) n * x % P ); &#125;</span><br><span class="line">		<span class="type">void</span> <span class="keyword">operator</span> +=(Int x) &#123; n = <span class="built_in">Add</span>(n, x.n); &#125;</span><br><span class="line">		<span class="type">void</span> <span class="keyword">operator</span> -=(Int x) &#123; n = <span class="built_in">Del</span>(n, x.n); &#125;</span><br><span class="line">		<span class="type">void</span> <span class="keyword">operator</span> *=(Int x) &#123; n = (LL) n * x.n % P; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Int <span class="keyword">operator</span> -(<span class="type">int</span> x, Int y) &#123; <span class="keyword">return</span> (Int) (x) - y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OR</span><span class="params">(Int *A, <span class="type">int</span> n, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> dep = <span class="number">1</span>; dep &lt; (<span class="number">1</span> &lt;&lt; n); dep &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> len = (dep &lt;&lt; <span class="number">1</span>), j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j += len) </span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; dep; k ++) </span><br><span class="line">				<span class="keyword">if</span>(type == <span class="number">1</span>) </span><br><span class="line">					A[j + k + dep] += A[j + k];</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					A[j + k + dep] -= A[j + k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AND</span><span class="params">(Int *A, <span class="type">int</span> n, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> dep = <span class="number">1</span>; dep &lt; (<span class="number">1</span> &lt;&lt; n); dep &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> len = (dep &lt;&lt; <span class="number">1</span>), j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j += len) </span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; dep; k ++) </span><br><span class="line">				<span class="keyword">if</span>(type == <span class="number">1</span>) </span><br><span class="line">					A[j + k] += A[j + k + dep];</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					A[j + k] -= A[j + k + dep];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XOR</span><span class="params">(Int *A, <span class="type">int</span> n, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> dep = <span class="number">1</span>; dep &lt; (<span class="number">1</span> &lt;&lt; n); dep &lt;&lt;= <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> len = (dep &lt;&lt; <span class="number">1</span>), j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j += len)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; dep; k ++) &#123;</span><br><span class="line">				Int x = A[j + k] + A[j + k + dep], y = A[j + k] - A[j + k + dep];</span><br><span class="line">				<span class="keyword">if</span>(type == <span class="number">1</span>) </span><br><span class="line">					A[j + k] = x, A[j + k + dep] = y;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					A[j + k] = x * inv2, A[j + k + dep] = y * inv2;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">Int a[<span class="number">1</span> &lt;&lt; <span class="number">17</span>], b[<span class="number">1</span> &lt;&lt; <span class="number">17</span>], c[<span class="number">1</span> &lt;&lt; <span class="number">17</span>];</span><br><span class="line">Int A[<span class="number">1</span> &lt;&lt; <span class="number">17</span>], B[<span class="number">1</span> &lt;&lt; <span class="number">17</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> IN</span></span><br><span class="line">	<span class="comment">//freopen(&quot;.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++) A[i] = a[i] = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++) B[i] = b[i] = <span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">OR</span>(a, n, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">OR</span>(b, n, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++) c[i] = a[i] * b[i];</span><br><span class="line">	<span class="built_in">OR</span>(c, n, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++) c[i].<span class="built_in">out</span>(i + <span class="number">1</span> == (<span class="number">1</span> &lt;&lt; n) ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span> );</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++) a[i] = A[i], b[i] = B[i];</span><br><span class="line">	<span class="built_in">AND</span>(a, n, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">AND</span>(b, n, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++) c[i] = a[i] * b[i];</span><br><span class="line">	<span class="built_in">AND</span>(c, n, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++) c[i].<span class="built_in">out</span>(i + <span class="number">1</span> == (<span class="number">1</span> &lt;&lt; n) ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span> );</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++) a[i] = A[i], b[i] = B[i];</span><br><span class="line">	<span class="built_in">XOR</span>(a, n, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">XOR</span>(b, n, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++) c[i] = a[i] * b[i];</span><br><span class="line">	<span class="built_in">XOR</span>(c, n, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++) c[i].<span class="built_in">out</span>(i + <span class="number">1</span> == (<span class="number">1</span> &lt;&lt; n) ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span> );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a>子集卷积</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ULL = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> ...U&gt; <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(T a, U ... b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">21</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, lim;</span><br><span class="line"><span class="type">int</span> a[<span class="number">21</span>][N], b[<span class="number">21</span>][N], bit[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(<span class="type">int</span> *A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> dep = <span class="number">1</span>; dep &lt; lim; dep &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>, len = (dep &lt;&lt; <span class="number">1</span>); j &lt; lim; j += len)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; dep; k ++)</span><br><span class="line">				A[j + k + dep] += A[j + k], A[j + k + dep] %= P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IFWT</span><span class="params">(<span class="type">int</span> *A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> dep = <span class="number">1</span>; dep &lt; lim; dep &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>, len = (dep &lt;&lt; <span class="number">1</span>); j &lt; lim; j += len)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; dep; k ++)</span><br><span class="line">				A[j + k + dep] -= A[j + k] - P, A[j + k + dep] %= P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rec[<span class="number">21</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = <span class="built_in">read</span>(); lim = (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; lim; i ++) bit[i] = bit[i - (i &amp; -i)] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) a[bit[i]][i] = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) b[bit[i]][i] = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) <span class="built_in">FWT</span>(a[i]), <span class="built_in">FWT</span>(b[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; lim; k ++)</span><br><span class="line">				rec[i][k] = (rec[i][k] + <span class="number">1LL</span> * a[j][k] * b[i - j][k] % P) % P;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) <span class="built_in">IFWT</span>(rec[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) cout &lt;&lt; rec[bit[i]][i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> a = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(; ! <span class="built_in">isdigit</span>(a); a = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(a == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(; <span class="built_in">isdigit</span>(a); a = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + a - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123; cout &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> ...U&gt; <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(T a, U ... b)</span> </span>&#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="built_in">debug</span>(b...); &#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合幂级数技巧"><a href="#集合幂级数技巧" class="headerlink" title="集合幂级数技巧"></a>集合幂级数技巧</h2><p>acm应该不至于考这个吧（（（</p>
<h2 id="各种技巧（待补充）"><a href="#各种技巧（待补充）" class="headerlink" title="各种技巧（待补充）"></a>各种技巧（待补充）</h2><h2 id="多项式全家桶"><a href="#多项式全家桶" class="headerlink" title="多项式全家桶"></a>多项式全家桶</h2><p>这个是包括了多点求值的。<br>注意多项式快速幂要保证0位是1， 不然要平移。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x + ((x &gt;&gt; <span class="number">31</span>) &amp; P); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL) res * x % P;</span><br><span class="line">		x = (LL) x * x % P; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> G = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Gi = <span class="built_in">power</span>(G, P - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lim, bit, rev[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	lim = <span class="number">1</span>, bit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(lim &lt; n) lim &lt;&lt;= <span class="number">1</span>, bit ++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Poly</span> &#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="built_in">Poly</span>(<span class="type">int</span> SZ = <span class="number">0</span>) &#123; vec.<span class="built_in">resize</span>(SZ); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> len)</span> </span>&#123; <span class="comment">//cerr &lt;&lt; vec.size() &lt;&lt; &#x27; &#x27; &lt;&lt; len &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">while</span>(vec.<span class="built_in">size</span>() &lt; len) vec.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(vec.<span class="built_in">size</span>() &gt; len) vec.<span class="built_in">pop_back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">lenth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vec.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> &amp; <span class="keyword">operator</span> [] (<span class="type">int</span> id) &#123; <span class="keyword">return</span> vec[id]; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = vec.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) ans = (vec[i] + (LL) v * ans % P) % P;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">deri</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inte</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span></span>;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Poly :: <span class="built_in">deri</span>() &#123;</span><br><span class="line">	<span class="type">int</span> len = vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i ++) vec[i] = (LL) vec[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % P;</span><br><span class="line">	<span class="built_in">resize</span>(len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Poly :: <span class="built_in">inte</span>() &#123;</span><br><span class="line">	<span class="type">int</span> len = vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">resize</span>(len + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --) vec[i] = (LL) vec[i - <span class="number">1</span>] * <span class="built_in">power</span>(i, P - <span class="number">2</span>) % P;</span><br><span class="line">	vec[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Poly :: <span class="built_in">reverse</span>() &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>() - i; i ++) <span class="built_in">swap</span>(vec[i], vec[vec.<span class="built_in">size</span>() - i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(Poly &amp;A, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//A.resize(lim);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++)</span><br><span class="line">		<span class="keyword">if</span>(i &lt; rev[i]) <span class="built_in">swap</span>(A[i], A[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> dep = <span class="number">1</span>; dep &lt; lim; dep &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> Wn = <span class="built_in">power</span>(type == <span class="number">1</span> ? G : Gi, (P - <span class="number">1</span>) / (dep &lt;&lt; <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; lim; j += (dep &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="type">int</span> w = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; dep; k ++, w = (LL) w * Wn % P) &#123;</span><br><span class="line">				<span class="type">int</span> x = A[j + k], y = (LL) A[j + k + dep] * w % P;</span><br><span class="line">				A[j + k] = <span class="built_in">Mod</span>(x + y - P);</span><br><span class="line">				A[j + k + dep] = <span class="built_in">Mod</span>(x - y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(type == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> inv = <span class="built_in">power</span>(lim, P - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) A[i] = (LL) A[i] * inv % P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Poly <span class="keyword">operator</span> *(Poly A, Poly B) &#123;</span><br><span class="line">	<span class="type">int</span> lenth = A.<span class="built_in">lenth</span>() + B.<span class="built_in">lenth</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">init</span>(lenth);</span><br><span class="line">	<span class="function">Poly <span class="title">C</span><span class="params">(lim)</span></span>; A.<span class="built_in">resize</span>(lim); B.<span class="built_in">resize</span>(lim);</span><br><span class="line">	<span class="built_in">NTT</span>(A, <span class="number">1</span>); <span class="built_in">NTT</span>(B, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) C[i] = (LL) A[i] * B[i] % P;</span><br><span class="line">	<span class="built_in">NTT</span>(C, <span class="number">-1</span>); C.<span class="built_in">resize</span>(lenth);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getinv</span><span class="params">(Poly &amp;F, Poly &amp;G, <span class="type">int</span> dep)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep == <span class="number">1</span>) &#123;</span><br><span class="line">		G.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line">		G[<span class="number">0</span>] = <span class="built_in">power</span>(F[<span class="number">0</span>], P - <span class="number">2</span>); </span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getinv</span>(F, G, (dep + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">init</span>(dep &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	Poly C;</span><br><span class="line">	C.<span class="built_in">resize</span>(lim);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dep; i ++) C[i] = F[i];</span><br><span class="line">	G.<span class="built_in">resize</span>(lim);</span><br><span class="line">	<span class="built_in">NTT</span>(C, <span class="number">1</span>); <span class="built_in">NTT</span>(G, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) &#123;</span><br><span class="line">		G[i] = <span class="built_in">Mod</span>(<span class="built_in">Mod</span>(G[i] + G[i] - P) - (LL) C[i] * G[i] % P * G[i] % P);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">NTT</span>(G, <span class="number">-1</span>);</span><br><span class="line">	G.<span class="built_in">resize</span>(dep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Poly <span class="keyword">operator</span> ~(Poly &amp;A) &#123;</span><br><span class="line">	Poly B;</span><br><span class="line">	<span class="built_in">getinv</span>(A, B, A.<span class="built_in">lenth</span>());</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Poly <span class="title">ln</span><span class="params">(Poly A)</span> </span>&#123;</span><br><span class="line">	Poly dA = A;</span><br><span class="line">	dA.<span class="built_in">deri</span>();</span><br><span class="line">	A = ~ A;</span><br><span class="line">	Poly B = dA * A;</span><br><span class="line">	B.<span class="built_in">inte</span>();</span><br><span class="line">	B.<span class="built_in">resize</span>(A.<span class="built_in">lenth</span>());</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq_exp</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, Poly &amp;A, Poly &amp;B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">		<span class="keyword">if</span>(l == <span class="number">0</span>) B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> B[l] = (LL) <span class="built_in">power</span>(l, P - <span class="number">2</span>) * B[l] % P;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cdq_exp</span>(l, mid, A, B);</span><br><span class="line">	<span class="type">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">init</span>(len);</span><br><span class="line">	<span class="function">Poly <span class="title">C</span><span class="params">(lim)</span>, <span class="title">D</span><span class="params">(lim)</span></span>; </span><br><span class="line">	<span class="keyword">if</span>(A.<span class="built_in">lenth</span>() &lt; lim) A.<span class="built_in">resize</span>(lim);</span><br><span class="line">	<span class="keyword">if</span>(B.<span class="built_in">lenth</span>() &lt; lim) B.<span class="built_in">resize</span>(lim);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) C[i] = (LL) i * A[i] % P;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= mid; i ++) D[i - l] = B[i];</span><br><span class="line">	<span class="built_in">NTT</span>(C, <span class="number">1</span>); <span class="built_in">NTT</span>(D, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) C[i] = (LL) C[i] * D[i] % P;</span><br><span class="line">	<span class="built_in">NTT</span>(C, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i ++) B[i] = <span class="built_in">Mod</span>(B[i] + C[i - l] - P);</span><br><span class="line">	<span class="built_in">cdq_exp</span>(mid + <span class="number">1</span>, r, A, B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>; <span class="type">char</span> a = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(; ! <span class="built_in">isdigit</span>(a); a = <span class="built_in">getchar</span>());</span><br><span class="line">	<span class="keyword">for</span>(; <span class="built_in">isdigit</span>(a); a = <span class="built_in">getchar</span>())</span><br><span class="line">		x = (x * <span class="number">10LL</span> % P + (a - <span class="string">&#x27;0&#x27;</span>)) % P;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Poly <span class="title">exp</span><span class="params">(Poly A)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> l = A.<span class="built_in">lenth</span>();</span><br><span class="line">	<span class="function">Poly <span class="title">B</span><span class="params">(A.lenth())</span></span>;</span><br><span class="line">	<span class="built_in">cdq_exp</span>(<span class="number">0</span>, A.<span class="built_in">lenth</span>() - <span class="number">1</span>, A, B);</span><br><span class="line">	B.<span class="built_in">resize</span>(l);</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Poly <span class="title">power</span><span class="params">(Poly A, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	A = <span class="built_in">ln</span>(A);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">lenth</span>(); i ++) A[i] = (LL) A[i] * k % P;</span><br><span class="line">	A = <span class="built_in">exp</span>(A);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_sq</span><span class="params">(<span class="type">int</span> dep, Poly &amp;F, Poly &amp;G)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep == <span class="number">1</span>) &#123; </span><br><span class="line">		G.<span class="built_in">resize</span>(<span class="number">1</span>); G[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">get_sq</span>((dep + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, F, G);</span><br><span class="line">	<span class="type">int</span> lim = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(lim &lt; (dep &lt;&lt; <span class="number">1</span>)) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	G.<span class="built_in">resize</span>(dep);</span><br><span class="line">	<span class="function">Poly <span class="title">C</span><span class="params">(lim)</span>, LG </span>= ~ G; </span><br><span class="line">	<span class="built_in">init</span>(dep &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	LG.<span class="built_in">resize</span>(lim); G.<span class="built_in">resize</span>(lim);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dep; i ++) C[i] = F[i];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NTT</span>(C, <span class="number">1</span>);  <span class="built_in">NTT</span>(G, <span class="number">1</span>);  <span class="built_in">NTT</span>(LG, <span class="number">1</span>); </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++)</span><br><span class="line">		G[i] = (LL) (P + <span class="number">1</span>) / <span class="number">2</span> * LG[i] % P * (C[i] + (LL) G[i] % P * G[i] % P) % P; </span><br><span class="line">	<span class="built_in">NTT</span>(G, <span class="number">-1</span>); </span><br><span class="line">	G.<span class="built_in">resize</span>(dep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Poly <span class="title">sqrt</span><span class="params">(Poly A)</span> </span>&#123;</span><br><span class="line">	Poly B;</span><br><span class="line">	<span class="built_in">get_sq</span>(A.<span class="built_in">lenth</span>(), A, B);</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Poly <span class="keyword">operator</span> /(Poly F, Poly G) &#123;</span><br><span class="line">	<span class="type">int</span> n = F.<span class="built_in">lenth</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> m = G.<span class="built_in">lenth</span>() - <span class="number">1</span>;</span><br><span class="line">	Poly RF = F, RG = G;</span><br><span class="line">	RF.<span class="built_in">reverse</span>();</span><br><span class="line">	RF.<span class="built_in">resize</span>(n - m + <span class="number">1</span>);</span><br><span class="line">	RG.<span class="built_in">reverse</span>();</span><br><span class="line">	RG.<span class="built_in">resize</span>(n - m + <span class="number">1</span>);</span><br><span class="line">	Poly IRG = ~ RG;</span><br><span class="line">	Poly Q = RF * IRG; </span><br><span class="line">	Q.<span class="built_in">resize</span>(n - m + <span class="number">1</span>);</span><br><span class="line">	Q.<span class="built_in">reverse</span>();</span><br><span class="line">	Q.<span class="built_in">resize</span>(n - m + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Poly <span class="keyword">operator</span> -(Poly A, Poly B) &#123;</span><br><span class="line">	<span class="function">Poly <span class="title">res</span><span class="params">(A.lenth())</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; B.<span class="built_in">lenth</span>(); i ++) res[i] = <span class="built_in">Mod</span>(A[i] - B[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = B.<span class="built_in">lenth</span>(); i &lt; A.<span class="built_in">lenth</span>(); i ++) res[i] = A[i];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Poly <span class="keyword">operator</span> %(Poly A, Poly B) &#123;</span><br><span class="line">	<span class="keyword">if</span>(A.<span class="built_in">lenth</span>() &lt; B.<span class="built_in">lenth</span>()) <span class="keyword">return</span> A;</span><br><span class="line">	Poly res = A - A / B * B;</span><br><span class="line">	res.<span class="built_in">resize</span>(B.<span class="built_in">lenth</span>() - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Poly <span class="title">Get_Poly</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">		<span class="function">Poly <span class="title">F</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">		F[<span class="number">0</span>] = P - vec[l];</span><br><span class="line">		F[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> F;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Get_Poly</span>(l, mid, vec) * <span class="built_in">Get_Poly</span>(mid + <span class="number">1</span>, r, vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Eval</span><span class="params">(Poly F, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt; &amp;res, vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l + <span class="number">300</span> &gt;= r) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i ++) res[i] = F.<span class="built_in">ask</span>(vec[i]);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	Poly tmp = <span class="built_in">Get_Poly</span>(l, mid, vec);</span><br><span class="line">	<span class="built_in">Eval</span>(F % tmp, l, mid, res, vec);</span><br><span class="line">	tmp = <span class="built_in">Get_Poly</span>(mid + <span class="number">1</span>, r, vec);</span><br><span class="line">	<span class="built_in">Eval</span>(F % tmp, mid + <span class="number">1</span>, r, res, vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">evaluation</span><span class="params">(Poly &amp;F, vector&lt;<span class="type">int</span>&gt; vec)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">	F = F % <span class="built_in">Get_Poly</span>(<span class="number">0</span>, n - <span class="number">1</span>, vec);</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="built_in">Eval</span>(F, <span class="number">0</span>, n - <span class="number">1</span>, res, vec);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;2.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">	ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="function">Poly <span class="title">F</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) cin &gt;&gt; F[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) cin &gt;&gt; vec[i];	</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; res = <span class="built_in">evaluation</span>(F, vec);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i ++) cout &lt;&lt; res[i] &lt;&lt; endl; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="任意模数多项式乘法-求逆（使用MTT实现）"><a href="#任意模数多项式乘法-求逆（使用MTT实现）" class="headerlink" title="任意模数多项式乘法/求逆（使用MTT实现）"></a>任意模数多项式乘法/求逆（使用MTT实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="comment">//#define double long double</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> a = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(; ! <span class="built_in">isdigit</span>(a); a = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(a == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(; <span class="built_in">isdigit</span>(a); a = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + a - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> x * f; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">	<span class="type">double</span> x, y;</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">double</span> X = <span class="number">0</span>, <span class="type">double</span> Y = <span class="number">0</span>) : <span class="built_in">x</span>(X), <span class="built_in">y</span>(Y) &#123;&#125;</span><br><span class="line">	<span class="keyword">inline</span> Complex <span class="keyword">operator</span> +(<span class="type">const</span> Complex t) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Complex</span>(x + t.x, y + t.y);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">inline</span> Complex <span class="keyword">operator</span> -(<span class="type">const</span> Complex t) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Complex</span>(x - t.x, y - t.y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">inline</span> Complex <span class="keyword">operator</span> *(<span class="type">const</span> Complex t) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Complex</span>(x * t.x - y * t.y, y * t.x + x * t.y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">inline</span> Complex <span class="keyword">operator</span> /(<span class="type">const</span> <span class="type">double</span> tmp) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Complex</span>(x / tmp, y / tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> Complex <span class="title">conj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Complex</span>(x, -y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> =(<span class="type">const</span> <span class="type">double</span> tmp) &#123;</span><br><span class="line">		x = tmp; y = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> =(<span class="type">const</span> Complex tmp) &#123;</span><br><span class="line">		x = tmp.x, y = tmp.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Complex <span class="title">I</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bit, lim, rev[N];</span><br><span class="line">Complex Wn[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	lim = <span class="number">1</span>, bit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(lim &lt; n) lim &lt;&lt;= <span class="number">1</span>, bit ++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) Wn[i] = <span class="built_in">Complex</span>(<span class="built_in">cos</span>(PI / lim * i), <span class="built_in">sin</span>(PI / lim * i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(Complex *A, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++)</span><br><span class="line">		<span class="keyword">if</span>(rev[i] &gt; i) <span class="built_in">swap</span>(A[i], A[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> dep = <span class="number">1</span>; dep &lt; lim; dep &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>, len = (dep &lt;&lt; <span class="number">1</span>); j &lt; lim; j += len) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; dep; k ++) &#123;</span><br><span class="line">				Complex w = Wn[(LL) k * lim / dep];</span><br><span class="line">				<span class="keyword">if</span>(type == <span class="number">-1</span>) w = w.<span class="built_in">conj</span>();</span><br><span class="line">				Complex x = A[j + k], y = A[j + k + dep] * w;</span><br><span class="line">				A[j + k] = x + y;</span><br><span class="line">				A[j + k + dep] = x - y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(type == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) A[i] = A[i] / lim;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFT</span><span class="params">(Complex *A, Complex *B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) A[i] = A[i] + I * B[i];</span><br><span class="line">	<span class="built_in">FFT</span>(A, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) B[i] = A[i ? lim - i : <span class="number">0</span>].<span class="built_in">conj</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) &#123;</span><br><span class="line">		Complex p = A[i], q = B[i];</span><br><span class="line">		A[i] = (p + q) / <span class="number">2</span>;</span><br><span class="line">		B[i] = (q - p) / <span class="number">2</span> * I;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL) res * x % P;</span><br><span class="line">		x = (LL) x * x % P; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex a0[N], a1[N], b0[N], b1[N];</span><br><span class="line">Complex p[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qz</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x &gt;= <span class="number">0</span>) <span class="keyword">return</span> (LL) (x + <span class="number">0.5</span>) % P;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">return</span> (LL) (x - <span class="number">0.5</span>) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MTT</span><span class="params">(<span class="type">int</span> *A, <span class="type">int</span> *B, <span class="type">int</span> *C, <span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(n + m + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) &#123;</span><br><span class="line">		a0[i] = <span class="number">0</span>; a1[i] = <span class="number">0</span>; b0[i] = <span class="number">0</span>; b1[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> M = <span class="built_in">sqrt</span>(P) + <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		a0[i] = A[i] / M;</span><br><span class="line">		a1[i] = A[i] % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">		b0[i] = B[i] / M;</span><br><span class="line">		b1[i] = B[i] % M;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; b1[i].x &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DFT</span>(a1, b0); <span class="built_in">DFT</span>(a0, b1);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) &#123;</span><br><span class="line">		p[i] = a0[i] * b0[i] + I * a1[i] * b0[i];</span><br><span class="line">		q[i] = a0[i] * b1[i] + I * a1[i] * b1[i];</span><br><span class="line">		<span class="comment">//cout &lt;&lt; (LL) b0[i].y &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FFT</span>(p, <span class="number">-1</span>); <span class="built_in">FFT</span>(q, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + m; i ++) &#123;</span><br><span class="line">		C[i] = ( (LL) M * M % P * <span class="built_in">qz</span>(p[i].x) % P + (LL) M * <span class="built_in">qz</span>(p[i].y) % P + (LL) M * <span class="built_in">qz</span>(q[i].x) % P + <span class="built_in">qz</span>(q[i].y) ) % P; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getinv</span><span class="params">(<span class="type">int</span> *F, <span class="type">int</span> *G, <span class="type">int</span> dep)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep == <span class="number">1</span>) &#123;</span><br><span class="line">		G[<span class="number">0</span>] = <span class="built_in">power</span>(F[<span class="number">0</span>], P - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getinv</span>(F, G, (dep + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> C[N], D[N];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dep; i ++) C[i] = F[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = dep; i &lt; (dep &lt;&lt; <span class="number">1</span>); i ++) C[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (dep &lt;&lt; <span class="number">1</span>); i ++) D[i] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//for(int i = 0; i &lt; dep; i ++) cout &lt;&lt; D[i] &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;-----------------------------------------&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//for(int i = 0; i &lt;= dep; i ++) cout &lt;&lt; C[i] &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//for(int i = 0; i &lt;= dep; i ++) cout &lt;&lt; G[i] &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="built_in">MTT</span>(C, G, D, dep, dep);</span><br><span class="line">	<span class="comment">//for(int i = 0; i &lt;= dep; i ++) cout &lt;&lt; D[i] &lt;&lt; &#x27; &#x27; ; cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;-----------------------------------------&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//lfor(int i = 0; i &lt; dep; i ++) cout &lt;&lt; D[i] &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = dep; i &lt; (dep &lt;&lt; <span class="number">1</span>); i ++) D[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//for(int i = 0; i &lt; (dep &lt;&lt; 2); i ++) C[i] = 0;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;-----------------------------------------&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//for(int i = 0; i &lt;= dep; i ++) cout &lt;&lt; D[i] &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//for(int i = 0; i &lt;= dep; i ++) cout &lt;&lt; G[i] &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl;</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">MTT</span>(D, G, C, dep, dep);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//for(int i = 0; i &lt;= dep; i ++) cout &lt;&lt; C[i] &lt;&lt; &#x27; &#x27; ; cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;----------------------------------------&quot; &lt;&lt; endl;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = dep; i &lt; (dep &lt;&lt; <span class="number">1</span>); i ++) C[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dep; i ++) &#123;</span><br><span class="line">		<span class="type">int</span> v = (<span class="number">2LL</span> * G[i] % P - C[i] + P) % P;</span><br><span class="line">		G[i] = v;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = dep; i &lt; (dep &lt;&lt; <span class="number">1</span>); i ++) G[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;----------------------------------------&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//for(int i = 0; i &lt;= dep; i ++) cout &lt;&lt; G[i] &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;----------------------------------------&quot; &lt;&lt; endl;</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">	n = <span class="built_in">read</span>(); P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) a[i] = <span class="built_in">read</span>() % P;</span><br><span class="line">	<span class="built_in">getinv</span>(a, b, n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三模NTT"><a href="#三模NTT" class="headerlink" title="三模NTT"></a>三模NTT</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> a = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(; a &gt; <span class="string">&#x27;9&#x27;</span> || a &lt; <span class="string">&#x27;0&#x27;</span>; a = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(a == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(; a &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; a &gt;= <span class="string">&#x27;0&#x27;</span>; a = <span class="built_in">getchar</span>()) x = x * <span class="number">10</span> + a - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Data &#123;</span><br><span class="line">	<span class="function">LL <span class="title">power</span><span class="params">(LL x, LL k, LL P)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; k &lt;&lt; &#x27; &#x27; &lt;&lt; P &lt;&lt; endl;</span></span><br><span class="line">		LL res = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(k) &#123;</span><br><span class="line">			<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL) res * x % P;</span><br><span class="line">			x = (LL) x * x % P; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> A = <span class="number">998244353</span>, B = <span class="number">1004535809</span>, C = <span class="number">469762049</span>;</span><br><span class="line">	<span class="comment">//const int P = 1e9 + 7;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> G = <span class="number">3</span>;</span><br><span class="line">	<span class="type">const</span> LL I1 = <span class="built_in">power</span>(A, B - <span class="number">2</span>, B);</span><br><span class="line">	<span class="type">const</span> LL AB = (LL)A * B;</span><br><span class="line">	<span class="type">const</span> LL I2 = <span class="built_in">power</span>(AB % C, C - <span class="number">2</span>, C); </span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> :</span><br><span class="line">			LL a, b, c;</span><br><span class="line">		<span class="keyword">public</span> :</span><br><span class="line">			<span class="built_in">Int</span>() &#123;&#125;</span><br><span class="line">			<span class="built_in">Int</span>(<span class="type">int</span> V) : <span class="built_in">a</span>(V % A), <span class="built_in">b</span>(V % B), <span class="built_in">c</span>(V % C) &#123;&#125;</span><br><span class="line">			<span class="built_in">Int</span>(<span class="type">int</span> X, <span class="type">int</span> Y, <span class="type">int</span> Z) : <span class="built_in">a</span>(X), <span class="built_in">b</span>(Y), <span class="built_in">c</span>(Z) &#123;&#125;</span><br><span class="line">			<span class="function"><span class="type">static</span> <span class="keyword">inline</span> Int <span class="title">reduce</span><span class="params">(<span class="type">const</span> Int &amp;x)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">Int</span> ( (x.a % A + A) % A,  (x.b % B + B) % B, (x.c % C + C) % C );</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">inline</span> <span class="keyword">friend</span> Int <span class="keyword">operator</span> +(<span class="type">const</span> Int &amp;x, <span class="type">const</span> Int &amp;y) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">reduce</span>( <span class="built_in">Int</span> (x.a + y.a, x.b + y.b, x.c + y.c) );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">inline</span> <span class="keyword">friend</span> Int <span class="keyword">operator</span> -(<span class="type">const</span> Int &amp;x, <span class="type">const</span> Int &amp;y) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">reduce</span>( <span class="built_in">Int</span> (x.a - y.a + A, x.b - y.b + B, x.c - y.c + C) );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">inline</span> <span class="keyword">friend</span> Int <span class="keyword">operator</span> *(<span class="type">const</span> Int &amp;x, <span class="type">const</span> Int &amp;y) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">reduce</span>( <span class="built_in">Int</span> (x.a * y.a % A, x.b * y.b % B, x.c * y.c % C) );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="keyword">inline</span> LL <span class="title">ask</span><span class="params">(<span class="type">int</span> P)</span> </span>&#123;</span><br><span class="line">				LL x = (b - a + B) % B * I1 % B * A + a;</span><br><span class="line">				<span class="keyword">return</span> ((LL) (c - x % C + C) % C * I2 % C * ( AB % P ) % P + x) % P;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Data :: Int;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lim, bit;</span><br><span class="line"><span class="type">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	lim = <span class="number">1</span>; bit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(lim &lt; n) lim &lt;&lt;= <span class="number">1</span>, bit ++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(Int *A, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) <span class="keyword">if</span>(i &lt; rev[i]) <span class="built_in">swap</span>(A[i], A[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> dep = <span class="number">1</span>; dep &lt; lim; dep &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		Int Wn = ((type == <span class="number">1</span>) ? </span><br><span class="line">		<span class="built_in">Int</span>( </span><br><span class="line">		Data :: <span class="built_in">power</span>(<span class="number">3</span>, (Data :: A - <span class="number">1</span>) / (dep &lt;&lt; <span class="number">1</span>), Data :: A), </span><br><span class="line">		Data :: <span class="built_in">power</span>(<span class="number">3</span>, (Data :: B - <span class="number">1</span>) / (dep &lt;&lt; <span class="number">1</span>), Data :: B),</span><br><span class="line">		Data :: <span class="built_in">power</span>(<span class="number">3</span>, (Data :: C - <span class="number">1</span>) / (dep &lt;&lt; <span class="number">1</span>), Data :: C) ) :</span><br><span class="line">		<span class="built_in">Int</span>(</span><br><span class="line">		Data :: <span class="built_in">power</span>(Data :: <span class="built_in">power</span>(<span class="number">3</span>, Data :: A - <span class="number">2</span>, Data :: A), (Data :: A - <span class="number">1</span>) / (dep &lt;&lt; <span class="number">1</span>), Data :: A),</span><br><span class="line">		Data :: <span class="built_in">power</span>(Data :: <span class="built_in">power</span>(<span class="number">3</span>, Data :: B - <span class="number">2</span>, Data :: B), (Data :: B - <span class="number">1</span>) / (dep &lt;&lt; <span class="number">1</span>), Data :: B),</span><br><span class="line">		Data :: <span class="built_in">power</span>(Data :: <span class="built_in">power</span>(<span class="number">3</span>, Data :: C - <span class="number">2</span>, Data :: C), (Data :: C - <span class="number">1</span>) / (dep &lt;&lt; <span class="number">1</span>), Data :: C) ) );</span><br><span class="line">		<span class="comment">//cout &lt;&lt; Wn.a &lt;&lt; &#x27; &#x27; &lt;&lt; Wn.b &lt;&lt; &#x27; &#x27; &lt;&lt; Wn.c &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>, len = (dep &lt;&lt; <span class="number">1</span>); j &lt; lim; j += len) &#123;</span><br><span class="line">			<span class="function">Int <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; dep; k ++, w = w * Wn) &#123;</span><br><span class="line">				Int x = A[j + k], y = w * A[j + k + dep];</span><br><span class="line">				A[j + k] = x + y;</span><br><span class="line">				A[j + k + dep] = x - y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(type == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="function">Int <span class="title">inv</span> <span class="params">(Data :: power(lim, Data :: A - <span class="number">2</span>, Data :: A), </span></span></span><br><span class="line"><span class="params"><span class="function">				Data :: power(lim, Data :: B - <span class="number">2</span>, Data :: B),</span></span></span><br><span class="line"><span class="params"><span class="function">				Data :: power(lim, Data :: C - <span class="number">2</span>, Data :: C))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) A[i] = A[i] * inv;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, P;</span><br><span class="line">Int f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> IN</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;P4245_11.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); P = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[i] = <span class="built_in">Int</span> (<span class="built_in">read</span>() % P);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i ++) g[i] = <span class="built_in">Int</span> (<span class="built_in">read</span>() % P); </span><br><span class="line">	<span class="built_in">init</span>(n + m + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(f, <span class="number">1</span>); <span class="built_in">NTT</span>(g, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++) f[i] = f[i] * g[i];</span><br><span class="line">	<span class="built_in">NTT</span>(f, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + m; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, f[i].<span class="built_in">ask</span>(P));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常系数齐次线性递推-amp-BM算法"><a href="#常系数齐次线性递推-amp-BM算法" class="headerlink" title="常系数齐次线性递推 &amp; BM算法"></a>常系数齐次线性递推 &amp; BM算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BerlekampMassey &#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> P = <span class="number">998244353</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x + ((x &gt;&gt; <span class="number">31</span>) &amp; P); &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123; x = (x % P + P) % P;</span><br><span class="line">		<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(k) &#123;</span><br><span class="line">			<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL) res * x % P;</span><br><span class="line">			x = (LL) x * x % P; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">getfac</span><span class="params">(<span class="type">int</span> q, <span class="type">int</span> A = <span class="number">10000</span>)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> x = q, y = P, a = <span class="number">1</span>, b = <span class="number">0</span>;</span><br><span class="line"> 		<span class="keyword">while</span> (x &gt; A) &#123;</span><br><span class="line">  			<span class="built_in">swap</span>(x, y); <span class="built_in">swap</span>(a, b);</span><br><span class="line">   			a -= x / y * b;</span><br><span class="line">   			x %= y;</span><br><span class="line">  		&#125;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="built_in">make_pair</span>(x, a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">solve</span><span class="params">(<span class="type">int</span> *A, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; ans, lst;</span><br><span class="line">		<span class="type">int</span> w = <span class="number">0</span>, delta = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">			<span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j ++)</span><br><span class="line">				tmp = (tmp + (LL) A[i - j - <span class="number">1</span>] * ans[j] % P) % P;</span><br><span class="line">			<span class="keyword">if</span>((A[i] - tmp) % P == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(! w) &#123;</span><br><span class="line">				w = i;</span><br><span class="line">				delta = A[i] - tmp; delta = (delta % P + P) % P;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j = i; j; j --) ans.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			vector&lt;<span class="type">int</span>&gt; now = ans;</span><br><span class="line">			<span class="type">int</span> mul = (LL) (A[i] - tmp + P) * <span class="built_in">power</span>(delta, P - <span class="number">2</span>) % P;</span><br><span class="line">			<span class="keyword">if</span>(ans.<span class="built_in">size</span>() &lt; lst.<span class="built_in">size</span>() + i - w) ans.<span class="built_in">resize</span>(lst.<span class="built_in">size</span>() + i - w);</span><br><span class="line">			ans[i - w - <span class="number">1</span>] = (ans[i - w - <span class="number">1</span>] + mul) % P;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; lst.<span class="built_in">size</span>(); j ++)</span><br><span class="line">				ans[i - w + j] = (ans[i - w + j] - (LL) mul * lst[j] % P + P) % P;</span><br><span class="line">			<span class="keyword">if</span>(now.<span class="built_in">size</span>() - i &lt; lst.<span class="built_in">size</span>() - w) &#123;</span><br><span class="line">				lst = now; w = i; delta = A[i] - tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x + ((x &gt;&gt; <span class="number">31</span>) &amp; P); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL) res * x % P;</span><br><span class="line">		x = (LL) x * x % P; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Poly</span> &#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="built_in">Poly</span>(<span class="type">int</span> SZ = <span class="number">0</span>) &#123; vec.<span class="built_in">resize</span>(SZ); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> len)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">while</span>(vec.<span class="built_in">size</span>() &lt; len) vec.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(vec.<span class="built_in">size</span>() &gt; len) vec.<span class="built_in">pop_back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vec.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> &amp; <span class="keyword">operator</span> [] (<span class="type">int</span> id) &#123; <span class="keyword">return</span> vec[id]; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = vec.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) </span><br><span class="line">			ans = (vec[i] + (LL) v * ans % P) % P;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">deri</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inte</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span></span>;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Poly :: <span class="built_in">reverse</span>() &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>() - i; i ++) <span class="built_in">swap</span>(vec[i], vec[vec.<span class="built_in">size</span>() - i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> +(Poly x, Poly y) &#123;</span><br><span class="line">	Poly z;</span><br><span class="line">	<span class="keyword">if</span>(x.<span class="built_in">size</span>() &lt; y.<span class="built_in">size</span>()) std :: <span class="built_in">swap</span>(x, y);</span><br><span class="line">	z = x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; y.<span class="built_in">size</span>(); i ++) </span><br><span class="line">		z[i] = <span class="built_in">Mod</span>(z[i] + y[i] - P);</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> -(Poly x, Poly y) &#123;</span><br><span class="line">	Poly z = x;</span><br><span class="line">	<span class="keyword">if</span>(z.<span class="built_in">size</span>() &lt; y.<span class="built_in">size</span>()) z.<span class="built_in">resize</span>(y.<span class="built_in">size</span>()); </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; y.<span class="built_in">size</span>(); i ++) z[i] = <span class="built_in">Mod</span>(z[i] - y[i]);</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly x, Poly y) &#123;</span><br><span class="line">	<span class="function">Poly <span class="title">z</span><span class="params">(x.size() + y.size() - <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; x.<span class="built_in">size</span>(); i ++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; y.<span class="built_in">size</span>(); j ++)</span><br><span class="line">			z[i + j] = <span class="built_in">Mod</span>(z[i + j] + (LL) x[i] * y[j] % P - P);</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> ~(Poly f) &#123;</span><br><span class="line">	<span class="function">Poly <span class="title">g</span><span class="params">(f.size())</span></span>;</span><br><span class="line">	g[<span class="number">0</span>] = <span class="built_in">power</span>(f[<span class="number">0</span>], P - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">1</span>; n &lt; f.<span class="built_in">size</span>(); n ++) &#123;</span><br><span class="line">		<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) res = <span class="built_in">Mod</span>(res + (LL) g[i] * f[n - i] % P - P);</span><br><span class="line">		g[n] = P - (LL) g[<span class="number">0</span>] * res % P;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Poly <span class="keyword">operator</span> /(Poly F, Poly G) &#123;</span><br><span class="line">	<span class="type">int</span> n = F.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> m = G.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	Poly RF = F, RG = G;</span><br><span class="line">	RF.<span class="built_in">reverse</span>(); RF.<span class="built_in">resize</span>(n - m + <span class="number">1</span>);</span><br><span class="line">	RG.<span class="built_in">reverse</span>(); RG.<span class="built_in">resize</span>(n - m + <span class="number">1</span>);</span><br><span class="line">	Poly IRG = ~ RG, Q = RF * IRG; </span><br><span class="line">	Q.<span class="built_in">resize</span>(n - m + <span class="number">1</span>); Q.<span class="built_in">reverse</span>();</span><br><span class="line">	Q.<span class="built_in">resize</span>(n - m + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Poly <span class="keyword">operator</span> %(Poly F, Poly G) &#123;</span><br><span class="line">	<span class="keyword">if</span>(F.<span class="built_in">size</span>() &lt; G.<span class="built_in">size</span>()) <span class="keyword">return</span> F;</span><br><span class="line">	Poly Q = F / G;</span><br><span class="line">	Poly R = F - Q * G;</span><br><span class="line">	R.<span class="built_in">resize</span>(G.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recursion</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;p, vector&lt;<span class="type">int</span>&gt; &amp;f, LL n)</span> </span>&#123;</span><br><span class="line">	<span class="function">Poly <span class="title">pl</span><span class="params">(p.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">	pl[p.<span class="built_in">size</span>()] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); i ++) </span><br><span class="line">		pl[i] = P - p[p.<span class="built_in">size</span>() - i - <span class="number">1</span>];</span><br><span class="line">	<span class="function">Poly <span class="title">x</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	x[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n &amp; <span class="number">1</span>) res = res * x % pl;</span><br><span class="line">		x = x * x % pl; n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; f.<span class="built_in">size</span>(); i ++) ans = <span class="built_in">Mod</span>(ans + (LL) res[i] * f[i] % P - P);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> A[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; A[i];</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; p, f;</span><br><span class="line">	p = BerlekampMassey :: <span class="built_in">solve</span>(A, n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v : p) cout &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span>; cout &lt;&lt; endl;</span><br><span class="line">	f.<span class="built_in">resize</span>(p.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); i ++) f[i] = A[i + <span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> ans = <span class="built_in">recursion</span>(p, f, m);</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s\n%s&quot;</span>, s1 + <span class="number">1</span>, s2 + <span class="number">1</span>);</span><br><span class="line">n = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line">m = <span class="built_in">strlen</span>(s2 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">	<span class="keyword">while</span>(j &amp;&amp; s2[j + <span class="number">1</span>] != s2[i]) j = p[j];</span><br><span class="line">	<span class="keyword">if</span>(s2[j + <span class="number">1</span>] == s2[i]) j ++;</span><br><span class="line">	p[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">	<span class="keyword">while</span>(j &amp;&amp; s1[i] != s2[j + <span class="number">1</span>]) j = p[j];</span><br><span class="line">	<span class="keyword">if</span>(s2[j + <span class="number">1</span>] == s1[i]) j ++;</span><br><span class="line">	<span class="keyword">if</span>(j == m) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i - m + <span class="number">1</span>);</span><br><span class="line">		j = p[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">lep</span> (i, <span class="number">1</span>, m) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, p[i], <span class="string">&quot; \n&quot;</span>[i == m]);</span><br></pre></td></tr></table></figure>
<h2 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std :: cin;</span><br><span class="line"><span class="keyword">using</span> std :: cout;</span><br><span class="line"><span class="keyword">using</span> std :: cerr;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); </span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; s[i], s[i + n] = s[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ) &#123;</span><br><span class="line">		<span class="type">int</span> j = i, k = i + <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">while</span>(k &lt;= <span class="number">2</span> * n &amp;&amp; s[j] &lt;= s[k]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s[j] &lt; s[k]) j = i;</span><br><span class="line">			<span class="keyword">else</span> j ++;</span><br><span class="line">			k ++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">			<span class="comment">//ans ^= i + k - j - 1;</span></span><br><span class="line">			i += k - j;</span><br><span class="line">			<span class="keyword">if</span>(i &lt;= n) ans = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cout &lt;&lt; s[ans - <span class="number">1</span> + i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动机相关"><a href="#自动机相关" class="headerlink" title="自动机相关"></a>自动机相关</h2><p>基本定义与约定：</p>
<ul>
<li>称字符串 $T$ 匹配 $S$ 为 $T$ 在 $S$ 中出现。</li>
<li><strong>模式串</strong>：相当于题目给出的 <strong>字典</strong>，用于匹配的字符串。下文也称 <strong>单词</strong>。</li>
<li><strong>文本串</strong>：被匹配的字符串。</li>
<li>更多约定见 常见字符串算法。</li>
</ul>
<h3 id="AC-自动机-ACAM"><a href="#AC-自动机-ACAM" class="headerlink" title="AC 自动机 ACAM"></a>AC 自动机 ACAM</h3><hr>
<p>前置知识：字典树，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/alex-wei/p/Common_String_Theory_Theory.html">KMP</a> 算法与 <strong>动态规划</strong> 思想。</p>
<p>AC 自动机是一类确定有限状态自动机，这说明它有完整的 DFA 五要素，分别是起点 $s$（Trie 树根节点），状态集合 $Q$（Trie 树上所有节点），接受状态集合 $F$（所有以某个单词作为后缀的节点），字符集 $\Sigma$（题目给定）和转移函数 $\delta$（类似 KMP 求解）。</p>
<p>AC 自动机全称 Aho-Corasick Automaton，简称 ACAM。它的用途非常广泛，是重要的字符串算法（$8$ 级）。</p>
<h4 id="1-1-算法详解"><a href="#1-1-算法详解" class="headerlink" title="1.1 算法详解"></a>1.1 算法详解</h4><p>AC 自动机用于解决 <strong>多模式串</strong> 匹配问题：给定 <strong>字典</strong> $s$ 和文本串 $t$，求每个单词 $s_i$ 在 $t$ 中出现的次数。当然，它的实际应用十分广泛，远超这一基本问题。ACAM 与 KMP 的不同点在于后者仅有一个模式串，而前者有多个。</p>
<p>朴素的基于 KMP 的暴力时间复杂度为 $|t|\times N + \sum |s_i|$，其中 $N$ 是单词个数。因为进行一次匹配的时间复杂度为 $|s_i| + |t|$。当单词数量 $N$ 较大时，无法接受。</p>
<p>多串问题自然首先考虑建出字典树。根据其定义，字典树上任意节点 $q\in Q$ 与所有单词的某个前缀 <strong>一一对应</strong>。设节点（节点也称状态）$i$ 表示的字符串为 $t_i$。</p>
<p>借鉴 KMP 算法的思想，我们考虑对于每个状态 $q$，求出其 <strong>失配指针</strong> $fail_q$。类似 KMP 的失配数组 $nxt$，失配指针的含义为：$q$ 所表示字符串 $t_q$ 的 <strong>最长真后缀</strong> $t_q[j, |t_q|]\ (2\leq j\leq |t_q| + 1)$，使得该后缀作为某个单词的前缀出现。这说明 $t_q[j, |t_q|]$ 恰好对应了字典树上某个状态，因此一个状态的失配指针指向另一个长度比它短的状态。注意，这样的后缀 <strong>可能不存在</strong>，因此失配指针可能指向表示空串的根节点。</p>
<p>从 $q$ 向字符串 $fail_q$ 连一条有向边，就得到了 ACAM 的 <strong>fail 树</strong>。</p>
<ul>
<li>例如，当 $s = {\texttt{b},\ \texttt{ab}}$ 时，$\tt ab$ 会向 $\tt b$ 连边，因为 $\tt ab$ 最长的（也是唯一的）在 $s_i$ 中作为前缀出现的后缀为 $\tt b$。</li>
<li>再例如，当 $s = {\texttt{aba},\ \texttt {baba}}$ 时，$\tt ab$ 会向 $\tt b$ 连边， $\tt bab$ 会向 $\tt ab$ 连边，$\tt aba$ 会向 $\tt ba$ 连边，而 $\tt baba$ 会向 $\tt aba$ 连边。对于每一条有向边 $q \to fail_q$，后者是前者的后缀，也是 $s_i$ 的前缀。</li>
</ul>
<p>考虑用类似 KMP 的算法求解失配指针：首先令 $fail<em>q\gets fail</em>{fa<em>q}$。若当前的 $fail_q$ 没有 $fa_q\to q$ 这条（字典树上的）边所表示的字符 $c$ 的转移，则令 $fail_q\gets fail</em>{fail_q}$，否则 $fail_q = \mathrm{trans}(fail_q, c)$，即字典树上在 $fail_q$ 处添加字符 $c$ 后到达的状态。若 $fail_q$ 已经指向根，但还是没找到出边，则 $fail_q$ 最终就指向根。</p>
<p>失配指针已经足够强大，但这并不是 AC 自动机的完全体。我们尝试将每个状态的所有字符转移 $\delta(i, c)$ 都封闭在状态集合 $Q$ 里面。把 KMP 自动机的转移拎出来观察</p>
<script type="math/tex; mode=display">\delta(i, c) = \begin{cases} i+1 & s_{i + 1} = c \\ 0 & s_{i + 1} \neq c \land i = 0 \\ \delta(nxt_i, c) & s_{i + 1} \neq c \land i \neq 0 \\ \end{cases}</script><p>设字典树的根为节点 $0$，AC 自动机的转移可类似地写为：</p>
<script type="math/tex; mode=display">\delta(i,c) = \begin{cases} \mathrm{trans}(i, c) & \mathrm{if}\ \mathrm{trans}(i, c)\ \mathrm{exist} \\ 0 & \mathrm{if}\ \mathrm{trans}(i, c)\ \mathrm{doesn't\ exist} \land i = 0\ (\mathrm{which\ is \ root}) \\ \delta(fail_i, c) & \mathrm{if}\ \mathrm{trans}(i, c)\ \mathrm{doesn't\ exist} \land i \neq 0 \end{cases}</script><p>$\delta(i,c)$ 表示往状态 $i$ 后面添加字符 $c$，所得字符串的 <strong>最长的</strong> 与 $s_i$ <strong>前缀</strong> 匹配的 <strong>后缀</strong> 所表示的状态。也可理解为从 $i$ 开始跳 $fail$ 指针，遇到的第一个有字符 $c$ 的转移对应转移到的节点：若 $i$ 本身有转移，则 $\delta(i, c)$ 就等于 $\mathrm{trans}(i, c)$，否则向上跳一层 $fail$ 指针，等于 $\delta(fail_i, c)$。</p>
<p>根据已有信息递推，这是 <strong>动态规划</strong> 的核心思想。即求解 $\delta$ 函数的的过程本质上是一类 DP。</p>
<p>当 $\mathrm{trans}(i, c)$ 存在时，设其为 $q$， 则有 $fail_q = \delta(fail_i, c)$。因为根据求 $fail_q$ 的方法，我们会先令 $fail_q \gets fail_i$，然后跳到第一个有字符 $c$ 的位置，令 $fail_q$ 等于该位置添加 $c$ 转移到的状态。这和 $\delta(fail_i, c)$ 的定义等价。</p>
<p>有了这一性质，我们就不需要预先求出失配指针，而是在建造 AC 自动机的同时一并求出。由于我们需要保证在计算一个状态的转移时，其失配指针指向的状态的转移已经计算完毕，又因为失配指针长度小于原串长度，故使用 BFS 建立 AC 自动机。一般形式的 AC 自动机代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> node, son[N][S], fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(string s)</span> </span>&#123; <span class="comment">// 建出 trie 树</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">char</span> it : s) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!son[p][it - <span class="string">&#x27;a&#x27;</span>]) son[p][it - <span class="string">&#x27;a&#x27;</span>] = ++node;</span><br><span class="line"></span><br><span class="line">		p = son[p][it - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123; <span class="comment">// 建出 AC 自动机</span></span><br><span class="line"></span><br><span class="line">	queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++) <span class="keyword">if</span>(son[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(son[<span class="number">0</span>][i]); <span class="comment">// 对于第一层特判，因为 fa[0] = 0，此处即转移的第二种情况</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123; <span class="comment">// 求得的 son[t][i] 就是文章中的转移函数 delta(t, i)，相当于合并了 trie 和 AC 自动机的转移函数</span></span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(son[t][i]) fa[son[t][i]] = son[fa[t]][i], q.<span class="built_in">push</span>(son[t][i]); <span class="comment">// 转移的第一种情况：原 trie 图有 trans(t, i) 的转移</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> son[t][i] = son[fa[t]][i]; <span class="comment">// 转移的第三种情况</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特别的，在 ACAM 上会有一些 <strong>终止节点</strong> $p$，代表一个单词或以一个单词结尾，即 $p$ 对应的字符串 $t_p$ 的某个 <strong>后缀</strong> 在字典 $s$ 中作为 <strong>单词</strong> 出现。 若状态 $p$ 本身表示一个单词，即 $t_p\in s$，则称为 <strong>单词节点</strong>。所有终止节点 $p$ 对应着 DFA 的 <strong>接受状态集合</strong> $F$：ACAM 接受且仅接受以给定词典中的某一个单词结尾的字符串。</p>
<p>总结一下我们使用到的约定和定义：</p>
<ul>
<li>节点也被称为 <strong>状态</strong>。</li>
<li>设字典树上状态 $i$ 所表示的字符串为 $t_i$。</li>
<li><strong>失配指针</strong> $fail_q$ 的含义为 $q$ 所表示字符串 $t_q$ 的最长真后缀 $t_q[j, |t_q|]\ (2\leq j\leq |t_q| + 1)$ 使得该后缀作为某个单词的前缀出现。</li>
<li>$\delta(i,c)$ 表示往状态 $i$ 后添加字符 $c$，所得字符串的 <strong>最长的</strong> 与某个单词的 <strong>前缀</strong> 匹配的 <strong>后缀</strong> 所表示的状态。它也是从 $i$ 开始，不断跳失配指针直到遇到一个有字符 $c$ 转移的状态 $p$，添加字符 $c$ 后得到的状态 $\mathrm{trans}(p, c)$。</li>
<li><strong>终止节点</strong> $p$ 代表一个单词，或以一个单词结尾。</li>
<li>所有终止节点 $p$ 组成的集合对应着 DFA 的 <strong>接受状态集合</strong> $F$。</li>
<li>若状态 $p$ 本身表示一个单词，即 $t_p\in s$，则称为 <strong>单词节点</strong>。</li>
</ul>
<h4 id="1-2-fail-树的性质与应用"><a href="#1-2-fail-树的性质与应用" class="headerlink" title="1.2 fail 树的性质与应用"></a>1.2 fail 树的性质与应用</h4><p>AC 自动机的核心就在于 fail 树。它有非常好的性质，能够帮我们解决很多问题。</p>
<ul>
<li>性质 0：它是一棵 <strong>有根树</strong>，支持树剖，时间戳拍平，求 LCA 等各种树上路径或子树操作。</li>
<li>性质 1：对于节点 $p$ 及其对应字符串 $t_p$，对于其子树内部所有节点 $q\in \mathrm{subtree}(p)$，都有 $t_p$ 是 $t_q$ 的后缀，且 $t_p$ 是 $t_q$ 的后缀 <strong>当且仅当</strong> $q\in \mathrm{subtree}(p)$。根据失配指针的定义易证。</li>
<li>性质 2：若 $p$ 是终止节点，则 $p$ 的子树全部都是终止节点。根据 fail 指针的定义，容易发现对于在 fail 树上具有祖先 - 后代关系的点对 $p,q$，$t_p$ 是 $t_q$ 的 Border，这意味着 $t_p$ 是 $t_q$ 的后缀。因此，若 $t_p$ 以某个单词结尾，则 $t_q$ 也一定以该单词结尾，得证。</li>
<li>性质 3：定义 $ed_p$ 表示作为 $t_p$ 后缀的单词数量。若单词互不相同，则 $ed_p$ 等于 fail 树从 $p$ 到根节点上单词节点的数量。若单词可以重复，则 $ed_p$ 等于这些单词节点所对应的单词的出现次数之和。</li>
<li>常用结论：一个单词在匹配串 $S$ 中出现次数之和，等于它在 $S$ 的 <strong>所有前缀中作为后缀出现</strong> 的次数之和。</li>
</ul>
<p>根据性质 3，有这样一类问题：单词有带修权值，多次询问对于某个给定的字符串 $S$，所有单词的权值乘以其在 $S$ 中出现次数之和。根据常用结论，问题初步转化为 fail 树上带修点权，并对于 $S$ 的每个前缀，查询该前缀所表示的状态到根的权值之和。</p>
<p>通常带修链求和要用到树剖，但查询具有特殊性质：一个端点是根。因此，与其单点修改链求和，不如 <strong>子树修改单点查询</strong>。实时维护每个节点的答案，这样修改一个点相当于更新子树，而查询时只需查单点。转化之前的问题需要树剖 + 数据结构 $\log ^ 2$ 维护，但转化后即可时间戳拍平 + 树状数组单 $\log$ 小常数解决。</p>
<p>补充：对于普通的链求和，只需差分转化为三个到根链求和也可以使用上述技巧。<strong>链加，单点查询</strong> 也可以通过转化变成 <strong>单点加，子树求和</strong>。只要包含一个单点操作，一个链操作，均可以将链操作转化为子树操作，即可将时间复杂度更大的树剖 BIT 换成普通 BIT。</p>
<ul>
<li>性质 4：把字符串 $t$ 放在字典 $s$ 的 AC 自动机上跑，得到的状态为 $t$ 的最长后缀，满足它是 $s$ 的前缀。</li>
</ul>
<h4 id="1-3-应用"><a href="#1-3-应用" class="headerlink" title="1.3 应用"></a>1.3 应用</h4><p>大部分时候，我们借助 ACAM 刻画多模式串的匹配关系，求出文本串与字典的 <strong>最长匹配后缀</strong>。但 ACAM 也可以和动态规划结合：在利用动态规划思想构建的自动机上进行 DP，这是 <strong>DP 自动机</strong> 算法。</p>
<h5 id="1-3-1-结合动态规划"><a href="#1-3-1-结合动态规划" class="headerlink" title="1.3.1 结合动态规划"></a>1.3.1 结合动态规划</h5><p>ACAM 除了能够进行字符串匹配，还常与动态规划相结合，因为它精确刻画了文本串与 <strong>所有</strong> 模式串的匹配情况。同时，$\delta$ 函数自然地为动态规划的转移指明了方向。因此，当遇到形如 “<strong>不能出现若干单词</strong>” 的字符串 <strong>计数或最优化</strong> 问题，可以考虑在 ACAM 上 DP，将 ACAM 的状态写进 DP 的一个维度。</p>
<p>例如非常经典的 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4052">[JSOI2007] 文本生成器</a>。题目要求至少包含一个单词，补集转化相当于求 <strong>不包含任何一个单词</strong> 的长为 $m$ 的字符串数量。考虑到我们只关心当前字符串的长度，和它与所有单词的匹配情况，设 $f<em>{i,j}$ 表示长为 $i$ 且放到所有单词建出的 ACAM 上能够转移到状态 $j$ 的字符串数量。转移即枚举下一个字符 $c$ 是什么，$f</em>{i,j}\to f<em>{i+1,\delta(j,c)}$。根据限制，需要保证 $j$ 和 $\delta(j,c)$ 都不是终止节点，最终答案即 $26^m-\sum</em>{\ q\in Q\land q\notin F} f_{m, q}$。时间复杂度 $\mathcal{O}(nm|\Sigma||s_i|)$。</p>
<p>具体转移方式视题目而定。矩阵乘法也可以是广义矩阵乘法，如例 <em>XII.</em></p>
<h4 id="1-4-注意点"><a href="#1-4-注意点" class="headerlink" title="1.4 注意点"></a>1.4 注意点</h4><ul>
<li>建出字典树后不要忘记调用 <code>build</code> 建出 ACAM。</li>
<li>注意模式串是否可以重复。</li>
<li>在构建 ACAM 的过程中，不要忘记递推每个节点需要的信息。如 $ed<em>p$ 由 $ed</em>{fa_p}$ 和状态 $p$ 所表示的单词数量相加得到。</li>
</ul>
<h4 id="1-5-例题"><a href="#1-5-例题" class="headerlink" title="1.5 例题"></a>1.5 例题</h4><h5 id="I-P3808-【模板】AC-自动机（简单版）"><a href="#I-P3808-【模板】AC-自动机（简单版）" class="headerlink" title="I. P3808 【模板】AC 自动机（简单版）"></a>I. <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3808">P3808 【模板】AC 自动机（简单版）</a></h5><p>本题相同编号的串多次出现仅算一次，因此题目相当于求：文本串 $t$ 在模式串 $s_i$ 建出的 ACAM 上匹配时经过的所有节点到根的路径的并上单词节点的个数。</p>
<p>设当前状态为 $p$，每次跳 $p$ 的失配指针，加上经过节点表示的单词个数（单词可能相同）并标记，直到遇到标记节点 $q$，说明 $q$ 到根都已经被考虑到。注意上述过程并不改变 $p$ 本身。时间复杂度线性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, node, son[N][S], fa[N], ed[N];</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">char</span> it : s) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!son[p][it - <span class="string">&#x27;a&#x27;</span>]) son[p][it - <span class="string">&#x27;a&#x27;</span>] = ++node;</span><br><span class="line"></span><br><span class="line">		p = son[p][it - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">	&#125; ed[p]++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++) <span class="keyword">if</span>(son[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(son[<span class="number">0</span>][i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(son[t][i]) fa[son[t][i]] = son[fa[t]][i], q.<span class="built_in">push</span>(son[t][i]);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> son[t][i] = son[fa[t]][i];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; s, <span class="built_in">ins</span>(s);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>, ans = <span class="number">0</span>; cin &gt;&gt; s, <span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">char</span> it : s) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> tmp = p = son[p][it - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(ed[tmp] != <span class="number">-1</span>) ans += ed[tmp], ed[tmp] = <span class="number">-1</span>, tmp = fa[tmp];</span><br><span class="line"></span><br><span class="line">	&#125; cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后缀自动机-SAM"><a href="#后缀自动机-SAM" class="headerlink" title="后缀自动机 SAM"></a>后缀自动机 SAM</h3><p>后缀自动机全称 Suffix Automaton，简称 SAM，是一类极其有用但难以真正理解的字符串后缀结构（$10$ 级）。它是笔者一年以前学习的算法，现在进行复习并重构学习笔记，看看能不能悟到一些新的东西。</p>
<h4 id="2-1-基本定义与引理"><a href="#2-1-基本定义与引理" class="headerlink" title="2.1 基本定义与引理"></a>2.1 基本定义与引理</h4><p>SAM 相关的定义非常多，需要牢记并充分理解它们，否则学习 SAM 会非常吃力，因为符号化的语言相较于直观的图片和实例更难以理解。</p>
<p>首先，我们给出 SAM 的定义：一个长为 $n$ 的字符串 $s$ 的 SAM 是一个接受 $s$ 的所有 <strong>后缀</strong> 的 <strong>最小</strong> 的有限状态自动机。具体地，SAM 有 <strong>状态集合</strong> $Q$，每个状态是有向无环图上的一个节点。从每个状态出发有若干条或零条 <strong>转移边</strong>，每条转移边都 <strong>对应一个字符</strong>（因此，一条路径表示一个 <strong>字符串</strong>），且从一个状态出发的转移互不相同。根据 DFA 的定义，SAM 还存在 <strong>终止状态集合</strong> $F$，表示从初始状态 $T$ 到任意终止状态的任意一条路径与 $s$ 的一个 <strong>后缀</strong> 一一对应。</p>
<p>SAM 最重要，也是最基本的一个性质：从 $T$ 到任意状态的所有路径与 $s$ 的 <strong>所有</strong> 子串 <strong>一一对应</strong>。我们称状态 $p$ 表示字符串 $t_p$，当且仅当存在一条 $T\to p$ 的路径使得该路径所表示的字符串为 $t_p$。根据上述性质，$t_p$ 是 $s$ 的子串。</p>
<ul>
<li>定义转移边 $p\to q$ 表示的字符为 $c_{p, q}$。</li>
<li>定义 $\delta(p, c)$ 表示状态 $p$ 添加字符 $c$ 转移到的状态。</li>
<li>定义 <strong>前缀</strong> 状态集合 $P$ 由所有前缀 $s[1, i]$ 对应的状态组成。</li>
<li><p>SAM 的有向无环转移图也是有向无环单词图（DAWG, Directed Acyclic Word Graph）。</p>
</li>
<li><p>$\mathrm{endpos}(t)$：<strong>字符串</strong> $t$ 在 $s$ 中所有出现的 <strong>结束位置</strong> 的 <strong>集合</strong>。例如，当 $s = \texttt{“abcab”}$ 时，$\mathrm{endpos}(\texttt{“ab”}) = {2, 5}$，因为 $s[1 : 2] = s[4 : 5] = \texttt{“ab”}$。</p>
</li>
<li>$\mathrm{substr}(p)$：<strong>状态</strong> $p$ 所表示的所有子串的 <strong>集合</strong>。</li>
<li>$\mathrm{shortest}(p)$：<strong>状态</strong> $p$ 所表示的所有子串中，长度 <strong>最短</strong> 的那一个子串。</li>
<li>$\mathrm{longest}(p)$：<strong>状态</strong> $p$ 所表示的所有子串中，长度 <strong>最长</strong> 的那一个子串。</li>
<li>$\mathrm{minlen}(p)$：<strong>状态</strong> $p$ 所表示的所有子串中，长度 <strong>最短</strong> 的那一个子串的 <strong>长度</strong>。$\mathrm{minlen}(i) = |\mathrm{shortest}(i)|$。</li>
<li>$\mathrm{len}(i)$：<strong>状态</strong> $p$ 所表示的所有子串中，长度 <strong>最长</strong> 的那一个子串的 <strong>长度</strong>。$\mathrm{len}(i)=|\mathrm{longest}(i)|$。</li>
</ul>
<p>两个字符串 $t_1, t_2$ 的 $\mathrm{endpos}$ 可能相等。例如当 $s = \texttt{“abab”}$ 时，$\mathrm{endpos}(\texttt{“b”}) = \mathrm{endpos}(\texttt{“ab”})$。这样，我们可以将 $s$ 的子串划分为若干 <strong>等价类</strong>，用一个状态表示。SAM 的每个状态对应若干 $\mathrm{endpos}$ 集合相同的子串。换句话说，$\forall t\in \mathrm{substr}(p)$，$\mathrm{endpos}(t)$ 相等。因此，SAM 的状态数等于所有子串的等价类个数（初始状态对应空串）。</p>
<p>读者应该有这样的直观印象：SAM 的每个状态 $p$ 都表示一个独一无二的 $\mathrm{endpos}$ 等价类，它对应着在 $s$ 中出现位置相同的一些子串 $\mathrm{substr}(p)$。$\mathrm{shortest}(p),\mathrm{longest}(p),\mathrm{minlen}(p)$ 和 $\mathrm{len}(p)$ 描述了 $\mathrm{substr}(p)$ 最短和最长的子串及其长度。</p>
<p>转移边与 $\mathrm{substr}$ 的联系：任意一条 $T\to p$ 的路径 $P$ 所表示的字符串 $t_{P}\in \mathrm{substr}(p)$。</p>
<p>在引出 SAM 的核心定义<strong>「后缀链接」</strong>前，我们需要证明关于上述概念的一些性质。下列引理的内容部分来自 OI-wiki，相关链接见 Part 2.4.</p>
<blockquote>
<p><strong>引理 1</strong>：考虑两个非空子串 $u$ 和 $w$（假设 $|u|\leq |w|$）。要么 $\mathrm{endpos}(u)\cup \mathrm{endpos}(w)=\varnothing$，要么 $\mathrm{endpos}(w) \subseteq \mathrm{endpos}(u)$，取决于 $u$ 是否为 $w$ 的一个后缀：</p>
<script type="math/tex; mode=display">\begin{cases} \mathrm{endpos}(w) \subseteq \mathrm{endpos}(u) & \mathrm{if} \ u\ \mathrm{is\ a\ suffix\ of}\ w \\ \mathrm{endpos}(u) \cup \mathrm{endpos}(w) = \varnothing & \mathrm{otherwise} \end{cases}</script></blockquote>
<p>证明：若存在位置 $i$ 满足 $i\in \mathrm{endpos}(u)$ 且 $i\in \mathrm{endpos}(w)$，说明 $u$ 和 $w$ 以 $i$ 为结束位置在 $s$ 中出现。由于 $|u|\leq |w|$，所以 $u$ 必然是 $w$ 的后缀，因此 $w$ 出现的位置 $u$ 必然以 $w$ 的后缀形式出现，即对于任意 $i\in \mathrm{endpos}(w)$ 有 $i\in \mathrm{endpos}(u)$。否则不存在这样的位置 $i$，即 $\mathrm{endpos}(u) \cup \mathrm{endpos}(w) = \varnothing$。</p>
<blockquote>
<p><strong>引理 2</strong>：考虑一个状态 $p$。$p$ 所表示的所有子串长度连续，且 <strong>较短者总是较长者的后缀</strong>。</p>
</blockquote>
<p>证明：根据引理 1，若两个子串 $\mathrm{endpos}$ 相同（这也说明它们属于相同状态），则较短者总是较长者的后缀，后半部分得证。</p>
<p>对于前半部分考虑反证：假设 $\mathrm{longest}(p)$ 长为 $L\ (\mathrm{minlen}(p) &lt; L &lt; \mathrm{len}(p))$ 的后缀 $t_L\notin \mathrm{substr}(p)$。由于 $t_L$ 是 $\mathrm{longest}(p)$ 的 <strong>真后缀</strong>，故 $\mathrm{endpos}(\mathrm{longest}(p)) \subseteq \mathrm{endpos}(t_L)$。根据假设，$\mathrm{endpos}(\mathrm{longest}(p)) \neq \mathrm{endpos}(t_L)$。又因为 $\mathrm{shortest}(p)$ 是 $t_L$ 的 <strong>真后缀</strong>，故 $\mathrm{endpos}(t_L) \subseteq \mathrm{endpos}(\mathrm{shortest}(p))$，因此 $|\mathrm{endpos}(\mathrm{longest}(p))| &lt; |\mathrm{endpos}(t_L)| \leq |\mathrm{endpos}(\mathrm{shortest}(p))|$，这与 $\mathrm{endpos}(\mathrm{longest}(p)) = \mathrm{endpos}(\mathrm{shortest}(p))$ 矛盾，证毕。</p>
<p>简单地说，对于一个子串 $t$ 的所有后缀，其 $\mathrm{endpos}$ 集合大小随着后缀长度减小而单调不降。这很好理解：<strong>后缀越长，在 $s$ 中出现的位置就越少</strong>。</p>
<blockquote>
<p><strong>推论 1</strong>：对于子串 $t$ 的所有后缀，其 $\mathrm{endpos}$ 集合大小随后缀长度减小而单调不降，且 <strong>较小的 $\mathrm{endpos}$ 集合包含于较大的 $\mathrm{endpos}$ 集合</strong>。</p>
</blockquote>
<p>引理 2 是非常重要的性质。有了它，我们就可以定义后缀链接了。</p>
<ul>
<li>定义状态 $p$ 的 <strong>后缀链接</strong> $\mathrm{link}(p)$ 指向 $\mathrm{longest}(p)$ <strong>最长</strong> 的一个后缀 $w$ 满足 $w\notin \mathrm{substr}(p)$ 所在的状态。换句话说，一个后缀链接 $\mathrm{link}(p)$ 连接到对应于 $\mathrm{longest}(p)$ 最长的处于另一个 $\mathrm{endpos}$ 等价类的后缀所在的状态。根据引理 2，$\mathrm{minlen}(i) = \mathrm{len(link}(i))+1$。</li>
</ul>
<blockquote>
<p><strong>引理 3</strong>：所有后缀链接形成一棵以 $T$ 为根的树。</p>
</blockquote>
<p>证明：对于任意不等于 $T$ 的状态，沿着后缀链接移动总能达到一个所表示字符串更短的状态，直到 $T$。</p>
<ul>
<li>定义 <strong>后缀路径</strong> $p\to q$ 表示在后缀链接形成的树上 $p\to q$ 的路径。</li>
</ul>
<blockquote>
<p><strong>引理 4</strong>：通过 $\mathrm{endpos}$ 集合构造的树（每个子节点的 $\mathrm {subset}$ 都包含在父节点的 $\mathrm{subset}$ 中）与通过后缀链接 $\mathrm{link}$ 构造的树相同。</p>
</blockquote>
<p>根据推论 1 与后缀链接的定义容易证明。因此，后缀链接构成的树本质上是 $\mathrm{endpos}$ 集合构成的一棵树。</p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/string/images/SAM/SA_suffix_links.svg"><img src="https://oi-wiki.org/string/images/SAM/SA_suffix_links.svg" alt=""></a></p>
<p>上图图源 OI-wiki。我们给出每个状态的 $\mathrm{endpos}$ 集合以便更好理解引理 4：$\mathrm{endpos}(\texttt{“a”}) = {1}$，</p>
<script type="math/tex; mode=display">\begin{aligned} \mathrm{endpos}(\texttt{"ab"}) = \{2\} \\ \mathrm{endpos}(\texttt{"abcb", "bcb", "cb"}) = \{4\} \\ \end{aligned} \subsetneq \mathrm{endpos}(\texttt{"b"}) = \{2, 4\} \\</script><script type="math/tex; mode=display">\begin{aligned} \mathrm{endpos}(\texttt{"abc"}) = \{3\} \\ \mathrm{endpos}(\texttt{"abcbc", "bcbc", "cbc"}) = \{5\} \\ \end{aligned} \subsetneq \mathrm{endpos}(\texttt{"bc", "c"}) = \{3, 5\} \\</script><h4 id="2-2-关键结论"><a href="#2-2-关键结论" class="headerlink" title="2.2 关键结论"></a>2.2 关键结论</h4><p>我们还需要以下定理确保构建 SAM 的算法的正确性，并使读者对上述定义形成感性的直观的认知。</p>
<blockquote>
<p><strong>结论 1.1</strong>：从任意状态 $p$ 出发跳后缀链接到 $T$ 的路径，所有状态 $q\in p\to T$ 的 $[\mathrm{minlen}(q),\mathrm{len}(q)]$ 不交，单调递减且并集形成 <strong>连续</strong> 区间 $[0,\mathrm{len}(p)]$。</p>
</blockquote>
<p>证明：根据后缀链接的性质 $\mathrm{len}(\mathrm{link}(p)) + 1 = \mathrm{minlen}(p)$ 即证。</p>
<blockquote>
<p><strong>结论 1.2</strong>：从任意状态 $p$ 出发跳后缀链接到 $T$ 的路径，所有状态 $q\in p\to T$ 的 $\mathrm{substr}(q)$ 的并集为 $\mathrm{longest}(p)$ 的 <strong>所有后缀</strong>。</p>
</blockquote>
<p>证明：由结论 1.1 和后缀链接的定义易证。</p>
<blockquote>
<p><strong>结论 2.1</strong>：$\forall t<em>p\in \mathrm{substr}(p)$，若存在 $p\to q$ 的 <strong>转移边</strong>，则 $t_p + c</em>{p,q}\in \mathrm{substr}(q)$。</p>
</blockquote>
<p>证明：根据 $\mathrm{substr}$ 的定义可得。</p>
<blockquote>
<p><strong>结论 2.2</strong>：$\forall t<em>q\in \mathrm{substr}(q)$，若存在 $p\to q$ 的转移边，则 $\exist t_p\in \mathrm{substr}(p)$ 使得 $t_p+c</em>{p,q} = t_q$。</p>
</blockquote>
<p>证明：结论 2.1 的逆命题。这很好理解，因为对于任意 $t<em>q\in \mathrm{substr}(q)$，若不存在这样的 $t_p + c</em>{p,q} = t<em>q$，那么就不存在 $T\to q$ 的路径使得其所表示字符串为 $t_p + c</em>{p,q}$，这与 $t_q\in \mathrm{substr}(q)$ 矛盾。</p>
<blockquote>
<p><strong>结论 3.1</strong>：考虑状态 $q$，不存在转移 $p\to q$ 使得 $\mathrm{len}(p) + 1 &gt; \mathrm{len}(q)$。</p>
</blockquote>
<p>证明：显然。</p>
<blockquote>
<p><strong>结论 3.2</strong>：考虑状态 $q$，<strong> 唯一 </strong> 存在状态 $p$ 和转移 $p\to q$ 使得 $\mathrm{len}(p) + 1 = \mathrm{len}(q)$。</p>
</blockquote>
<p>证明：考虑反证法，若不存在这样的 $p$，说明 $\forall p,\mathrm{len}(p)+1&lt;\mathrm{len}(q)$。根据结论 2.2，$\mathrm{substr}(q)$ 中最长的一个串的长度为 $\max<em>{\ t_p\in \mathrm{substr}(p)} |t_p| + 1$ 即 $\max</em>{\ p} \mathrm{len}(p) + 1$。根据 $\mathrm{len}$ 的定义与 $\mathrm{len}(p) + 1 &lt; \mathrm{len}(q)$，推得 $\mathrm{len}(q) &lt; \mathrm{len}(q)$，矛盾。唯一性不难证明。</p>
<p>简单地说，若数集 $T$ 由若干数集 $S$ 的并加上 $1$ 后得到，那么 $\max<em>{\ s\in S}s + 1 = \max</em>{\ t\in T}t$。</p>
<blockquote>
<p><strong>结论 3.3</strong>：考虑状态 $q$，<strong>唯一</strong> 存在转移 $p\to q$ 使得 $\mathrm{minlen}(p) + 1 = \mathrm{minlen}(q)$。</p>
</blockquote>
<p>证明：同理。</p>
<ul>
<li>定义 $\mathrm{maxtrans}(q)$ 表示使得 $\mathrm{len}(p) + 1 = \mathrm{len}(q)$ 且存在转移 $p\to q$ 的唯一的 $p$。</li>
<li>定义 $\mathrm{mintrans}(q)$ 表示使得 $\mathrm{minlen}(p) + 1 = \mathrm{minlen}(q)$ 且存在转移 $p\to q$ 的唯一的 $p$。</li>
</ul>
<blockquote>
<p><strong>结论 4.1</strong>：考虑状态 $q$，若存在转移 $p\to q$，则 $p$ 在后缀链接树上是 $\mathrm{maxtrans}(q)$ 或其祖先。</p>
</blockquote>
<p>证明：由于所有 $p$ 转移到相同状态 $q$，故所有 $p$ 的 $\mathrm{substr}(p)$ 的并，短串为长串的后缀。根据 $\mathrm{link}$ 树的性质即证。</p>
<blockquote>
<p><strong>结论 4.2</strong>：考虑状态 $q$，若存在转移 $p\to q$，则 $p$ 在后缀链接树上是 $\mathrm{mintrans}(q)$ 或其子节点。</p>
</blockquote>
<p>证明：同理。</p>
<blockquote>
<p><strong>结论 4.3</strong>：考虑状态 $q$，若存在转移 $p\to q$，则所有这样的 $p$ 在 $\mathrm{link}$ 树上形成了一条 <strong>深度递减的链</strong> $\mathrm{maxtrans}(q)\to \mathrm{mintrans}(q)$。</p>
</blockquote>
<p>证明：结合结论 4.1 与结论 4.2 易证。</p>
<p>可以发现上述性质大都与后缀链接有关，因为后缀链接是 SAM 所提供的最重要的核心信息。我们甚至可以抛弃 SAM 的 DAWG，仅仅使用后缀链接就可以解决大部分字符串相关问题。</p>
<ul>
<li>扩展定义：$\mathrm{substr}(p\to q)$ 表示后缀路径 $p\to q$ 上所有状态的 $\mathrm{substr}$ 的并。</li>
</ul>
<h4 id="2-3-构建-SAM"><a href="#2-3-构建-SAM" class="headerlink" title="2.3 构建 SAM"></a>2.3 构建 SAM</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lst = <span class="number">1</span>, node = <span class="number">1</span>, fa[N], len[N], sz[N];</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p = ++ node, now = lst; lst = p; sz[p] = <span class="number">1</span>; len[p] = len[now] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (now &amp;&amp; ! ch[now][c]) ch[now][c] = p, now = fa[now];</span><br><span class="line">	<span class="keyword">if</span> (! now) <span class="keyword">return</span> fa[p] = <span class="number">1</span>, <span class="built_in">void</span>();</span><br><span class="line">	<span class="type">int</span> x = ch[now][c];</span><br><span class="line">	<span class="keyword">if</span> (len[x] == len[now] + <span class="number">1</span>) <span class="keyword">return</span> fa[p] = x, <span class="built_in">void</span>();</span><br><span class="line">	<span class="type">int</span> y = ++ node; fa[y] = fa[x]; fa[x] = fa[p] = y; len[y] = len[now] + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(ch[y], ch[x], <span class="built_in">sizeof</span>(ch[y])); </span><br><span class="line">	<span class="keyword">while</span> (now &amp;&amp; ch[now][c] == x) ch[now][c] = y, now = fa[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当字符集 $\Sigma$ 非常大的时候，时空复杂度均无法接受，因此需要使用平衡树维护每个状态的所有转移边，可以用 <code>map</code> 代替。</p>
<h4 id="2-4-时间复杂度证明"><a href="#2-4-时间复杂度证明" class="headerlink" title="2.4 时间复杂度证明"></a>2.4 时间复杂度证明</h4><p>下设字符串 $s$ 长度为 $n$，证明大部分摘自 OI wiki。</p>
<h5 id="2-4-1-状态数上界"><a href="#2-4-1-状态数上界" class="headerlink" title="2.4.1 状态数上界"></a>2.4.1 状态数上界</h5><p>构建后缀自动机的算法本身就已经证明了其 SAM 状态数不超过 $2n-1$：插入 $s_1,s_2$ 时分别产生一个状态，后续插入每个 $s_i$ 时最多产生两个状态，因此当 $n&gt;1$ 时状态数不超过 $2n-2$，形如 $\tt abb\cdots bb$ 的字符串达到上界。当 $n=1$ 时状态数为 $2n-1$。</p>
<h5 id="2-4-2-转移数上界"><a href="#2-4-2-转移数上界" class="headerlink" title="2.4.2 转移数上界"></a>2.4.2 转移数上界</h5><p>称 $\mathrm{len}(p) + 1 = \mathrm{len}(q)$ 的转移 $(p, q)$ 为连续的，显然，从一个非终止状态 $p$ 出发 <strong>有且仅有</strong> 一条连续转移 $(p,q)$，对于 $q$ 也有且仅有一个对应的 $p$。因此，连续转移总数不超过 $2n-2$。对于不连续的转移，找到从根节点 $T\to p$ 的一条连续路径，设其所表示字符串为 $u$；找到从 $q$ 到任意一个终止节点 $f\in F$ 的一条连续路径，设其所表示字符串为 $v$。对于不同的 $p,q$，$s<em>{p,q} = u + c</em>{p,q} + v$ 互不相同：若两个转移 $(p,q)$ 和 $(p’, q’)$ 出现 $s<em>{p, q} = s</em>{p’, q’}$ 的情况，由于不同路径所表示字符串不同，因此 $(p, q)$ 和 $(p’, q’)$ 在同一条路径，这与 $T\to p$ 和 $q\to F$ 连续矛盾。又因为 $s_{p, q}$ 是 $s$ 的真后缀（$s$ 对应的路径转移显然连续），因此不连续的转移数量不超过 $n-1$。这样，我们得到了转移数上界 $3n-3$。</p>
<p>由于最大的状态数量仅在形如 $\tt abb \cdots bb$ 的字符串中达到，此时转移数量小于 $3n - 3$。形如 $\tt abb\cdots bbc$ 的字符串达到了 $3n - 4$ 的上界。</p>
<h4 id="2-5-应用"><a href="#2-5-应用" class="headerlink" title="2.5 应用"></a>2.5 应用</h4><h5 id="2-5-1-求本质不同子串个数"><a href="#2-5-1-求本质不同子串个数" class="headerlink" title="2.5.1 求本质不同子串个数"></a>2.5.1 求本质不同子串个数</h5><p>根据 SAM 的性质，每个子串唯一对应一个状态，因此答案即 $\sum \mathrm{len}(i) - \mathrm{len}(\mathrm{link}(i))$。</p>
<h5 id="2-5-2-字符串匹配"><a href="#2-5-2-字符串匹配" class="headerlink" title="2.5.2 字符串匹配"></a>2.5.2 字符串匹配</h5><p>用文本串 $t$ 在 $s$ 的 SAM 上跑匹配时，我们可以得到对于 $t$ 的每个 <strong>前缀</strong> $t[1, i]$，其作为 $s$ 的子串出现的 <strong>最长后缀 $L_i$</strong>：若当前状态 $p$（即 $t[i - L<em>{i - 1}, i - 1]$ 所表示的状态）不能匹配 $t_i$（即 $\delta(p, t_i)$ 不存在），就跳后缀链接令 $p\gets \mathrm{link}(p)$ 并实时更新 $L_i = \mathrm{len}(p)$ 直到 $p = T$ 或 $\delta(p, t_i)$ 存在，对于后者令 $p\gets \delta(p, t_i)$，$L_i$ 还需再加上 $1$。若能匹配，则直接令 $p\gets \delta(p, t_i)$ 并令 $L_i\gets L</em>{i - 1} + 1$。综合一下，我们得到如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, p = <span class="number">1</span>, L = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(p &gt; <span class="number">1</span> &amp;&amp; !son[p][t[i] - <span class="string">&#x27;a&#x27;</span>]) L = len[p = fa[p]];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(son[p][t[i] - <span class="string">&#x27;a&#x27;</span>]) L = <span class="built_in">min</span>(L + <span class="number">1</span>, len[p = son[p][t[i] - <span class="string">&#x27;a&#x27;</span>]]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-6-广义-SAM"><a href="#2-6-广义-SAM" class="headerlink" title="2.6 广义 SAM"></a>2.6 广义 SAM</h4><p>广义 SAM，GSAM，全称 General Suffix Automaton，相对于普通 SAM 它支持对多个字符串进行处理。它可以看做对 <strong>trie</strong> 建后缀自动机。</p>
<p>一般的写法是每插入一个字符串前将 $las$ 指针置为 $T$，非常方便。一个细节：构建单串 SAM 时，$\delta(las, s_i)$ 一定不存在，但对于多串 SAM 可能存在。这说明当前字符串 $s$ 的 $i$ 前缀是某个已经添加过的字符串的子串。我们需要进行以下特判，否则会出现这种情况：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/discuss/322224">https://www.luogu.com.cn/discuss/322224</a> 。</p>
<ol>
<li>当 $q = \delta(las, s_i)$ 存在，且 $\mathrm{len}(las) + 1 = \mathrm{len}(q)$ 时，令 $las\gets q$ 并直接返回。</li>
<li>当 $q = \delta(las, s_i)$ 存在，且 $\mathrm{len}(las) + 1 \neq \mathrm{len}(q)$ 时，我们会新建节点 $cl$，并进行复制。此时，令 $las\gets cl$ 而非 $cur$。这是因为 $\mathrm{len}(cur) = \mathrm{len}(las) + 1$ 且 $\mathrm{len}(cl) = \mathrm{len}(las) + 1$，又因为 $\mathrm{link}(cur) = cl$，所以这说明 $\mathrm{substr}(cur) = \varnothing$，即 <strong>节点 $cur$ 是空壳，真正的信息在 $cl$ 上面</strong>。为此，我们舍弃掉这个 $cur$，并用 $cl$ 代替它。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> it)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(son[p][it] &amp;&amp; len[son[p][it]] == len[p] + <span class="number">1</span>) <span class="keyword">return</span> son[p][it]; <span class="comment">// 如果节点已经存在，且 len 值相对应，即 (p, son[p][it]) 是连续转移，则直接转移。</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> cur = ++cnt, chk = son[p][it]; len[cur] = len[p] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!son[p][it]) son[p][it] = cur, p = fa[p];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!p) <span class="keyword">return</span> fa[cur] = <span class="number">1</span>, cur;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> q = son[p][it];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len[p] + <span class="number">1</span> == len[q]) <span class="keyword">return</span> fa[cur] = q, cur;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> cl = ++cnt; <span class="built_in">cpy</span>(son[cl], son[q], S);</span><br><span class="line"></span><br><span class="line">	len[cl] = len[p] + <span class="number">1</span>, fa[cl] = fa[q], fa[q] = fa[cur] = cl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(son[p][it] == q) son[p][it] = cl, p = fa[p];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> chk ? cl : cur; <span class="comment">// 如果 len[las][it] 存在，则 cur 是空壳，返回 cl 即可</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述方法本质相当于对匹配串建出 trie 后进行 <strong>dfs</strong> 构建 SAM。部分特殊题目会直接给出 trie 而非模板串，此时模板串长度之和的级别为 $\mathcal{O}(|S| ^ 2)$，因此只能 <strong>bfs</strong> 构建 SAM：设 $P_p$ 表示 trie 树上状态 $p$ 在 SAM 上对应的位置，若 <strong>trie 树</strong> $T$ 上的转移 $q = \delta_T(p, c)$ 存在，其中 $c$ 是 $p\to q$ 所表示字符，那么以 $P_p$ 作为 $las$，插入字符 $c$ 后新的 $las$ 即 $P_q$。此时 <strong>不需要</strong> 像上面一样特判，因为 $\delta(P_p, c)$ 必然不存在，这是由于 bfs 使得 $\mathrm{len}(P_p)$ <strong>单调不降</strong>。模板题 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6139">P6139</a> 代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpy(x, y, s) memcpy(x, y, sizeof(x[0]) * (s))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll n, ans, cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len[N], fa[N], son[N][S];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> it)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> cur = ++cnt; len[cur] = len[p] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!son[p][it]) son[p][it] = cur, p = fa[p];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!p) <span class="keyword">return</span> fa[cur] = <span class="number">1</span>, cur;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> q = son[p][it];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len[p] + <span class="number">1</span> == len[q]) <span class="keyword">return</span> fa[cur] = q, cur;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> cl = ++cnt; <span class="built_in">cpy</span>(son[cl], son[q], S);</span><br><span class="line"></span><br><span class="line">	len[cl] = len[p] + <span class="number">1</span>, fa[cl] = fa[q], fa[q] = fa[cur] = cl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(son[p][it] == q) son[p][it] = cl, p = fa[p];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> node = <span class="number">1</span>, pos[N], tr[N][S];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">char</span> it : s) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!tr[p][it - <span class="string">&#x27;a&#x27;</span>]) tr[p][it - <span class="string">&#x27;a&#x27;</span>] = ++node;</span><br><span class="line"></span><br><span class="line">		p = tr[p][it - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	queue &lt;<span class="type">int</span>&gt; q; q.<span class="built_in">push</span>(pos[<span class="number">1</span>] = <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, p; i &lt; S; i++) <span class="keyword">if</span>(p = tr[t][i])</span><br><span class="line"></span><br><span class="line">			pos[p] = <span class="built_in">ins</span>(pos[t], i), q.<span class="built_in">push</span>(p);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; s, <span class="built_in">ins</span>(s);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cnt; i++) ans += len[i] - len[fa[i]];</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-7-常用技巧与结论"><a href="#2-7-常用技巧与结论" class="headerlink" title="2.7 常用技巧与结论"></a>2.7 常用技巧与结论</h3><h4 id="2-7-1-线段树合并维护-mathrm-endpos-集合"><a href="#2-7-1-线段树合并维护-mathrm-endpos-集合" class="headerlink" title="2.7.1 线段树合并维护 $\mathrm{endpos}$ 集合"></a>2.7.1 线段树合并维护 $\mathrm{endpos}$ 集合</h4><p>对于部分题目，我们需要维护每个状态的 $\mathrm{endpos}$ 集合，以刻画每个子串在字符串中所有出现位置的信息。</p>
<p>为此，我们在 $s[1, i]$ 对应状态的 $\mathrm{endpos}$ 集合里插入位置 $i$，再根据 $\mathrm{endpos}$ 集合构造出来的树本质上就是后缀链接树这一事实，在 $\mathrm{link}$ 树上进行 <strong>线段树合并</strong> 即可得到每个状态的 $\mathrm{endpos}$ 集合。这是一个非常有用且常见的技巧。</p>
<p>注意，线段树合并时会破坏原有线段树的结构，因此若需要在线段树合并后保留每个状态的 $\rm endpos$ 集合对应的线段树的结构，需要在线段树合并时 <strong>新建节点</strong>。即 <strong>可持久化线段树合并</strong>。SAM 相关问题的线段树合并通常均需要可持久化。</p>
<p>特别的，如果仅为了得到 $\mathrm{endpos}$ 集合大小，那么只需求出每个状态在 $\mathrm{link}$ 树上的子树有多少个表示 $s$ 的前缀的状态。前缀状态即所有曾作为 $cur$ 的节点。对此，有两种解决方法：直接建图 dfs，以及 ——</p>
<h4 id="2-7-2-桶排确定-dfs-顺序"><a href="#2-7-2-桶排确定-dfs-顺序" class="headerlink" title="2.7.2 桶排确定 dfs 顺序"></a>2.7.2 桶排确定 dfs 顺序</h4><p>显然后缀链接树上父亲的 $\mathrm{len}$ 值一定小于儿子，但千万不能认为编号小的节点 $\mathrm{len}$ 值也小。因此，对所有节点按照 $\mathrm{len}$ 值从大到小进行桶排序，然后按顺序合并每个状态及其父亲是正确的，并且常数比建图 + dfs 小不少，代码见例题 <em>I.</em></p>
<h4 id="2-7-3-快速定位子串"><a href="#2-7-3-快速定位子串" class="headerlink" title="2.7.3 快速定位子串"></a>2.7.3 快速定位子串</h4><p>给定区间 $[l, r]$，求 $s<em>{l, r}$ 在 SAM 上的对应状态：在构建 SAM 时容易预处理 $s</em>{1, i}$ 所表示的状态 $pos_i$。从 $pos_r$ 开始在 $\mathrm{link}$ 树上倍增找到最浅的，$\rm len$ 值 $\geq r - l + 1$ 的状态 $p$​ 即为所求。</p>
<h4 id="2-7-4-其它结论"><a href="#2-7-4-其它结论" class="headerlink" title="2.7.4 其它结论"></a>2.7.4 其它结论</h4><ol>
<li>在 $\rm link$ 树上，若 $p$ 是 $q$ 的祖先，则 $\mathrm{substr}(p)$ 中所有字符串在 $\mathrm{longest}(q)$（下记为 $s$）中出现次数与出现位置相同。具体证明见 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/CF700E">CF700E 题解区</a>。</li>
</ol>
<h3 id="2-8-注意点总结"><a href="#2-8-注意点总结" class="headerlink" title="2.8 注意点总结"></a>2.8 注意点总结</h3><ul>
<li>做题时不要忘记初始化 $las$ 和 $cnt$。</li>
<li>第二个 <code>while</code> 不要写成 <code>son[p][it] = cur</code>，应为 <code>son[p][it] = cl</code>。</li>
<li>SAM <strong>开两倍空间</strong>。</li>
<li>对于多串 SAM，如果每插入一个新字符串时令 $las\gets T$，且插入字符时不特判 $\delta(las, s_i)$ 是否存在，会导致出现空状态，从而父节点的 $\mathrm{len}$ 值 <strong>不一定严格小于</strong> 子节点，使得桶排失效。对此要格外注意。</li>
</ul>
<h2 id="后缀平衡树"><a href="#后缀平衡树" class="headerlink" title="后缀平衡树"></a>后缀平衡树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> LIM = <span class="number">1e16</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[MAXN], S[MAXN];</span><br><span class="line"><span class="type">double</span> key[MAXN];</span><br><span class="line"><span class="type">int</span> ch[MAXN][<span class="number">2</span>], siz[MAXN];</span><br><span class="line"><span class="type">int</span> tr[MAXN], rt, tcnt;</span><br><span class="line"><span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Decode</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> mask)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		mask = (mask * <span class="number">131</span> + i) % len;</span><br><span class="line">		<span class="type">char</span> t = s[i];</span><br><span class="line">		s[i] = s[mask];</span><br><span class="line">		s[mask] = t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	siz[now] = <span class="number">1</span> + siz[ch[now][<span class="number">0</span>]] + siz[ch[now][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bad</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.0</span> * siz[ch[now][<span class="number">0</span>]] &gt; <span class="number">0.7</span> * siz[now] || <span class="number">1.0</span> * siz[ch[now][<span class="number">1</span>]] &gt; <span class="number">0.7</span> * siz[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!now) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">DFS</span>(ch[now][<span class="number">0</span>]);</span><br><span class="line">	tr[++tcnt] = now;</span><br><span class="line">	<span class="built_in">DFS</span>(ch[now][<span class="number">1</span>]);</span><br><span class="line">	ch[now][<span class="number">0</span>] = ch[now][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rebuild</span><span class="params">(<span class="type">int</span> &amp;now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">double</span> lv, <span class="type">double</span> rv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="type">double</span> midv = (lv + rv) / <span class="number">2</span>;</span><br><span class="line">	now = tr[mid];</span><br><span class="line">	key[now] = midv;</span><br><span class="line">	<span class="built_in">Rebuild</span>(ch[now][<span class="number">0</span>], l, mid - <span class="number">1</span>, lv, midv);</span><br><span class="line">	<span class="built_in">Rebuild</span>(ch[now][<span class="number">1</span>], mid + <span class="number">1</span>, r, midv, rv);</span><br><span class="line">	<span class="built_in">Update</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Maintain</span><span class="params">(<span class="type">int</span> &amp;now, <span class="type">double</span> lv, <span class="type">double</span> rv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">Bad</span>(now)) &#123;</span><br><span class="line">		tcnt = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">DFS</span>(now);</span><br><span class="line">		<span class="built_in">Rebuild</span>(now, <span class="number">1</span>, tcnt, lv, rv);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Comp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> S[x] &lt; S[y] || (S[x] == S[y] &amp;&amp; key[x - <span class="number">1</span>] &lt; key[y - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> &amp;now, <span class="type">int</span> idx, <span class="type">double</span> lv, <span class="type">double</span> rv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!now) &#123;</span><br><span class="line">		now = idx;</span><br><span class="line">		siz[now] = <span class="number">1</span>;</span><br><span class="line">		key[now] = (lv + rv) / <span class="number">2</span>;</span><br><span class="line">		ch[now][<span class="number">0</span>] = ch[now][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">Comp</span>(idx, now)) <span class="built_in">Insert</span>(ch[now][<span class="number">0</span>], idx, lv, key[now]);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">Insert</span>(ch[now][<span class="number">1</span>], idx, key[now], rv);</span><br><span class="line">	<span class="built_in">Update</span>(now);</span><br><span class="line">	<span class="built_in">Maintain</span>(now, lv, rv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(<span class="type">int</span> &amp;now, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (now == idx) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!ch[now][<span class="number">0</span>] || !ch[now][<span class="number">1</span>]) &#123;</span><br><span class="line">			now = (ch[now][<span class="number">0</span>] | ch[now][<span class="number">1</span>]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> cur = ch[now][<span class="number">0</span>], las = now;</span><br><span class="line">			<span class="keyword">while</span> (ch[cur][<span class="number">1</span>]) &#123;</span><br><span class="line">				las = cur;</span><br><span class="line">				siz[las]--;</span><br><span class="line">				cur = ch[cur][<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (las == now) &#123;</span><br><span class="line">				ch[cur][<span class="number">1</span>] = ch[now][<span class="number">1</span>];</span><br><span class="line">				now = cur;</span><br><span class="line">				<span class="built_in">Update</span>(now);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ch[cur][<span class="number">0</span>] = ch[now][<span class="number">0</span>];</span><br><span class="line">				ch[cur][<span class="number">1</span>] = ch[now][<span class="number">1</span>];</span><br><span class="line">				ch[las][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">				now = cur;</span><br><span class="line">				<span class="built_in">Update</span>(now);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">Comp</span>(idx, now)) <span class="built_in">Remove</span>(ch[now][<span class="number">0</span>], idx);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">Remove</span>(ch[now][<span class="number">1</span>], idx);</span><br><span class="line">	<span class="built_in">Update</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Com</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; str[p]; p++, now = (now ? now - <span class="number">1</span> : <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (str[p] &lt; S[now]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (str[p] &gt; S[now]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!now) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ls = siz[ch[now][<span class="number">0</span>]];</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">Com</span>(now)) <span class="keyword">return</span> <span class="built_in">Query</span>(ch[now][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Query</span>(ch[now][<span class="number">1</span>]) + ls + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, S + <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> mask = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">	n = <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">Insert</span>(rt, i, <span class="number">0</span>, LIM);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">		<span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">Decode</span>(str + <span class="number">1</span>, mask);</span><br><span class="line">			<span class="type">int</span> len = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len; j++) &#123;</span><br><span class="line">				S[n + j] = str[j];</span><br><span class="line">				<span class="built_in">Insert</span>(rt, n + j, <span class="number">0</span>, LIM);</span><br><span class="line">			&#125;</span><br><span class="line">			n += len;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">Decode</span>(str + <span class="number">1</span>, mask);</span><br><span class="line">			<span class="type">int</span> len = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">reverse</span>(str + <span class="number">1</span>, str + len + <span class="number">1</span>);</span><br><span class="line">			str[len + <span class="number">1</span>] = <span class="string">&#x27;Z&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">			str[len + <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			ans = <span class="built_in">Query</span>(rt);</span><br><span class="line">			str[len]--;</span><br><span class="line">			ans -= <span class="built_in">Query</span>(rt);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">			mask ^= ans;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> k;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt; n - k; j--) <span class="built_in">Remove</span>(rt, j);</span><br><span class="line">			n -= k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h2><h3 id="manacher"><a href="#manacher" class="headerlink" title="manacher"></a>manacher</h3><p>来自洛谷模板<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std :: cin;</span><br><span class="line"><span class="keyword">using</span> std :: cout;</span><br><span class="line"><span class="keyword">using</span> std :: cerr;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lep(i, l, r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for (int i = (l); i &gt;= (r); i --)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N], t[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin &gt;&gt; (s + <span class="number">1</span>); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	t[++ len] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">1</span>, n)</span><br><span class="line">		t[++ len] = s[i], t[++ len] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">	t[++ len] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">	<span class="type">int</span> mx = <span class="number">0</span>, pos = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">lep</span> (i, <span class="number">2</span>, len - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; mx) p[i] = std :: <span class="built_in">min</span>(p[pos * <span class="number">2</span> - i], mx - i + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> p[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) ++ p[i];</span><br><span class="line">		res = std :: <span class="built_in">max</span>(res, p[i] - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (i + p[i] - <span class="number">1</span> &gt; mx) mx = i + p[i] - <span class="number">1</span>, pos = i;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="PAM"><a href="#PAM" class="headerlink" title="PAM"></a>PAM</h3><p>来自洛谷模板， 求每个位置结尾的回文子串个数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std :: cin;</span><br><span class="line"><span class="keyword">using</span> std :: cout;</span><br><span class="line"><span class="keyword">using</span> std :: cerr;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lep(i, l, r) for (int i = (l); i &lt;= (r); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for (int i = (l); i &gt;= (r); i --)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>], len[N], node, fa[N], cnt[N], las;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> u = las;</span><br><span class="line">	<span class="keyword">while</span> (s[id - len[u] - <span class="number">1</span>] != s[id]) u = fa[u];</span><br><span class="line">	<span class="keyword">if</span> (! ch[u][c]) &#123;</span><br><span class="line">		<span class="type">int</span> p = ++ node; <span class="type">int</span> v = fa[u]; len[p] = len[u] + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span> (s[id - len[v] - <span class="number">1</span>] != s[id]) v = fa[v];</span><br><span class="line">		fa[p] = ch[v][c]; ch[u][c] = p;</span><br><span class="line">		cnt[p] = cnt[fa[p]] + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	las = ch[u][c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin &gt;&gt; (s + <span class="number">1</span>); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	len[<span class="number">1</span>] = <span class="number">-1</span>; node = fa[<span class="number">0</span>] = fa[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">		<span class="built_in">ins</span>(i, s[i] - <span class="string">&#x27;a&#x27;</span>), s[i + <span class="number">1</span>] = (s[i + <span class="number">1</span>] - <span class="number">97</span> + cnt[las]) % <span class="number">26</span> + <span class="number">97</span>, cout &lt;&lt; cnt[las] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="exkmp"><a href="#exkmp" class="headerlink" title="exkmp"></a>exkmp</h2><p>给定两个字符串 $a,b$，你要求出两个数组：</p>
<ul>
<li>$b$ 的 $z$ 函数数组 $z$，即 $b$ 与 $b$ 的每一个后缀的 LCP 长度。</li>
<li>$b$ 与 $a$ 的每一个后缀的 LCP 长度数组 $p$。</li>
</ul>
<p>对于一个长度为 $n$ 的数组 $a$，设其权值为 $\operatorname{xor}_{i=1}^n i \times (a_i + 1)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std :: cin;</span><br><span class="line"><span class="keyword">using</span> std :: cout;</span><br><span class="line"><span class="keyword">using</span> std :: cerr;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> s[N], _s[N], <span class="type">_t</span>[N];</span><br><span class="line"><span class="type">int</span> z[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std :: ios :: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; (_s + <span class="number">1</span>);</span><br><span class="line">	n = <span class="built_in">strlen</span>(_s + <span class="number">1</span>);</span><br><span class="line">	cin &gt;&gt; (<span class="type">_t</span> + <span class="number">1</span>);</span><br><span class="line">	m = <span class="built_in">strlen</span>(<span class="type">_t</span> + <span class="number">1</span>);</span><br><span class="line">	std :: <span class="built_in">swap</span>(n, m);</span><br><span class="line">	std :: <span class="built_in">swap</span>(_s, <span class="type">_t</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) s[i] = _s[i];</span><br><span class="line">	s[n + <span class="number">1</span>] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) s[i + n + <span class="number">1</span>] = <span class="type">_t</span>[i];</span><br><span class="line">	z[<span class="number">1</span>] = n;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m + n + <span class="number">1</span>; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i &lt;= r) z[i] = std :: <span class="built_in">min</span>(z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> z[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(s[z[i] + <span class="number">1</span>] == s[i + z[i]]) z[i] ++;</span><br><span class="line">		<span class="keyword">if</span>(i + z[i] - <span class="number">1</span> &gt; r) r = i + z[i] - <span class="number">1</span>, l = i;</span><br><span class="line">	&#125;</span><br><span class="line">	i64 ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) ans ^= <span class="number">1ll</span> * i * (z[i] + <span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl; ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) ans ^= <span class="number">1ll</span> * i * (z[i + n + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><p>记录一些东西。</p>
<h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><p>采用求一次上凸包然后求一次下凸包在拼起来实现。<br>$type = 0$ 是下凸包， 反之是上凸包。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">graham</span><span class="params">(vector&lt;vec2&gt; &amp;vec, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vec.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; cerr &lt;&lt; <span class="string">&quot;Hull is empty !\n&quot;</span> &lt;&lt; endl; <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()); </span><br><span class="line">	vector&lt;vec2&gt; rec; rec.<span class="built_in">pb</span>(* vec.<span class="built_in">begin</span>()); <span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(type == <span class="number">0</span>) <span class="keyword">while</span>(sz &gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">le</span>(<span class="built_in">cross</span>(rec[sz - <span class="number">1</span>], rec[sz], vec[i]), <span class="number">0</span>)) rec.<span class="built_in">pop_back</span>(), sz --;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">while</span>(sz &gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">ge</span>(<span class="built_in">cross</span>(rec[sz - <span class="number">1</span>], rec[sz], vec[i]), <span class="number">0</span>)) rec.<span class="built_in">pop_back</span>(), sz --;</span><br><span class="line">		rec.<span class="built_in">push_back</span>(vec[i]); sz ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(vec, rec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">graham_full</span><span class="params">(vector&lt;vec2&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">	vector&lt;vec2&gt; v1 = vec, v2 = vec;</span><br><span class="line">	<span class="built_in">graham</span>(v1, <span class="number">0</span>); <span class="built_in">graham</span>(v2, <span class="number">1</span>);</span><br><span class="line">	v1.<span class="built_in">pop_back</span>(); <span class="keyword">for</span>(<span class="type">int</span> i = v2.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --) v1.<span class="built_in">push_back</span>(v2[i]); <span class="built_in">swap</span>(vec, v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="凸包直径"><a href="#凸包直径" class="headerlink" title="凸包直径"></a>凸包直径</h2><p>采用旋转卡壳实现。每次就看移动指针以后面积会不会变大就好了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">convDiameter</span><span class="params">(vector&lt;vec2&gt; vec)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vec.<span class="built_in">size</span>() == <span class="number">2</span>) &#123; <span class="keyword">return</span> (vec[<span class="number">0</span>] - vec[<span class="number">1</span>]).<span class="built_in">norm2</span>(); &#125;</span><br><span class="line">	vec.<span class="built_in">pb</span>(vec[<span class="number">0</span>]);</span><br><span class="line">	<span class="type">int</span> j = <span class="number">2</span>, n = vec.<span class="built_in">size</span>() - <span class="number">1</span>; </span><br><span class="line">	<span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>() - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">abs</span>(<span class="built_in">cross</span>(vec[i], vec[i + <span class="number">1</span>], vec[j])) &lt; <span class="built_in">abs</span>(<span class="built_in">cross</span>(vec[i], vec[i + <span class="number">1</span>], vec[j + <span class="number">1</span>]))) j = (j + <span class="number">1</span>) % n;</span><br><span class="line">		<span class="built_in">Max</span>(res, <span class="built_in">max</span>((vec[i] - vec[j]).<span class="built_in">norm2</span>(), (vec[i + <span class="number">1</span>] - vec[j]).<span class="built_in">norm2</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="直线交点"><a href="#直线交点" class="headerlink" title="直线交点"></a>直线交点</h2><p>用三角形面积然后定比分点实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> vec2 <span class="title">intersection</span><span class="params">(<span class="type">const</span> line &amp;l1, <span class="type">const</span> line &amp;l2)</span> </span>&#123;</span><br><span class="line">	<span class="type">double</span> ls = <span class="built_in">cross</span>(l1.p1, l1.p2, l2.p1);</span><br><span class="line">	<span class="type">double</span> rs = <span class="built_in">cross</span>(l1.p1, l1.p2, l2.p2);</span><br><span class="line">	<span class="keyword">return</span> l2.p1 + (l2.p2 - l2.p1) * ls / (ls - rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="半平面交"><a href="#半平面交" class="headerlink" title="半平面交"></a>半平面交</h2><p>把直线按照极角排序，平行的保留内侧在前， 注意排序判断是否在内侧的时候使用严格大于，从头开始加， 如果队头或者队尾的两条直线交点在当前直线右侧则弹出， 如果最后队尾两条直线交点在队头直线右侧则弹出队尾。<br>直线是逆时针存的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">HPI</span><span class="params">(vector&lt;line&gt; &amp;lv)</span> </span>&#123;</span><br><span class="line">	vector&lt;pair&lt;line, <span class="type">double</span>&gt; &gt; <span class="built_in">sorted</span>(lv.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lv.<span class="built_in">size</span>(); i ++) sorted[i].fi = lv[i], sorted[i].se = <span class="built_in">atan2</span>(lv[i].<span class="built_in">direct</span>().y, lv[i].<span class="built_in">direct</span>().x);</span><br><span class="line">	<span class="built_in">sort</span>(sorted.<span class="built_in">begin</span>(), sorted.<span class="built_in">end</span>(), [] (<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">eq</span>(a.se, b.se)) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">lt</span>(<span class="built_in">cross</span>(a.fi.p1, a.fi.p2, b.fi.p2), <span class="number">0</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> a.se &lt; b.se;</span><br><span class="line">	&#125; );</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lv.<span class="built_in">size</span>(); i ++) lv[i] = sorted[i].fi; </span><br><span class="line">	deque&lt;line&gt; q;</span><br><span class="line">	q.<span class="built_in">push_back</span>(lv[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; lv.<span class="built_in">size</span>(); i ++) <span class="keyword">if</span>(! <span class="built_in">parallel</span>(lv[i], lv[i - <span class="number">1</span>])) &#123;</span><br><span class="line">		<span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			vec2 p = <span class="built_in">intersection</span>(* --q.<span class="built_in">end</span>(), * -- -- q.<span class="built_in">end</span>());</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">lt</span>(<span class="built_in">cross</span>(lv[i].p1, lv[i].p2, p), <span class="number">0</span>)) q.<span class="built_in">pop_back</span>();</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			vec2 p = <span class="built_in">intersection</span>(* q.<span class="built_in">begin</span>(), * ++ q.<span class="built_in">begin</span>());</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">lt</span>(<span class="built_in">cross</span>(lv[i].p1, lv[i].p2, p), <span class="number">0</span>)) q.<span class="built_in">pop_front</span>();</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		q.<span class="built_in">push_back</span>(lv[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		vec2 p = <span class="built_in">intersection</span>(* --q.<span class="built_in">end</span>(), * -- -- q.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">lt</span>(<span class="built_in">cross</span>(q.<span class="built_in">begin</span>() -&gt; p1, q.<span class="built_in">begin</span>() -&gt; p2, p), <span class="number">0</span>)) q.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	lv = <span class="built_in">vector</span>&lt;line&gt; (q.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q.<span class="built_in">size</span>(); i ++) lv[i] = q[i]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闵可夫斯基和"><a href="#闵可夫斯基和" class="headerlink" title="闵可夫斯基和"></a>闵可夫斯基和</h2><p>要求 $v1, v2$ 是凸包且极角排序完毕。<br>把所有边拿下来归并即可。注意最后弹出一个初始点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> vector&lt;vec2&gt; <span class="title">Minkowski</span><span class="params">(vector&lt;vec2&gt; v1, vector&lt;vec2&gt; v2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// v1, v2 is sorted</span></span><br><span class="line">	<span class="function">vector&lt;vec2&gt; <span class="title">s1</span><span class="params">(v1.size())</span>, <span class="title">s2</span><span class="params">(v2.size())</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s1.<span class="built_in">size</span>(); i ++) s1[i - <span class="number">1</span>] = v1[i] - v1[i - <span class="number">1</span>]; s1[s1.<span class="built_in">size</span>() - <span class="number">1</span>] = v1[<span class="number">0</span>] - v1[s1.<span class="built_in">size</span>() - <span class="number">1</span>]; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s2.<span class="built_in">size</span>(); i ++) s2[i - <span class="number">1</span>] = v2[i] - v2[i - <span class="number">1</span>]; s2[s2.<span class="built_in">size</span>() - <span class="number">1</span>] = v2[<span class="number">0</span>] - v2[s2.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">	<span class="function">vector&lt;vec2&gt; <span class="title">hull</span><span class="params">(v1.size() + v2.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">	hull[cnt ++] = v1[<span class="number">0</span>] + v2[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">while</span>(p1 &lt; s1.<span class="built_in">size</span>() &amp;&amp; p2 &lt; s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		hull[cnt] = hull[cnt - <span class="number">1</span>] + (<span class="built_in">ge</span>(s1[p1] ^ s2[p2], <span class="number">0</span>) ? s1[p1 ++] : s2[p2 ++]);</span><br><span class="line">		cnt ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p1 &lt; s1.<span class="built_in">size</span>()) hull[cnt] = hull[cnt - <span class="number">1</span>] + s1[p1 ++], cnt ++;</span><br><span class="line">	<span class="keyword">while</span>(p2 &lt; s2.<span class="built_in">size</span>()) hull[cnt] = hull[cnt - <span class="number">1</span>] + s2[p2 ++], cnt ++;</span><br><span class="line">	hull.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> hull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="辛普森积分"><a href="#辛普森积分" class="headerlink" title="辛普森积分"></a>辛普森积分</h2><p>积分公式 ： $(R - L) \times (f(L) + f(R) + 4f(M)) \times \frac{1}{6}$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">db <span class="title">calc</span><span class="params">(db L, db R)</span> </span>&#123;</span><br><span class="line">	db mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">f</span>(L) + <span class="built_in">f</span>(R) + <span class="number">4</span> * <span class="built_in">f</span>(mid)) / <span class="number">6</span> * (R - L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">simpson</span><span class="params">(db L, db R, <span class="type">int</span> dep)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span>(L - R) &lt;= <span class="number">1e-9</span> &amp;&amp; dep &gt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	db mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="built_in">calc</span>(L, R) - <span class="built_in">calc</span>(L, mid) - <span class="built_in">calc</span>(mid, R)) &lt;= <span class="number">1e-9</span> &amp;&amp; dep &gt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="built_in">calc</span>(L, R);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">simpson</span>(L, mid, dep + <span class="number">1</span>) + <span class="built_in">simpson</span>(mid, R, dep + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="圆圆交点"><a href="#圆圆交点" class="headerlink" title="圆圆交点"></a>圆圆交点</h2><p>把一个圆放到圆心， 另外一个旋转到水平， 解方程以后转回去。</p>
<h2 id="平面图转对偶图"><a href="#平面图转对偶图" class="headerlink" title="平面图转对偶图"></a>平面图转对偶图</h2><p>使用最小左转法。把所有边拆为两条有向边， 然后在每个点上极角排序， 每次一个边在终点找反向边然后看极角序在反向边前面的一条边记为 $nxt$ ， 然后跳 $nxt$ 编号， 根据面积正负判断是否是无界域。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">sort</span>(e[i].<span class="built_in">begin</span>(), e[i].<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= tot; i ++) &#123;</span><br><span class="line">		<span class="type">int</span> y = E[i].y;</span><br><span class="line">		<span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(e[y].<span class="built_in">begin</span>(), e[y].<span class="built_in">end</span>(), E[i ^ <span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span>(it == e[y].<span class="built_in">begin</span>()) it = -- e[y].<span class="built_in">end</span>(); <span class="keyword">else</span> -- it;</span><br><span class="line">		nxt[i] = it -&gt; id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= tot; i ++) <span class="keyword">if</span>(! pos[i]) &#123;</span><br><span class="line">		pos[i] = pos[nxt[i]] = ++ cnt;</span><br><span class="line">		<span class="type">int</span> u = E[i].x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = nxt[i]; E[j].y != E[i].x; j = nxt[j], pos[j] = cnt) </span><br><span class="line">			s[cnt] += ( (nod[E[j].x] - nod[u]) ^ (nod[E[j].y] - nod[u]) );</span><br><span class="line">		<span class="keyword">if</span>(s[cnt] &lt; <span class="number">1e-9</span>) rt = cnt;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= tot; i ++) &#123;</span><br><span class="line">		hv[pos[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">		g[pos[i]].<span class="built_in">pb</span>( &#123;E[i].w, pos[i ^ <span class="number">1</span>]&#125; ) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="常用操作全家桶"><a href="#常用操作全家桶" class="headerlink" title="常用操作全家桶"></a>常用操作全家桶</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">circle</span>&#123;</span><br><span class="line">  point C;</span><br><span class="line">  <span class="type">double</span> r;</span><br><span class="line">  <span class="built_in">circle</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">circle</span>(point C, <span class="type">double</span> r): <span class="built_in">C</span>(C), <span class="built_in">r</span>(r)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">pair&lt;point, point&gt; <span class="title">line_circle_intersection</span><span class="params">(line L, circle C)</span></span>&#123;</span><br><span class="line">  point P = <span class="built_in">projection</span>(C.C, L);</span><br><span class="line">  <span class="type">double</span> d = <span class="built_in">point_line_distance</span>(C.C, L);</span><br><span class="line">  <span class="type">double</span> h = <span class="built_in">sqrt</span>(C.r * C.r - d * d);</span><br><span class="line">  point A = P + <span class="built_in">vec</span>(L) / <span class="built_in">abs</span>(<span class="built_in">vec</span>(L)) * h;</span><br><span class="line">  point B = P - <span class="built_in">vec</span>(L) / <span class="built_in">abs</span>(<span class="built_in">vec</span>(L)) * h;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make_pair</span>(A, B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pair&lt;point, point&gt; <span class="title">circle_intersection</span><span class="params">(circle C1, circle C2)</span></span>&#123;</span><br><span class="line">  <span class="type">double</span> d = <span class="built_in">dist</span>(C1.C, C2.C);</span><br><span class="line">  <span class="type">double</span> m = (C1.r * C1.r - C2.r * C2.r + d * d) / (d * <span class="number">2</span>);</span><br><span class="line">  point M = C1.C + (C2.C - C1.C) / d * m;</span><br><span class="line">  <span class="type">double</span> h = <span class="built_in">sqrt</span>(C1.r * C1.r - m * m);</span><br><span class="line">  point H = <span class="built_in">rotate90</span>(C2.C - C1.C) / d * h;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make_pair</span>(M - H, M + H);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pair&lt;point, point&gt; <span class="title">circle_tangent</span><span class="params">(point P, circle C)</span></span>&#123;</span><br><span class="line">  <span class="type">double</span> d = <span class="built_in">dist</span>(P, C.C);</span><br><span class="line">  <span class="type">double</span> r = <span class="built_in">sqrt</span>(d * d - C.r * C.r);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">circle_intersection</span>(C, <span class="built_in">circle</span>(P, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;line&gt; <span class="title">common_tangent</span><span class="params">(circle C1, circle C2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (C1.r &lt; C2.r)&#123;</span><br><span class="line">    <span class="built_in">swap</span>(C1, C2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">double</span> d = <span class="built_in">dist</span>(C1.C, C2.C);</span><br><span class="line">  vector&lt;line&gt; L;</span><br><span class="line">  <span class="keyword">if</span> (C1.r - C2.r &lt;= d + eps)&#123;</span><br><span class="line">    <span class="keyword">if</span> (C1.r - C2.r &lt;= eps)&#123;</span><br><span class="line">      point D = <span class="built_in">rotate90</span>(C2.C - C1.C) / d * C1.r;</span><br><span class="line">      L.<span class="built_in">push_back</span>(<span class="built_in">line</span>(C1.C + D, C2.C + D));</span><br><span class="line">      L.<span class="built_in">push_back</span>(<span class="built_in">line</span>(C1.C - D, C2.C - D));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">double</span> m = (C1.r - C2.r) * (C1.r - C2.r) / d;</span><br><span class="line">      point M = C1.C + (C2.C - C1.C) / d * m;</span><br><span class="line">      <span class="type">double</span> h = <span class="built_in">sqrt</span>((C1.r - C2.r) * (C1.r - C2.r) - m * m);</span><br><span class="line">      point H1 = M + <span class="built_in">rotate90</span>(C2.C - C1.C) / d * h;</span><br><span class="line">      point D1 = (H1 - C1.C) / <span class="built_in">dist</span>(H1, C1.C) * C2.r;</span><br><span class="line">      L.<span class="built_in">push_back</span>(<span class="built_in">line</span>(H1 + D1, C2.C + D1));</span><br><span class="line">      point H2 = M - <span class="built_in">rotate90</span>(C2.C - C1.C) / d * h;</span><br><span class="line">      point D2 = (H2 - C1.C) / <span class="built_in">dist</span>(H2, C1.C) * C2.r;</span><br><span class="line">      L.<span class="built_in">push_back</span>(<span class="built_in">line</span>(H2 + D2, C2.C + D2));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (C1.r + C2.r &lt;= d + eps)&#123;</span><br><span class="line">    <span class="type">double</span> m = (C1.r + C2.r) * (C1.r + C2.r) / d;</span><br><span class="line">    point M = C1.C + (C2.C - C1.C) / d * m;</span><br><span class="line">    <span class="type">double</span> h = <span class="built_in">sqrt</span>((C1.r + C2.r) * (C1.r + C2.r) - m * m);</span><br><span class="line">    point H1 = M + <span class="built_in">rotate90</span>(C2.C - C1.C) / d * h;</span><br><span class="line">    point D1 = (H1 - C1.C) / <span class="built_in">dist</span>(H1, C1.C) * C2.r;</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="built_in">line</span>(H1 - D1, C2.C - D1));</span><br><span class="line">    point H2 = M - <span class="built_in">rotate90</span>(C2.C - C1.C) / d * h;</span><br><span class="line">    point D2 = (H2 - C1.C) / <span class="built_in">dist</span>(H2, C1.C) * C2.r;</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="built_in">line</span>(H2 - D2, C2.C - D2));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">  <span class="type">double</span> x, y;</span><br><span class="line">  <span class="built_in">point</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">point</span>(<span class="type">double</span> x, <span class="type">double</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  point <span class="keyword">operator</span> +(point P)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">point</span>(x + P.x, y + P.y);</span><br><span class="line">  &#125;</span><br><span class="line">  point <span class="keyword">operator</span> -(point P)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">point</span>(x - P.x, y - P.y);</span><br><span class="line">  &#125;</span><br><span class="line">  point <span class="keyword">operator</span> *(<span class="type">double</span> k)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">point</span>(x * k, y * k);</span><br><span class="line">  &#125;</span><br><span class="line">  point <span class="keyword">operator</span> /(<span class="type">double</span> k)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">point</span>(x / k, y / k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">point <span class="title">rotate90</span><span class="params">(point P)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">point</span>(-P.y, P.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">point <span class="title">rotate</span><span class="params">(point P, <span class="type">double</span> t)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">point</span>(P.x * <span class="built_in">cos</span>(t) - P.y * <span class="built_in">sin</span>(t), P.x * <span class="built_in">sin</span>(t) + P.y * <span class="built_in">cos</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">abs</span><span class="params">(point P)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>(P.x * P.x + P.y * P.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dist</span><span class="params">(point P, point Q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">abs</span>(Q - P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dot</span><span class="params">(point P, point Q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> P.x * Q.x + P.y * Q.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cross</span><span class="params">(point P, point Q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> P.x * Q.y - P.y * Q.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">  point A, B;</span><br><span class="line">  <span class="built_in">line</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">line</span>(point A, point B): <span class="built_in">A</span>(A), <span class="built_in">B</span>(B)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">point <span class="title">vec</span><span class="params">(line L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> L.B - L.A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">point_on_segment</span><span class="params">(point P, line L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dot</span>(P - L.A, <span class="built_in">vec</span>(L)) &gt; -eps &amp;&amp; <span class="built_in">dot</span>(P - L.B, <span class="built_in">vec</span>(L)) &lt; eps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">point <span class="title">projection</span><span class="params">(point P, line L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> L.A + <span class="built_in">vec</span>(L) / <span class="built_in">abs</span>(<span class="built_in">vec</span>(L)) * <span class="built_in">dot</span>(P - L.A, <span class="built_in">vec</span>(L)) / <span class="built_in">abs</span>(<span class="built_in">vec</span>(L));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">point <span class="title">reflection</span><span class="params">(point P, line L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">projection</span>(P, L) * <span class="number">2</span> - P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">point_line_distance</span><span class="params">(point P, line L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">cross</span>(P - L.A, <span class="built_in">vec</span>(L))) / <span class="built_in">abs</span>(<span class="built_in">vec</span>(L));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">point_segment_distance</span><span class="params">(point P, line L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">dot</span>(P - L.A, <span class="built_in">vec</span>(L)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dist</span>(P, L.A);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">dot</span>(P - L.B, <span class="built_in">vec</span>(L)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dist</span>(P, L.B);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">point_line_distance</span>(P, L);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_parallel</span><span class="params">(line L1, line L2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">cross</span>(<span class="built_in">vec</span>(L1), <span class="built_in">vec</span>(L2))) &lt; eps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">point <span class="title">line_intersection</span><span class="params">(line L1, line L2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> L1.A + <span class="built_in">vec</span>(L1) * <span class="built_in">cross</span>(L2.A - L1.A, <span class="built_in">vec</span>(L2)) / <span class="built_in">cross</span>(<span class="built_in">vec</span>(L1), <span class="built_in">vec</span>(L2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">segment_intersect</span><span class="params">(line L1, line L2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">cross</span>(L1.A - L2.A, <span class="built_in">vec</span>(L2)) * <span class="built_in">cross</span>(L1.B - L2.A, <span class="built_in">vec</span>(L2)) &lt; eps &amp;&amp; <span class="built_in">cross</span>(L2.A - L1.A, <span class="built_in">vec</span>(L1)) * <span class="built_in">cross</span>(L2.B - L1.A, <span class="built_in">vec</span>(L1)) &lt; eps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">segment_distance</span><span class="params">(line L1, line L2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">segment_intersect</span>(L1, L2))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">double</span> ans = INF;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">point_segment_distance</span>(L1.A, L2));</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">point_segment_distance</span>(L1.B, L2));</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">point_segment_distance</span>(L2.A, L1));</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">point_segment_distance</span>(L2.B, L1));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="杂技"><a href="#杂技" class="headerlink" title="杂技"></a>杂技</h1><h2 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(R <span class="type">int</span> i=<span class="number">62</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">if</span>(x&amp;(<span class="number">1LL</span>&lt;&lt;i)) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!p[i]) &#123; p[i]=x,cnt++; <span class="keyword">break</span>; &#125;</span><br><span class="line">			<span class="keyword">else</span> x^=p[i];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询一个元素是否可以被异或出来"><a href="#查询一个元素是否可以被异或出来" class="headerlink" title="查询一个元素是否可以被异或出来"></a>查询一个元素是否可以被异或出来</h3><p>从高到低，如果这一位为$1$就异或上这一位的线性基，把$1$消去，根据性质一，如果最后得到了$0$，那这个数就可以表示出来。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(R <span class="type">int</span> i=<span class="number">62</span>;i&gt;=<span class="number">0</span>;i--) </span><br><span class="line">		<span class="keyword">if</span>(x&amp;(<span class="number">1LL</span>&lt;&lt;i)) x^=p[i];</span><br><span class="line">	<span class="keyword">return</span> x==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="查询异或最大值"><a href="#查询异或最大值" class="headerlink" title="查询异或最大值"></a>查询异或最大值</h3><p>按位贪心即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">askmx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(R <span class="type">int</span> i=<span class="number">62</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">if</span>((ans^p[i])&gt;ans) ans^=p[i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="查询异或最小值"><a href="#查询异或最小值" class="headerlink" title="查询异或最小值"></a>查询异或最小值</h3><p>其实异或的最小值一般来说就是线性基里的最小元素，因为插入这个元素的时候我们总是尽量让它的高位为$0$才来插入这一位。但是为什么是“一般”呢？因为有可能会有出现$0$，得要在插入的时候记下个标记来特判才行。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">askmn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(zero) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(R <span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">62</span>;i++)</span><br><span class="line">		<span class="keyword">if</span>(p[i]) <span class="keyword">return</span> p[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="查询异或第-k-小"><a href="#查询异或第-k-小" class="headerlink" title="查询异或第$k$小"></a>查询异或第$k$小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rebuild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(R <span class="type">int</span> i=MB;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">for</span>(R <span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">			<span class="keyword">if</span>(p[i]&amp;(<span class="number">1LL</span>&lt;&lt;j)) p[i]^=p[j];</span><br><span class="line">	<span class="keyword">for</span>(R <span class="type">int</span> i=<span class="number">0</span>;i&lt;=MB;i++) <span class="keyword">if</span>(p[i]) d[cnt++]=p[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&gt;=(<span class="number">1LL</span>&lt;&lt;cnt)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	LL ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(R <span class="type">int</span> i=MB;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">if</span>(k&amp;(<span class="number">1LL</span>&lt;&lt;i)) ans^=d[i];</span><br><span class="line">	<span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样其实还不太对，因为我们并没有考虑$0$的情况，所以还要去考虑一下$0$的情况，特判即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,tmp-zero?<span class="built_in">kth</span>(tmp-zero):<span class="number">0LL</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="查询排名"><a href="#查询排名" class="headerlink" title="查询排名"></a>查询排名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rank</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(R <span class="type">int</span> i = cnt - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">                  <span class="keyword">if</span>(x &gt;= d[i]) ans += (<span class="number">1</span> &lt;&lt; i), x ^= d[i];</span><br><span class="line">      <span class="keyword">return</span> ans + zero; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：这个$d[i]$是重建后的线性基。</p>
<h1 id="部分结论-amp-定理-amp-技巧"><a href="#部分结论-amp-定理-amp-技巧" class="headerlink" title="部分结论 &amp; 定理 &amp; 技巧"></a>部分结论 &amp; 定理 &amp; 技巧</h1><h2 id="Prufer-序列"><a href="#Prufer-序列" class="headerlink" title="Prufer 序列"></a>Prufer 序列</h2><h3 id="树转-Prufer"><a href="#树转-Prufer" class="headerlink" title="树转 Prufer"></a>树转 Prufer</h3><p>不断将编号最小的叶子节点删除并将其父节点加入 Prufer 序列</p>
<p>可以证明树中至少有 $2$ 个叶子，所以 $n$ 号点必然留到最后，也就是可以把 $n$ 当作根先求出每个点的父节点</p>
<p>考虑用一个指针维护最小叶子，每删一个叶子，至多只能多一个叶子，所以直接判其是否小于当前指针</p>
<p>如果是，将其加入 Prufer ；否则，继续枚举指针，因为不影响</p>
<p>不难发现每一种不区分儿子顺序的无根树都能唯一对应一种 Prufer 序列</p>
<p>这里也可以看出， Prufer 中一个点出现的次数等于其点度减 $1$</p>
<h3 id="Prufer-转树"><a href="#Prufer-转树" class="headerlink" title="Prufer 转树"></a>Prufer 转树</h3><p>类似根据树转 Prufer 的做法考虑通过 Prufer 倒推树</p>
<p>从前往后枚举 Prufer 序列，每次取出在之后没出现，且还没选过的点确认为当前选出的叶子，根据 Prufer 就可以知道它的父亲</p>
<p>从小到大枚举数，同时维护一个在 Prufer 上从前往后的指针</p>
<p>找到一个合法的叶子时，它的父亲就是指针指向的 Prufer 的值，同时向后移动指针</p>
<p>此时它的父亲可能成为新的叶子，当它的父亲编号小于当前枚举的数时继续确定树上结构即可</p>
<p>注意 Prufer 的长度为 $n-2$ 所以要在后面加一个 $n$ 以指示最后一个被删的数的父亲同时防止操作越界</p>
<p>同时也不难发现每一个 Prufer 序列唯一对应一棵树，因此无根树是与 Prufer 序列一一对应的</p>
<h3 id="一些推论或应用"><a href="#一些推论或应用" class="headerlink" title="一些推论或应用"></a>一些推论或应用</h3><ul>
<li>给定点度数计数</li>
</ul>
<p>直接可以得出每个点在 Prufer 中的出现次数 $d<em>i$，答案就是 $\frac{(n-2)!}{\prod</em>{i} d_i!}$</p>
<hr>
<ul>
<li>无根树森林计数</li>
</ul>
<p>考虑建立无根树的 EGF</p>
<hr>
<ul>
<li>有根树森林计数</li>
</ul>
<p>考虑把每棵树的跟连到 $n+1$ 上，直接做无根树计数，然后把与 $n+1$ 相连的边断开即可</p>
<hr>
<ul>
<li>有根树森林给定根计数</li>
</ul>
<p>设给定了 $P$ 个根，此时只要这个序列的最后一位是某一个根并且序列长度为 $n-P$ 就一定能对应一种合法森林</p>
<p>根据一般 Prufer 的处理方式，我们不选择维护最后一位为根，而是去掉最后一位，强制某个根少出现一次</p>
<p>此时无法维护每个点各为一棵树的情况，具体做题的时候可能需要特判</p>
<h3 id="拓展：图联通计数"><a href="#拓展：图联通计数" class="headerlink" title="拓展：图联通计数"></a>拓展：图联通计数</h3><blockquote>
<p>$n$ 个点 $m$ 条边的图，若其有 $K$ 个联通块，求添加 $K-1$ 条边使其联通的方案数</p>
</blockquote>
<p>设联通块 $i$ 的点度为 $d_i$ ，则总方案为</p>
<script type="math/tex; mode=display">
\binom{K-2}{d_1-1,d_2-1,\dots,d_K-1}=\frac{(K-2)!}{(d_1-1)!(d_2-1)!\dots(d_K-1)!}</script><p>设联通块 $i$ 的点数为 $s_i$ ，则其连边的方案为 $s_i^{d_i}$ ，则枚举 $d$ 序列有总方案数为</p>
<script type="math/tex; mode=display">
\sum_{d_i\geq 1 \ and\  \sum d_i=2K-2}\binom{K-2}{d_1-1,d_2-1,\dots,d_K-1}*\prod_{i=1}^Ks_i^{d_i}</script><p>考虑多项式定理</p>
<script type="math/tex; mode=display">
(x_1+\dots+x_m)^p=\sum_{c_i\geq0\ and\  \sum c_i=p}\binom{p}{c_1,c_2,\dotsm c_m}*\prod_{i=1}^mx_i^{c_i}</script><p>换元 $e_i=d_i-1\ and\ \sum e_i=K-2$ 得</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{e_i\geq0\ and\ \sum e_i=K-2}\binom{K-2}{e_1,e_2,\dots,e_K}*\prod_{i=1}^Ks_i^{e_i+1}\\
&=(s_1+s_2+\dots+s_K)^{K-2}*\prod_{i=1}^K s_i \\
&=n^{K-2}\prod_{i=1}^Ks_i
\end{align}</script><p>得到了一个很简洁的答案</p>
<h2 id="无向图环计数"><a href="#无向图环计数" class="headerlink" title="无向图环计数"></a>无向图环计数</h2><h3 id="三元环计数"><a href="#三元环计数" class="headerlink" title="三元环计数"></a>三元环计数</h3><p>对无向图定向，每条边由度数大的点指向度数小的点，若度数相同则由标号大的指向标号小的</p>
<p>此时图变成了 $DAG$，那么先枚举一个点 $u$，将其在 DAG 上可达的点打上标记</p>
<p>再枚举它在 DAG 上指向的一个点 $v$，然后再枚举 $v$ 的可达点，若被标记了，则这个点和 $u,v$ 共同构成三元环</p>
<p>此时对于一条边 $u\rightarrow v$，它被遍历的次数为 $in_u$ 即 $u$ 在 DAG 中的入度</p>
<p>显然 $deg_u\geq in_u$，因此 $u$ 及其前面的点共需要使用 $O(in_u^2)$ 条边，因此 $in_u$ 是 $O(\sqrt m)$ 级别的</p>
<p>故总复杂度为 $O(m\sqrt m)$ 的</p>
<h3 id="四元环计数"><a href="#四元环计数" class="headerlink" title="四元环计数"></a>四元环计数</h3><p>首先类似三元环一样将图定向形成 DAG</p>
<p>那么对于一个四元环，它的结构应该是 $u\rightarrow v\rightarrow v’\rightarrow w,u\rightarrow w$ 或者 $u\rightarrow v,v’\rightarrow w$</p>
<p>其中 $u,w$ 是拓扑序中最小和最大的点</p>
<p>因此我们的做法为对于点 $u$，枚举它的可达点 $v$，同时枚举 $v$ 在<strong>无向图</strong>上的可达点 $w$ 且满足在拓扑序上 $u&lt;w$，给答案加上 $w$ 的标记后让 $w$ 的标记增大 $1$</p>
<p>此时复杂度也是 $O(m\sqrt m)$ 的</p>
<h2 id="竞赛图"><a href="#竞赛图" class="headerlink" title="竞赛图"></a>竞赛图</h2><p>有向完全图的一种叫法</p>
<h3 id="哈密顿路径"><a href="#哈密顿路径" class="headerlink" title="哈密顿路径"></a>哈密顿路径</h3><p>这里给出一种提取竞赛图哈密顿路径的做法，同时也可以视为竞赛图一定存在哈密顿路径的一个证明</p>
<p>考虑分治解决问题，将点集分成两部分然后分别求解</p>
<p>考虑合并两条哈密顿路径</p>
<p>类似于归并排序，从两条路径的起点开始枚举</p>
<p>对于现在在枚举的节点，考虑它们中间的边，将这条边的起点加入合并的路径，并枚举下一个节点</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ukzjtee2.png" alt=""></p>
<p>类似图中合并 $[1,4]$ 与 $[5,6]$，因为存在边 $1\Rightarrow 5$，所以将 $1$ 压入合并路径，并继续合并 $[2,4]$ 与 $[5,6]$，正确性显然</p>
<h3 id="哈密顿回路"><a href="#哈密顿回路" class="headerlink" title="哈密顿回路"></a>哈密顿回路</h3><p>强联通的竞赛图一定包含一条哈密顿回路</p>
<p>考虑在哈密顿路径上做</p>
<p>一定可以找到一个最靠后的点使得它有一条指向开头的边，那么这个子图就有哈密顿回路</p>
<p>然后往后拓展，如果一个点没有一条指向哈密顿回路的边，那么就往后走</p>
<p>因为强连通，所以一定有边指向哈密顿回路</p>
<p>若此时已积累一条单向链，那么直接选该边，被指向点在哈密顿回路上的前驱一定指向单向链起点</p>
<p>否则此时一定可以找到哈密顿回路上相邻两个点，使得后一个被当前点指向，前一个点指向当前点</p>
<p>另外一个与强联通相关的性质是竞赛图缩点后一定为一条链</p>
<h3 id="兰道定理"><a href="#兰道定理" class="headerlink" title="兰道定理"></a>兰道定理</h3><p>将一个竞赛图的出度序列从小到大排列</p>
<p>它是一个合法的序列当且仅当</p>
<script type="math/tex; mode=display">
\forall 1\leq k \leq n,\sum_{i=1}^k a_i\geq \binom k2</script><p>当然，显然 $k=n$ 时右边的式子要取等</p>
<p>必要性是这 $k$ 个点内部必须是连满的，还有可能往外连边</p>
<p>充分性略</p>
<h3 id="Erdos–Gallai-定理"><a href="#Erdos–Gallai-定理" class="headerlink" title="Erdős–Gallai 定理"></a>Erdős–Gallai 定理</h3><p>虽然与竞赛图没什么关系，但是还是放在这里</p>
<p>将无向图的度数从大到小排列</p>
<p>它是一个合法序列当且仅当，度数之和为偶数，且</p>
<script type="math/tex; mode=display">
\forall 1\leq k \leq n,\sum_{i=1}^k d_i-\sum_{i=k+1}^n\min(d_i,k) \leq k(k-1)</script><p>必要性是假设这 $k$ 个点尽可能连到其它点上后剩下的度数足够内部消化</p>
<h2 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h2><p>定义域数 $d$ 为平面图将平面划分出的数目</p>
<p>那么一张联通平面图有 $d=m-n+2$</p>
<p>而有 $k$ 个联通块的平面图有 $d=m-n+k+1$</p>
<p>进而拓展得到对于一张不一定联通的平面图有 $d+n-m\geq 2$</p>
<ul>
<li>极大平面图</li>
</ul>
<p>无限分割域可以使得每个域都只有三条边  $3d\leq2m$ ，且平面图联通</p>
<p>带入欧拉公式 $\begin{cases}m\leq 3n-6\ d\leq2n-4\end{cases}$</p>
<ul>
<li>最小度点</li>
</ul>
<p>设点度最小为 $k$，显然在极大平面图中才会让点度更大，联立方程 $\begin{cases}kn\leq 2m \ 3d= 2m\end{cases}$ 解得 $kn\leq 6n-12$</p>
<p>最终得到 $k \leq 5$</p>
<h2 id="非平面图的判定"><a href="#非平面图的判定" class="headerlink" title="非平面图的判定"></a>非平面图的判定</h2><p>一张图是非平面图当且仅当缩掉所有度数为 $2$ 的点后存在 $K<em>5$ 或 $K</em>{3,3}$ 子图</p>
<h2 id="数论-1"><a href="#数论-1" class="headerlink" title="数论"></a>数论</h2><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>对于质数 $p$，若 $gcd(a,p)=1$，则 $a^{p-1}\equiv1 \pmod p$</p>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若 $a\bot m$，则 $a^{\varphi(m)} \equiv 1 \pmod m$</p>
<hr>
<h3 id="拓展欧拉定理"><a href="#拓展欧拉定理" class="headerlink" title="拓展欧拉定理"></a>拓展欧拉定理</h3><script type="math/tex; mode=display">
a^c \equiv
\begin{cases}
  a^{c \bmod \varphi(m)} &\gcd(a,m)=1 \\
  a^c &\gcd(a,m) \neq 1,c<\varphi(m) \\
  a^{\left(c \bmod \varphi(m)\right)+\varphi(m)} &\gcd(a,m) \neq 1,c \geq \varphi(m)
\end{cases}
\pmod m</script><h3 id="O-1-快速乘"><a href="#O-1-快速乘" class="headerlink" title="O(1) 快速乘"></a>O(1) 快速乘</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">ksc</span><span class="params">(ll x,ll y,ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll d=(<span class="type">long</span> <span class="type">double</span>)x/mod*y+<span class="number">0.5</span>;</span><br><span class="line">    ll bck=x*y-d*mod;</span><br><span class="line">    <span class="keyword">return</span> bck&lt;<span class="number">0</span>?bck+mod:bck;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>听说因为一些奇怪的溢出又溢回来的奇怪问题，总之它就是对的</p>
<p>因为 <code>long double</code> 的精度问题所以小概率会锅，但架不住它快啊</p>
<p>补自 2021.11.17，似乎 <code>__int128</code> 的存在使得快速乘没有价值了</p>
<p>补自 2021.12.15，CTT Day4 证明了 <code>__int128</code> 比 <code>long double</code> 常数大</p>
<hr>
<h3 id="Exgcd"><a href="#Exgcd" class="headerlink" title="Exgcd"></a>Exgcd</h3><p>对于不定方程 $ax+by= gcd(a,b)$</p>
<p>$\because gcd(a,b)=gcd(b,a\bmod b)$</p>
<p>设 $bx_0+(a\bmod b)y_0= gcd(b,a\bmod b)$</p>
<p>则 $ax+by=bx_0+(a-\lfloor\frac ab\rfloor*b)y_0$</p>
<p>待定系数可得 $\begin{cases}x=y_0 \ y=x_0-\lfloor\frac ab\rfloor*y_0 \end{cases}$</p>
<p>注意它求出来的 $x,y$ 可能是负数</p>
<p>另外，这种求法求出的是 $|x|+|y|$ 最小的一组解</p>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>当合并同余方程组时</p>
<script type="math/tex; mode=display">
\begin{cases}
a_1\equiv b_1 \pmod {p_1} \\
a_2\equiv b_2 \pmod {p_2} \\
\ldots\ldots\\
a_n\equiv b_n \pmod {p_n}
\end{cases}</script><p>若 $\forall i\neq j,p_i\bot p_j$ 则有一种简单的合并方式</p>
<p>显然最后的模数是 $M=\prod_{i=1}^n p_i$</p>
<p>设 $M_i=\frac M {p_i}$ ，那么显然 $M_i \bot p_i$</p>
<p>设 $t_i\equiv \frac 1 {M_i} \pmod {p_i}$，这个可以通过 Exgcd 求</p>
<p>那么我们可以构造一个显然正确的答案 $\sum_{i=1}^n b_iM_it_i$</p>
<hr>
<h3 id="Excrt"><a href="#Excrt" class="headerlink" title="Excrt"></a>Excrt</h3><p>直接合并同余方程就行了，注意除掉 gcd 再做之类问题</p>
<p>可用性广一些，但细节也多一些</p>
<h3 id="Lucas-定理"><a href="#Lucas-定理" class="headerlink" title="Lucas 定理"></a>Lucas 定理</h3><script type="math/tex; mode=display">
\binom{n}{m}\equiv \binom{n/P}{m/P}*\binom{n\bmod P}{m\bmod P} \pmod P</script><p>其中 $P$ 是质数</p>
<p>这个式子的意义在于优化组合数求解的速度</p>
<p>另外，组合数求解只在 $n,m&lt;P$ 的时候才能逆元求解，否则无法处理出现上下约分的情况，而 Lucas 定理可以将 $n,m$ 减小到 $p$ 以下</p>
<hr>
<ul>
<li>ExLucas</li>
</ul>
<p>考虑分解 $mod=\prod p_i^{b_i}$，显然可以对每个 $p_i^{b_i}$ 分别求解然后 Excrt 合并</p>
<p>现在问题转化为了求解 $\binom{n}{m}\equiv\frac{n!}{m!(n-m)!} \pmod {p^k}$</p>
<p>考虑分开算每个阶乘，比如 $n!=p^e*q\ (q\bot p)$</p>
<p>那么我们可以将 $p^e$ 提出来算，而 $q\bot p$，所以是有逆元存在的</p>
<p>考虑 $n!$ 相当于按 $p^k$ 的长度分段，把 $p$ 的倍数拿出来除掉 $p$ 继续递归，其余互质的部分在模 $p^k$ 意义下显然可以直接预处理</p>
<h3 id="库默尔定理"><a href="#库默尔定理" class="headerlink" title="库默尔定理"></a>库默尔定理</h3><p>令 $v_p(n)$ 表示 $n$ 中质因子 $p$ 的次数，则 $v_p(\binom{n}{m})$ 为 $m$ 与 $n-m$ 在 $p$ 进制下的加法进位次数</p>
<p>这里考虑 $\binom nm=\frac {n!}{m!(n-m)!}$</p>
<p>而 $x!$ 中 $p$ 的次数为 $\sum_{i=0}^\infty \lfloor\frac x {p^i}\rfloor$</p>
<p>那么 $m$ 与 $n-m$ 在 $p$ 进制下每次进位就会在某个 $i$ 处多贡献 $1$</p>
<h3 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h3><script type="math/tex; mode=display">
p\in \text{prime} \iff (p-2)!\equiv 1 \pmod p</script><p>当 $p$ 为合数时显然 $(p-2)!\equiv 0 \pmod p$，因此满足必要性</p>
<p>当 $p$ 为质数时，这些数都有逆元，一一搭配得到 $1$，因此也满足充分性</p>
<h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><ol>
<li>Exgcd 法：考虑欲求 $x^{-1}<em>x \equiv 1 \pmod p$，转化为 $x^{-1}</em>x+p*y=1$，解线性不定方程即可</li>
<li>费马小定理法：根据费马小定理 $x^{p-1} \equiv 1 \pmod p$ 得 $x^{-1}\equiv x^{p-2} \pmod p$</li>
<li>线性递推法：考虑带余除法 $mod=x*t \cdots r$，有 $r\equiv -xt \pmod p \iff x^{-1}\equiv - tr^{-1} \pmod p$</li>
</ol>
<h3 id="原根与乘法群"><a href="#原根与乘法群" class="headerlink" title="原根与乘法群"></a>原根与乘法群</h3><p>定义 $g$ 为 $\Z^*_n$（整数模 $n$ 乘法群，其中元素是模 $n$ 的互质同余类）的原根，那么 $g^{0}\sim g^{\varphi(n)-1}$ 为 $1\sim \varphi(n)$</p>
<hr>
<h3 id="原根基础"><a href="#原根基础" class="headerlink" title="原根基础"></a>原根基础</h3><p>一个整数 $n$ 有原根 $\iff n=2、4、p^k、2p^k$</p>
<p>若 $n$ 有原根，则其原根个数为 $\varphi(\varphi(n))$，有个感性的理解方式把这个剩余系绕成一个环，一个 $g$ 就对应一个可以遍历整个环的步长，那这个步长肯定与环长互质</p>
<p>对于原根的判定，我们需要使得 $\forall x,0&lt;x&lt;\varphi(n),g^x\not \equiv1$</p>
<p>考虑若 $g^x\equiv1$，那么 $g^{xy}\equiv 1$，所以我们只需判断 $\forall p\mid\varphi(n),g^{\frac{\varphi(n)}{p}}\not\equiv1$ 即可</p>
<hr>
<h3 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h3><p>对于 $\Z^*_p$ 中每个数 $x$，称以 $g$ 为原根时 $y$ 是它的离散对数 $\iff g^y\equiv x\pmod p$</p>
<p>离散对数可以将 $\Z^<em>_p$ 中的乘法转化为 $\Z^</em>_{\varphi(p)}$ 中的加法</p>
<p>求解方法可以使用后面提到的 BSGS</p>
<p>这里再给出一个 Pohlig-Hellman 算法，主要用于处理 $\varphi(p)$ 的质因子较小的情况 </p>
<p>我们知道 $g$ 的阶是 $\varphi(p)$，从中分解出一个质数 $\varphi(p)=p’q$，那么我们可以假设 $g^{p’u+v}\equiv x \pmod p$</p>
<p>考虑两边同时取 $q$ 次幂，因为 $g^{p’q}\equiv1 \pmod p$，所以 $g^{vq}\equiv (g^{q})^v\equiv x^{q} \pmod p$，因为 $g^q$ 的阶是 $p’$，那么就可以在 $O(\sqrt{p’})$ 的复杂度中求出 $v$</p>
<p>将逆元带入原式 $g^{p’u}\equiv (g^{p’})^u\equiv x*g^{-v} \pmod p$，那么阶就变成了 $\frac{\varphi(p)}{p’}$ 继续递归求解 $u$</p>
<hr>
<h3 id="阶-1"><a href="#阶-1" class="headerlink" title="阶"></a>阶</h3><p>定义 $ord_n(x)=k$，表示最小的正整数 $k$ 使得 $x^k \equiv1 \pmod n$，也可以理解为是 $x$ 的幂在模 $n$ 意义下的环长</p>
<p>显然有 $ord_n(x)\mid \varphi(n)$</p>
<p>不难发现原根其实就是 $ord_n(g)=\varphi(n)$</p>
<p>另外在存在原根的时候不难发现 $gcd(\ln_n(x),\varphi(n))*ord_n(x)=\varphi(n)$，也就是步长乘以步数等于环长</p>
<p>求阶的思路比较简单，直接分解 $\varphi(n)$，初始将 $ord_n(x)$ 置为 $\varphi(n)$，然后不断试除质因子判断是否还有 $x^{ord_n(x)}\equiv1 \pmod n$即可</p>
<h3 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a>二次剩余</h3><p>对于奇质数 $p$ 和整数 $x\bot p$，若存在 $a$ 使得 $a^2\equiv x \pmod p$，我们称 $x$ 在模 $p$ 意义下是一个二次剩余</p>
<p>实际实现注意特判 $x=0$</p>
<hr>
<ul>
<li>勒让德符号</li>
</ul>
<p>定义勒让德符号 $(\frac xp)=x^{\frac{p-1}2}$</p>
<p>考虑 $x^{p-1}\equiv 1 \pmod p$ ，那么有 $(x^{\frac {p-1}2}+1)(x^{\frac{p-1}2}-1)\equiv 0 \pmod p$</p>
<p>因此 $x^{\frac {p-1}2}$ 必定为 $1$ 或 $-1$</p>
<p>若其为 $-1$ 则一定无解，否则 $\sqrt x ^{p-1}\not\equiv 1 \pmod p$，矛盾</p>
<p>接下来因为 $p$ 为奇质数，所以存在原根，设其为 $g$</p>
<p>有 $g^{y\frac{p-1}2}\equiv 1$，又因为 $g$ 的阶为 $p-1$，所以 $p-1\mid y\frac{p-1}2$，因此 $2\mid y$，那么 $g^{\frac y2}$ 即为 $x$ 的二次剩余</p>
<script type="math/tex; mode=display">
(\frac{x}{p})=
\begin{cases}
-1,\quad \not\exist a,a^2\equiv x \pmod p\\
1,\quad \exist a,a^2 \equiv x \pmod p\\
0,\quad p\mid x
\end{cases}</script><hr>
<ul>
<li>高斯二次互反律</li>
</ul>
<p>对于奇质数 $p,q$ 有 $(\frac pq)<em>(\frac qp)=(-1)^{\frac{p-1}2</em>\frac{q-1}2}$</p>
<p>且对于奇质数 $c$ 有 $(\frac{ab}c)=(\frac ac)*(\frac bc)$ ，这个显然</p>
<hr>
<ul>
<li>Cipolla</li>
</ul>
<p>考虑随机一个数 $n$ 使得 $(\frac{n^2-x}{p})=-1$，可以证明大约有一半 $n$ 满足条件，所以期望只需要随机 $2$ 次即可</p>
<p>考虑令 $\omega\equiv\sqrt{n^2-x} \pmod p$，具体运算类比复数</p>
<p>我们有一个性质 $\omega^p\equiv (\omega^2)^{\frac{p-1}2}*\omega\equiv -\omega \pmod p$</p>
<p>还有一个性质 $(a+b)^p=\sum_{i=0}^p \binom{p}{i}a^ib^{p-i}$，显然只有 $i=0/p$ 时 $\binom{p}{i}\not\equiv0 \pmod p$，因为 $p$ 作为奇质数一定不会被小于它的数约分掉，因此 $(a+b)^p\equiv a^p+b^p \pmod p$</p>
<p>那么 $a=(n+\omega)^{\frac{p+1}2}$ 就是 $a^2\equiv x \pmod p$ 的一根</p>
<script type="math/tex; mode=display">
\begin{aligned}
a^2
&\equiv (n+\omega)^{p+1}\\
&\equiv (n+\omega)^p*(n+\omega)\\
&\equiv (n^p+\omega^p)*(n+\omega)\\
&\equiv (n-\omega)(n+\omega)\\
&\equiv n^2-(n^2-x)\\
&\equiv x \pmod p
\end{aligned}</script><p>那么我们只需要维护一个类似于虚数的加、乘法运算即可</p>
<p>另外，考虑一个二次方程最多只有两个根，而对于 $a^2\equiv (p-a)^2 \equiv x \pmod p$ 确实有两个解，不会存在增根，所以解出来的虚数中 $\omega$ 前的系数必然为 $0$</p>
<p>这里可能需要特判 $a=0$</p>
<h3 id="Baby-Step-Giant-Step-BSGS"><a href="#Baby-Step-Giant-Step-BSGS" class="headerlink" title="Baby Step Giant Step(BSGS)"></a>Baby Step Giant Step(BSGS)</h3><p>对于形如求解 $a^k=b$ 在 $[0,n]$ 中的最小非负整数解 $k$ 的问题，其中的乘法是一个满足结合律的半群（走若干次以后进入循环，一开始的一截可能不在循环内）</p>
<p>考虑取 $B=\sqrt n$，预处理出 $a^0,a^1,\ldots,a^{B-1}$ 和 $a^B,a^{2B},\ldots,a^{\lfloor\frac{n}{B}\rfloor B}$</p>
<p>将第二个集合压入哈希表，在第一个集合中枚举，若存在 $p,q$ 使得 $b*a^p=a^{qB}$，则 $b$ 有可能等于 $a^{qB-p}$</p>
<p>然后比如我们的运算存在逆元的时候 $b$ 一定等于 $a^{qB-p}$，否则需要带入验算</p>
<h3 id="类欧几里得算法"><a href="#类欧几里得算法" class="headerlink" title="类欧几里得算法"></a>类欧几里得算法</h3><ul>
<li>前置基础知识</li>
</ul>
<script type="math/tex; mode=display">
x>\frac ab \iff x>\lfloor\frac ab\rfloor \\
x\leq \frac ab \iff x\leq \lfloor\frac ab\rfloor \\</script><hr>
<ul>
<li>原型</li>
</ul>
<script type="math/tex; mode=display">
f(a,b,c,n)=\sum_{i=0}^n \lfloor\frac{ai+b}c\rfloor</script><p>首先特判掉 $a=0$ 和 $n&lt;0$ 的情况</p>
<p>然后我们可以用比较显然的办法简化一下问题</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(a,b,c,n)
&=\sum_{i=0}^n \lfloor\frac{ai+b}c\rfloor \\
&=\sum_{i=0}^n \lfloor\frac{(\lfloor\frac ac\rfloor c+a\bmod c)i+(\lfloor\frac bc\rfloor c+b\bmod c)}{c}\rfloor \\
&=\lfloor\frac ac\rfloor*\frac{n(n+1)}2+\lfloor\frac bc\rfloor (n+1)+\sum_{i=0}^n \lfloor\frac{(a\bmod c)i+(b\bmod c)}{c}\rfloor \\
&=\lfloor\frac ac\rfloor*\frac{n(n+1)}2+\lfloor\frac bc\rfloor (n+1)+f(a\bmod c,b\bmod c,c,n)
\end{aligned}</script><p>这样就只需要考虑 $a&lt;c,b&lt;c$ 的情况了</p>
<p>考虑对条件与贡献放缩与转化，具体而言原式中 $0\leq i \leq n$ 是条件，而 $\lfloor\frac{ai+b}c \rfloor$ 是贡献</p>
<p>一般而言想要优化一个式子通常采用的是贡献合并，然而这里的贡献因为取整符号而难以合并，那么我们不妨转化条件与贡献</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(a,b,c,n)
&=\sum_{i=0}^n\sum_{j=0}^{\lfloor\frac{ai+b}c \rfloor-1}1 \\
&=\sum_{j=0}^{\lfloor\frac{an+b}c \rfloor-1}\sum_{i=0}^n [j<\lfloor\frac{ai+b}c \rfloor]
\end{aligned}</script><p> 改一下后面的式子</p>
<script type="math/tex; mode=display">
j<\lfloor\frac{ai+b}c \rfloor \iff j+1\leq\lfloor\frac{ai+b}c \rfloor \iff j+1\leq \frac{ai+b}c</script><p>继续变换</p>
<script type="math/tex; mode=display">
j+1\leq\frac{ai+b}c \iff jc+c-b-1<ai\iff\lfloor\frac{jc+c-b-1}a\rfloor<i</script><p>令 $m=\lfloor\frac{an+b}c\rfloor$，此时原式变为</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(a,b,c,n)
&=\sum_{j=0}^{m-1}\sum_{i=0}^n[\lfloor\frac{jc+c-b-1}a\rfloor<i] \\
&=\sum_{j=0}^{m-1}(n-\lfloor\frac{jc+c-b-1}a\rfloor) \\
&=nm-f(c,c-b-1,a,m-1)
\end{aligned}</script><p>此时 $a,c$ 调换了顺序，然后继续辗转相除，就可以递归处理，不难发现复杂度是 $O(\log c)$ 的</p>
<hr>
<ul>
<li>拓展式</li>
</ul>
<blockquote>
<p><del>你已经学会四则运算了，快来完成这道微积分例题吧！</del></p>
</blockquote>
<script type="math/tex; mode=display">
g(a,b,c,n)=\sum_{i=0}^n i\lfloor\frac{ai+b}c\rfloor</script><p>首先还是除掉 $a,b$ 中多出的部分，令 $A=\lfloor\frac ac\rfloor,B=\lfloor\frac bc\rfloor$，求解 $\sum_{i=0}^n i(Ai+B)$，直接套用公式即可</p>
<p>那么接下来默认 $a&lt;c,b&lt;c$</p>
<p>令 $m=\lfloor\frac{an+b}c\rfloor,t=\lfloor\frac{cj+c-b-1}a\rfloor,N=(c,c-b-1,a,m-1)$ 那么转化式子得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
g(a,b,c,n)
&=\sum_{j=0}^{m-1}\sum_{i=0}^n i[i>t] \\
&=\sum_{j=0}^{m-1}\frac{(n+t+1)(n-t)}2 \\
&=\frac12 \sum_{j=0}^{m-1} n^2-t^2+n-t \\
&=\frac12(mn^2+mn-\sum_{j=0}^{m-1}t^2-\sum_{j=0}^{m-1}t) \\
&=\frac12(mn(n+1)-h(N)-f(N))
\end{aligned}</script><p>这里引入新的定义</p>
<script type="math/tex; mode=display">
h(a,b,c,n)=\sum_{i=0}^n \lfloor\frac{ai+b}c\rfloor^2</script><p>接下来还是表演老两样，一步除去 $a,b$ 中多余部分，令 $N=(a\bmod c,b\bmod c,c,n),A=\lfloor\frac ac\rfloor,B=\lfloor\frac bc\rfloor$</p>
<script type="math/tex; mode=display">
\begin{aligned}
h(a,b,c,n)
&=\sum_{i=0}^n (Ai+B+\lfloor\frac{(a\bmod c)i+(b\bmod c)}c\rfloor)^2 \\
&=\sum_{i=0}^n (Ai+B+R)^2 \\
&=\sum_{i=0}^n A^2i^2+B^2+R^2+2ABi+2AiR+2BR \\
&=\sum_{i=0}^n A^2i^2+2ABi+B^2+h(N)+2A*g(N)+2B*f(N)
\end{aligned}</script><p>然后默认 $a&lt;c,b&lt;c$，再一步交换贡献与条件</p>
<p>令 $v=\lfloor\frac{ai+b}c\rfloor,m=\lfloor\frac{an+b}c\rfloor,t=\lfloor\frac{cj+c-b-1}a\rfloor,N=(c,c-b-1,a,m-1)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
h(a,b,c,n)
&=\sum_{i=0}^n\sum_{j=0}^{v-1}(2j+1) \\
&=\sum_{j=0}^{m-1}(2j+1)\sum_{i=0}^n[i>t] \\
&=\sum_{j=0}^{m-1}(2j+1)(n-t) \\
&=nm^2-\sum_{j=0}^{m-1}(2j+1)t \\
&=nm^2-2g(N)-f(N)
\end{aligned}</script><p>至此我们已经完成了 $g,h$ 的维护，由于这三个函数总是互相调用，因此实现的时候一般是对于同样的状态一起维护，复杂度 $O(\log c)$</p>
<h3 id="万能欧几里得算法"><a href="#万能欧几里得算法" class="headerlink" title="万能欧几里得算法"></a>万能欧几里得算法</h3><h3 id="Stern-Brocot-树"><a href="#Stern-Brocot-树" class="headerlink" title="Stern-Brocot 树"></a>Stern-Brocot 树</h3><p>这是一种用于维护分数的结构</p>
<p>首先从两个分数 $\frac 01,\frac 10$ 开始，忽略分数的定义我们可以将 $\frac10$ 视为 $\infty$</p>
<p>不断地在序列中的两个分数 $\frac ab,\frac cd$ 中插入 $\frac{a+c}{b+d}$</p>
<script type="math/tex; mode=display">
\frac 01,\frac 11,\frac 10 \\
\frac 01,\frac 12,\frac 11,\frac 21,\frac 10 \\
\frac 01.\frac 13,\frac 12,\frac 23,\frac 11,\frac 32,\frac 21,\frac 31,\frac 10 \\</script><p>但是竟然说是树，我们肯定要弄出类似于树的结构来</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/k5nwmlsg.png" alt=""></p>
<p>首先，数学归纳法证明它每一层都是单调的，$\frac ab\leq \frac cd \iff ad\leq bc \iff ad+ab\leq bc+ab \iff \frac ab\leq \frac{a+c}{b+d}$，另一边同理可得证</p>
<p>类似的，我们证明 $bc-ad=1$，$b(a+c)-a(b+d)=bc-ad=1$</p>
<p>将它看做一个不定方程 $bx-ay=1$，因为显然 $c,d$ 为一组解，所以 $c\bot d$，同理 $a\bot b$</p>
<p>这样我们就知道了这棵树每一层都是最简分数</p>
<hr>
<ul>
<li>在 Stern-Brocot 树上二分</li>
</ul>
<p>虽然我们现在有了一个很好的枚举分数的结构，但还是有点不够</p>
<p>考虑不妨考虑这样一个问题，询问小于一个实数 $k$ 的最大的最简分数 $\frac xy$，且满足 $x,y\leq n$</p>
<p>当然这里的小于 $k$ 其实可以改成任意具有单调性的问题，这样这个算法的意义就很大了</p>
<p>首先特判掉 $\frac 01,\frac 10$，因为这两个数实际上不在树中</p>
<p>然后我们每次判断当前节点是否合法，如果合法就往右，否则往左</p>
<p>但是这样还不够，不难发现假如我们想要找到的分数是类似 $\frac n1$ 的数，那么我们可能需要向下走 $O(n)$ 步</p>
<p>不妨简化一些步骤，比如确认下一步的方向后，二分得到往这个方向还会走多少步，这样相当于一段连续路径被 $O(\log n)$ 优化掉了</p>
<p>而对于左右来回切换，不难发现分子分母之和类似于斐波那契数列，增大速度极快，大约也是 $O(\log n)$ 级就无法再走了</p>
<p>也就是说我们的复杂度降到了 $O(\log^2 n)$</p>
<h2 id="容斥与反演"><a href="#容斥与反演" class="headerlink" title="容斥与反演"></a>容斥与反演</h2><h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><h4 id="常见积性-数论函数"><a href="#常见积性-数论函数" class="headerlink" title="常见积性/数论函数"></a>常见积性/数论函数</h4><p>积性函数满足若 $x\bot y$ 有 $f(xy)=f(x)*f(y)$</p>
<p>显然一般默认 $f(1)=1$</p>
<p>设 $x=\prod_{i=1}^{cnt} p_i^{b_i},\quad\forall i,b_i \neq 0$</p>
<ul>
<li>$\varepsilon(x)=[x=1]$   狄利克雷卷积的单位元，完全积性函数</li>
<li>$\mu(x)=\begin{cases}0 &amp;\exist b_i&gt;1 \ (-1)^{cnt}&amp; otherwise\end{cases}$</li>
<li>$id(x)=x$ 完全积性函数</li>
<li>$1(x)=1$ 完全积性函数</li>
<li>$\varphi(x)=\sum_{i=1}^x[x\bot i]$</li>
<li>$d(x)=\prod_{i=1}^{cnt}(b_i+1)$</li>
<li>$\tau(x)=\prod<em>{i=1}^{cnt}\sum</em>{j=0}^{b_i}p_i^{j}$</li>
</ul>
<blockquote>
<p> 不是积性函数的数论函数 $\lambda(x)=\sum_{i=1}^{cnt} b_i$</p>
</blockquote>
<p>定义狄利克雷卷积 $h=g*f$ 表示 $h(n)=\sum_{d\mid n}g(d)f(\frac nd)$</p>
<p>两个积性函数的狄利克雷卷积还是一个积性函数</p>
<p>两个积性函数的点乘 $h(n)=g(n)\cdot f(n)$ 是一个积性函数</p>
<h4 id="贝尔级数"><a href="#贝尔级数" class="headerlink" title="贝尔级数"></a>贝尔级数</h4><script type="math/tex; mode=display">
F(z)=\sum_{i\geq1}\frac{f(i)}{i^2}</script><p>相当于是为狄利克雷卷积而的诞生的不带有 $x$ 的生成函数</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(z)*G(z)
&=\sum_{i\geq1} \frac{f(i)}{i^2}*\sum_{j\geq1}\frac{g(j)}{j^2}\\
&=\sum_{n\geq1}\frac{\sum_{d|n}f(d)g(\frac nd)}{n^2}\\
&=(F*G)(z)
\end{aligned}</script><p>所以这个东西可以表示狄利克雷卷积</p>
<p>而我们一般需要求的是积性函数，所以只需要质数处的值就可以求了</p>
<p>定义质数处的贝尔级数 $F<em>p(z)=\sum</em>{n\geq0}f(p^n)z^n$，那么两个积性函数相卷的贝尔级数恰好对应它们在每个质数处的贝尔级数的卷积</p>
<p>当然这里的卷积正确性又有所不同</p>
<script type="math/tex; mode=display">
\begin{aligned}
F_p(z)*G_p(z)
&=\sum_{i\geq0}f(p^i)z^i*\sum_{j\geq0}g(p^j)z^j\\
&=\sum_{n\geq0}\sum_{i=0}^nf(p^i)g(p^{n-i})z^{n}\\
&=\sum_{n\geq0}\sum_{d|n}f(d)g(\frac{p^n}{d})z^n\\
&=(F*G)_p(z)
\end{aligned}</script><p>下面给出一下常见的贝尔级数</p>
<ul>
<li>$\varepsilon_p(z)=1$</li>
<li>$1_p(z)=1+z+z^2+\ldots=\frac1{1-z}$</li>
<li>$id_p(z)=1+pz+p^2z^2+\ldots=\frac1{1-pz}$</li>
<li>$\mu_p(z)=1-z$</li>
<li>$\mu^2_p(z)=1+z$</li>
<li>$\varphi_p(z)=1+(p-1)z+p(p-1)z^2+\ldots=1+\frac{(p-1)z}{1-pz}=\frac{1-z}{1-pz}$</li>
<li>$d_p(z)=1+2z+3z^2+\ldots=\frac1{(1-z)^2}$</li>
</ul>
<p>用于推导有很好的效果，但是没有用于计算具体值的价值</p>
<h4 id="莫比乌斯反演核心式"><a href="#莫比乌斯反演核心式" class="headerlink" title="莫比乌斯反演核心式"></a>莫比乌斯反演核心式</h4><ul>
<li>$\varepsilon=1*\mu$ 这个主要用于转化掉式子中的艾佛森括号，如 $[i\bot j]$ 等</li>
<li>$id=1*\varphi$ 这个主要用于转化掉式子中的比较麻烦的贡献，如 $\gcd(i,j)$ 等</li>
<li>$\varphi=\mu*id$</li>
</ul>
<script type="math/tex; mode=display">
f(n)=\sum_{d\mid n}g(d) \iff g(n)=\sum_{d\mid n}\mu(\frac{n}{d})f(d) \\
f(n)=\sum_{n\mid d}g(d) \iff g(n)=\sum_{n\mid d}\mu(\frac{d}{n})f(n)</script><h4 id="一些常用的推论式"><a href="#一些常用的推论式" class="headerlink" title="一些常用的推论式"></a>一些常用的推论式</h4><ol>
<li><p>$\sum_{i=1}^n [i\bot n]i=\frac{\varphi(n)*n}2$</p>
<p>若 $\gcd(x,n)=1$，由辗转相除法必有 $\gcd(n-x,n)=1$，那么可以将与 $n$ 互质的树两两配对为 $n$</p>
<p>因为 $\frac n2 \not \bot n$ 所以不会出现重复计算</p>
</li>
<li><p>$\sum<em>{i=1}^n\sum</em>{j=1}^n [i\bot j]ij=\sum_{i=1}^n i^2 \varphi(i)$</p>
<p>考虑递推式</p>
<script type="math/tex; mode=display">
\begin{cases}
F(n)=F(n-1)+2\sum_{i=1}^n [i\bot n]in,\quad n\neq 1 \\
F(1)=1
\end{cases}</script><p>那么展开式子得到 $F(n)=\sum<em>{i=2}^ni\sum</em>{j=1}^i [i \bot j]j+1$</p>
<p>代入上一个结论即可</p>
</li>
<li><p>$\sum<em>{i=1}^n\sum</em>{j=1}^n [i\bot j]$ 的两种求法</p>
<ol>
<li>$\mu$ 相关</li>
</ol>
<script type="math/tex; mode=display">
\sum_{i=1}^n \sum_{j=1}^n [i\bot j]=
\sum_{i=1}^n \sum_{j=1}^n \sum_{d\mid i,d\mid j} \mu(d)=\sum_{d=1}^n \mu(d) \lfloor\frac nd\rfloor^2</script><p>整除分块即可</p>
<ol>
<li>$\varphi$ 相关</li>
</ol>
<p>考虑递推式</p>
<script type="math/tex; mode=display">
\begin{cases}
F(n)=F(n-1)+2\sum_{i=1}^n [i\bot n]=F(n-1)+2\varphi(n) \\
F(1)=1
\end{cases}</script><p>展开得到 $F(n)=2\sum_{i=1}^n \varphi(i)-1$</p>
</li>
<li><p>$d(xy)=\sum<em>{i\mid x}\sum</em>{j\mid y}[i\bot j]$</p>
<p>$xy$ 的因数是由 $y$ 的所有因数乘上一个 $x$ 的因数的来的</p>
<p>为防止重复计算，考虑建立一个对应关系 $i*\frac yj$</p>
<p>那么一个相当于对于这个因数的质因子尽量在 $y$ 中选取，不够就在 $x$ 中再选，多了就除掉，所以不会重复</p>
<p>也就是一种质因子只会在一个数中出现，而此时这个质因子的次数应该是在这个数之前的所有这个质因子的指数之和加上当前出现的指数</p>
<p>不难发现这个结论是可以推广的，只需要满足枚举的因子两两互质即可</p>
</li>
<li><p>$\varphi(xy)=\frac{\varphi(x)\varphi(y)\gcd(x,y)}{\varphi(\gcd(x,y))}$</p>
<p>往下再推导通常是考虑用 $\varphi*1=id$ 来处理掉 $\gcd$ 来简化式子</p>
</li>
<li><p>$\mu(xy)=[x\bot y]\mu(x)\mu(y)$</p>
</li>
<li><p>$f_D(xy)=f_D(x)f_D(y)f_D^2(xy)$ 其中设 $n=\prod_i b_i^{k_i}$ 则 $f_D(n)=\prod_i (-1)^{k_i}[\max{k_i}\leq D]$</p>
<p>考虑设 $h_D(n)=\max_t{t^{D+1}|n}$</p>
<p>则 $f<em>D^2(n)=[h(n)=1]=\sum</em>{d\mid h<em>D(n)} \mu(d)=\sum</em>{d^{D+1}\mid n} \mu(d)$</p>
</li>
<li><p>$2^{f(n)}=\sum<em>{d\mid n} \mu^2(d)=\sum</em>{d\mid n}[d\bot \frac nd]$，其中 $f(n)$ 表示 $n$ 的不同质因子个数</p>
<p>前面的化法看起来比较好看，但实际上求解前缀和时后面的那个式子我推得的复杂度更低，前面的反而优化空间更低</p>
</li>
<li><p>$\sum<em>{i=1}^n \mu^2(i)=\sum</em>{i=1}^n\sum<em>{d^2\mid i}\mu(d)=\sum</em>{d=1}^{\sqrt n}\mu(d)\lfloor\frac n{d^2}\rfloor$</p>
<p>考虑 $i$ 无二次质因子的时候，能产生贡献的 $d$ 显然只有 $1$，恰好 $\mu(1)$ 贡献 $1$</p>
<p>否则 $\mu^2(i)=0$，此时每个次数大于 $1$ 的质因子都会经历选与不选，$\mu(d)$ 相互抵消为 $0$</p>
</li>
</ol>
<h4 id="杜教筛-1"><a href="#杜教筛-1" class="headerlink" title="杜教筛"></a>杜教筛</h4><p>构造函数 $g(x)$，则有</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n(f*g)(i)=\sum_{i=1}^n\sum_{d\mid i}g(d)f(\frac id)=\sum_{i=1}^ng(i)S(\lfloor \frac ni \rfloor)</script><p>可得 $g(1)S(n)=\sum<em>{i=1}^n(f*g)(i)-\sum</em>{i=2}^ng(i)S(\lfloor\frac ni \rfloor)$</p>
<p>当构造的 $g(x)$ 使 $(f*g)(i)$ 和 $g(i)$ 方便求出时，对 $S(\lfloor \frac ni \rfloor)$ 整除分块求出 $S(n)$</p>
<p>考虑在递归的过程中我们只会求形如 $S(\lfloor\frac nx\rfloor)$ 的式子，那么我们用 map 或哈希表保存已求出的值</p>
<p>那么我们的复杂度就是 $O(\sum_{x=1}^{\sqrt n} \sqrt{\frac nx}+\sqrt x)$，积分近似是 $O(n^{\frac 34})$</p>
<p>考虑线性筛预处理 $S(1)\sim S(T)$，积分得到复杂度是 $O(\frac n{T^{\frac12}}+T)$，取 $T=n^{\frac 23}$ 时有最优复杂度 $O(n^{\frac 23})$</p>
<p>实际 $T$ 可能取大点比较好？线性筛应该比杜教筛常数小</p>
<p>回过来考虑我们记忆化其实不需要使用 map 或哈希表，因为我们已经预处理了 $S(1)\sim S(n^{\frac 23})$</p>
<p>所以我们实际需要保存的是 $\lfloor\frac{n}{x}\rfloor,x\leq n^ \frac 13$，我们直接保留在对应 $\lfloor\frac{n}{\lfloor\frac{n}{x}\rfloor}\rfloor$ 的位置即可</p>
<p>但如果是多组询问的话，使用 map 可能效果更好，因为可以沿用之前的答案</p>
<hr>
<ul>
<li>嵌套杜教筛</li>
</ul>
<p>考虑嵌套调用的过程中查询的位置也是形如 $\lfloor\frac nx\rfloor$ 的位置，所以复杂度不变</p>
<hr>
<ul>
<li>杜教筛式算法复合处理</li>
</ul>
<p>举个例子吧，考虑求解 $\forall x,\sum_{i=1}^{\lfloor\frac nx \rfloor}d(i)$</p>
<p>考虑求解 $\sum<em>{i=1}^{\lfloor \frac nx \rfloor} d(i)$，枚举一个数看有多少个数包含它这个因子 $\sum</em>{i=1}^{\lfloor \frac nx \rfloor} \lfloor\frac n{ix}\rfloor$，可以整除分块做到 $O(\sqrt {\lfloor \frac nx \rfloor})$，暴力整除分块套整除分块做完显然是 $O(n^{\frac 34})$</p>
<p>那么我们可以先预处理到一定范围，后面的使用暴力方法硬做，复杂度也是 $O(n^{\frac 23})$</p>
<h3 id="单位根反演"><a href="#单位根反演" class="headerlink" title="单位根反演"></a>单位根反演</h3><script type="math/tex; mode=display">
[k\mid n]=\frac 1k\sum_{i=0}^{k-1}\omega_k^{in}</script><p>更形象地可以理解为以 $\omega_k^n$ 为步长在圆上走，若整除，则其值为 $1$，走 $k$ 步就是 $k$，否则可以分成若干组，每组都形如 $\omega_t^0+\omega_t^1+\ldots+\omega_t^{t-1}$​​ 等比数列求和可以发现等于 $0$</p>
<p>另外可以特别注意一下 $\omega_2^x=(-1)^x$</p>
<ul>
<li>例：<a target="_blank" rel="noopener" href="https://uoj.ac/problem/450">UOJ450 复读机</a></li>
</ul>
<h3 id="拉格朗日反演"><a href="#拉格朗日反演" class="headerlink" title="拉格朗日反演"></a>拉格朗日反演</h3><p>若 $F(G(x))=x$，即 $G(F(x))$，称 $F(x)$ 与 $G(x)$ 互为复合逆</p>
<p>此时有</p>
<script type="math/tex; mode=display">
[x^n]F(x)=\frac1n[x^{-1}](\frac1{G(x)})^n=\frac1n [x^{n-1}](\frac x{G(x)})^n \\ [x^n]H(F(x))=\frac1n[x^{-1}]H'(x)(\frac1{G(x)})^n=\frac1n [x^{n-1}]H'(x)(\frac x{G(x)})^n</script><h3 id="子集反演"><a href="#子集反演" class="headerlink" title="子集反演"></a>子集反演</h3><script type="math/tex; mode=display">
f(S)=\sum_{T\subseteq S} g(T) \iff g(S)=\sum_{T\subseteq S} (-1)^{|S|-|T|}f(T) \\
f(S)=\sum_{S\subseteq T} g(T) \iff g(S)=\sum_{S\subseteq T} (-1)^{|S|-|T|}f(T)</script><h4 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h4><script type="math/tex; mode=display">
f(n)=\sum_{i=0}^n \binom{n}{i} g(i) \\
g(n)=\sum_{i=0}^n (-1)^{n-i} \binom{n}{i} f(i)</script><p>二项式反演是子集反演的特殊情况</p>
<h3 id="多重子集反演"><a href="#多重子集反演" class="headerlink" title="多重子集反演"></a>多重子集反演</h3><p>定义 $\mu(S)$ 表示若 $S$ 中有重复元素则 $\mu(S)=0$，否则 $\mu(S)=(-1)^{|S|}$</p>
<script type="math/tex; mode=display">
f(S)=\sum_{T\subseteq S} g(T) \iff g(S)=\sum_{T\subseteq S} \mu(S-T)f(T) \\
f(S)=\sum_{S\subseteq T} g(T) \iff g(S)=\sum_{S\subseteq T} \mu(T-S)f(T)</script><p>正确性就不证了，通常来说，我们可以强行将任意元素看成互不相同，然后使用子集反演，但是我们也可以根据多重子集反演的 $\mu(S)$ 可能等于 $0$ 来省略掉一些无用情况的枚举</p>
<p>莫比乌斯反演是将一个数的质因子当做多重集的多重子集反演</p>
<h3 id="韦恩图式容斥"><a href="#韦恩图式容斥" class="headerlink" title="韦恩图式容斥"></a>韦恩图式容斥</h3><p>给定多个限制，求不满足任何一个限制的总数，令 $S$ 为所有限制的集合</p>
<script type="math/tex; mode=display">
\sum_{T\subseteq S} F(T)*(-1)^{|T|}</script><p>本质可以考虑所有方案满足的限制集合，当且仅当一个方案不满足任何一个限制的时候才会贡献 $1$</p>
<h3 id="min-max-容斥"><a href="#min-max-容斥" class="headerlink" title="min-max 容斥"></a>min-max 容斥</h3><script type="math/tex; mode=display">
\min(S)=\sum_{T\sub S\ and\  T\neq \empty}(-1)^{|T|-1}\max(T)\\
\max(S)=\sum_{T\sub S\ and\  T\neq \empty}(-1)^{|T|-1}\min(T)</script><p>这里只证明第一个式子，第二个类似</p>
<p>考虑将 $S$ 集合的元素排序</p>
<p>对于元素 $a_i$ ，它会作为最大值在 $2^{i-1}$ 个子集中贡献</p>
<p>这些子集是完全的，也就是说都会存在，不会因为条件限制不贡献</p>
<p>所以很自然地想到让奇数大小的子集与偶数大小的子集的贡献符号相反</p>
<script type="math/tex; mode=display">
\sum_{i =  1}^n \binom ni =\sum_{i =  0}^n \binom ni ,\quad n\geq1</script><p>这样除了最小值只在一个子集中，贡献了一次，其他的元素全部抵消了不贡献</p>
<p>min-max 容斥其实提供了一类容斥的思路，通过对所有子集求值来获得全集的一个值</p>
<hr>
<ul>
<li>min-max 容斥推广</li>
</ul>
<script type="math/tex; mode=display">
\text{kthmin}(S)=\sum_{T\sub S\ and\  T \neq \empty} (-1)^{|T|-k}\binom{|T|-1}{k-1} \max(T) \\
\text{kthmax}(S)=\sum_{T\sub S \ and\  T \neq \empty} (-1)^{|T|-k}\binom{|T|-1}{k-1} \min(T)</script><p>只证明第一个式子，第二个同理</p>
<p>不难发现当 $|T|&lt;k$​ 的时候根本没有贡献，所以比 $a_k$​ 小的数根本不会贡献</p>
<p>考虑研究元素 $a_t$​​ 贡献的系数</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{i=1}^t \binom {t-1}{i-1} (-1)^{i-k} \binom{i-1}{k-1} \\
&= \sum_{i=1}^t (-1)^{i-k} \binom{t-1}{k-1}\binom{t-k}{i-k} \\
&=\binom{t-1}{k-1}\sum_{i=0}^{t-k} (-1)^i \binom{t-k}{i}
\end{align}</script><p>与二项式反演类似的思路，求和符号中的内容是奇偶相抵，只有 $t=k$ 的时候系数为 $1$</p>
<h3 id="条件划分容斥"><a href="#条件划分容斥" class="headerlink" title="条件划分容斥"></a>条件划分容斥</h3><p>考虑当限制可划分为阶段时，可以通过 dp 优化</p>
<p>设 $dp_i$ 表示最后一个强制不满足的限制是 $i$ 时的方案数</p>
<p>枚举 $i$ 之前的阶段的某个限制 $j$ ，$dp_i=dp_i-dp_j*val(j,i)$，其中 $val(j,i)$ 表示已知不满足限制 $j$，经过 $j\rightarrow i$ 之间的阶段后转移到 $i$ 的方案数变化系数</p>
<p>正确性考虑对于一种不合法方案只在第一个限制处会被算到一次，在之后的每个限制处都不会被算到</p>
<h3 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h3><script type="math/tex; mode=display">
f(n)=\sum_{i=0}^n {n \brace i} g(i) \iff g(n)=\sum_{i=0}^n (-1)^{n-i}{n \brack i} f(i) \\
f(k)=\sum_{i=k}^n {i \brace k} g(i) \iff g(k)=\sum_{i=k}^n (-1)^{i-k}{i \brack k} f(i)</script><p>证明可以考虑由之后介绍的上升幂，下降幂与常幂的转化推导</p>
<h3 id="一些经典限制的容斥方式"><a href="#一些经典限制的容斥方式" class="headerlink" title="一些经典限制的容斥方式"></a>一些经典限制的容斥方式</h3><ul>
<li>强连通图</li>
</ul>
<p>将条件改成，缩为 DAG 以后不存在小于 $n$ 的入度为 $0$ 的点</p>
<p>对小于 $n$ 的点集入度为 $0$ 这个限制做容斥即可</p>
<hr>
<ul>
<li>元素值不相同</li>
</ul>
<p>若干个元素，要求它们在值互不相同时满足某个条件</p>
<p>考虑建立一个完全图，一条边表示两个元素的值不能相同</p>
<p>那么一个简单的容斥思路是直接枚举它的子图，然后将边当做要求值相同，然后做无限制的计数</p>
<p>但是枚举子图还是复杂度太大了，最多到 $n=7$ 就不行了</p>
<p>现在我们假设这些元素不区分，也就是我并不关心容斥的时候具体哪两个值相同，只关心分成的联通块分别是怎样的</p>
<p>直接枚举拆分联通块，考虑计算它可能带来的贡献和</p>
<p>令 $G<em>n=\sum</em>{S\subseteq E}(-1)^{|S|}=[n=1]$ 表示乱选边的贡献和，令 $F_n$ 表示选的边连成了一个联通块的贡献和</p>
<p>那么 $F<em>n=G_n-\sum</em>{i=1}^{n-1} \binom{n-1}{i-1}F<em>{i}G</em>{n-i}=(-1)^{n-1}(n-1)!$</p>
<h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="拉格朗日插值"><a href="#拉格朗日插值" class="headerlink" title="拉格朗日插值"></a>拉格朗日插值</h3><p> 若对于 $n$ 次多项式有 $n+1$ 个点值 $(x_0,y_0),(x_1,y_1),(x_2,y_2)\ldots (x_n,y_n)$</p>
<p> 则有</p>
<script type="math/tex; mode=display">
F(x)=\sum_{i=0}^n y_i\prod_{j\neq i}\frac{x-x_j}{x_i-x_j}</script><p>通常用于优化背包之类简单的多项式相乘</p>
<hr>
<ul>
<li>求解拉格朗日插值的多项式系数</li>
</ul>
<p>考虑 $\prod_{t=1}^n(x-x_t)$ 对次数来说是背包一样的东西，所以直接做一遍背包，而 $\frac1{x-x_i}$ 可以用逆向背包解决</p>
<hr>
<ul>
<li>高维插值</li>
</ul>
<p>对于一些题目，我们可能需要维护多个未知数，这种情况下同样可以使用拉格朗日插值，且做法基本相同</p>
<h4 id="整数幂和"><a href="#整数幂和" class="headerlink" title="整数幂和"></a>整数幂和</h4><ul>
<li><p>拉格朗日插值求解</p>
<p>$\sum_{i=0}^n i^k$ 是关于 $n$ 的 $k+1$ 次多项式，显然可以拉格朗日插值</p>
</li>
</ul>
<p>我们知道在选取的 $x$ 已知的情况下，拉格朗日插值可以 $O(k)$ 得到答案</p>
<p>考虑快速求点值，不难发现 $i^k$ 是一个完全积性函数，在质数位置快速幂计算的复杂度为 $O(\frac k {\log k}*\log k)=O(k)$，线性筛即可</p>
<p>复杂度 $O(k)$，侧重于对固定的 $k$ 快速计算答案</p>
<hr>
<ul>
<li>生成函数求解</li>
</ul>
<p>若已知 $n$，考虑写出 $\sum_{i=1}^n i^k$ 的 EGF，有</p>
<script type="math/tex; mode=display">
\begin{align}
G(x)
&=\sum_{k\geq0}\frac{\sum_{i=1}^ni^k}{k!}x^k \\
&=\sum_{i=1}^n\sum_{k\geq0}\frac{i^k}{k!}x^k \\
&=\sum_{i=1}^n e^{ix}
\end{align}</script><p>由等比数列求和公式得</p>
<script type="math/tex; mode=display">
G(x)=\frac{e^{(n+1)x}-e^x}{e^x-1}</script><p>多项式求逆即可</p>
<p>实际实现的时候因为分子分母常数项都为 $0$，所以要先除以 $x$；另外 $g_0$ 显然没有算，所以要自己特判一下</p>
<p>复杂度 $O(n\log n)$，侧重于对于每一个 $k$ 算出同一个 $n$ 的答案</p>
<h3 id="循环卷积"><a href="#循环卷积" class="headerlink" title="循环卷积"></a>循环卷积</h3><blockquote>
<p>DFT就是对扩域后的多项式做循环卷积 ——Daniel_yuan</p>
</blockquote>
<hr>
<ul>
<li>求逆</li>
</ul>
<p>设 $F(x)*F^{-1}(X)=1$</p>
<p>转成点值后不难发现右边是全 $1$</p>
<p>由于 DFT 关于循环卷积的性质，可以将 $F(x)$ 的点值全部取逆再 IDFT 回去得到在以 $lim$ 为长度的循环卷积逆</p>
<p>写成多元方程的形式易证这样的逆是唯一的</p>
<h4 id="bluestein-算法"><a href="#bluestein-算法" class="headerlink" title="bluestein 算法"></a>bluestein 算法</h4><p>注意到问题转化需要求 $F<em>k=\sum</em>{i=0}^{n-1} a_i w_n^{ik}$</p>
<p>根据组合意义 $ik=\binom{i+k}2-\binom i2-\binom k2$</p>
<p>所以 $F<em>k=\sum</em>{i=0}^{n-1}a<em>iw_n^{\binom{i+k}2-\binom i2-\binom k2}=w_n^{-\binom k2}\sum</em>{i=0}^{n-1}a_i w_n^{-\binom i2}w_n^{\binom{i+k}2}$ ，显然求和符号内变成了一个卷积形式的东西</p>
<p>也就是说我们通过三次 NTT 实现了任意长度的一次 DFT/IDFT</p>
<h3 id="生成函数推导相关"><a href="#生成函数推导相关" class="headerlink" title="生成函数推导相关"></a>生成函数推导相关</h3><h4 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h4><script type="math/tex; mode=display">
F(x)=\sum_{i\geq0}\frac{f^{(i)}(x_0)}{i!}(x-x_0)^i</script><p>一般取 $x_0=0$，即麦克劳林级数</p>
<h4 id="广义二项式定理"><a href="#广义二项式定理" class="headerlink" title="广义二项式定理"></a>广义二项式定理</h4><script type="math/tex; mode=display">
(x+y)^a=\sum_{i\geq0}\binom{a}{i}x^iy^{a-i},\quad a\in \R \\ \binom{a}{i}=\frac{\prod_{j=0}^{i-1}(a-j)}{i!}</script><hr>
<ul>
<li>拓展：多项式定理</li>
</ul>
<p>多项式 $(x_1+x_2+\ldots+x_k)^n$ 的展开式中 $x_1^{n_1}x_2^{n_2}\ldots x_k^{n_k}$ 的系数为</p>
<script type="math/tex; mode=display">
\binom{n}{n_1,n_2\ldots,n_k}=\frac{n!}{n_1!n_2!\ldots n_k!}</script><h4 id="常用生成函数"><a href="#常用生成函数" class="headerlink" title="常用生成函数"></a>常用生成函数</h4><script type="math/tex; mode=display">
\frac1{1-x}=\sum_{i \geq 0}x^i \\
e^{x}=\sum_{i\geq0} \frac{1}{i!}x^i \\
\ln(1-x)=-\sum_{i\geq1} \frac1{i}x^i</script><h4 id="展开生成函数"><a href="#展开生成函数" class="headerlink" title="展开生成函数"></a>展开生成函数</h4><ul>
<li>类 Fibnacci 数列</li>
</ul>
<p>已知 $f<em>n=\begin{cases}n&amp;n\leq1\f</em>{n-1}+f_{n-2}&amp;n&gt;1\end{cases}$</p>
<p>则其生成函数为 $F(x)=x+\sum_{i=2}^\infty f_ix^i$</p>
<script type="math/tex; mode=display">
F(x)=x+\sum_{i=2}^\infty (f_{i-1}*x^{i-1}*x+f_{i-2}*x^{i-2}*x^2)=x+xF(x)+x^2F(x)</script><p>解得 $F(x)=\frac{x}{1-x-x^2}$</p>
<p>对分母部分求根 $x_{1,2}=\frac{-1\pm\sqrt5}{2}$</p>
<p>设 $F(x)=\frac{a}{1-\frac{1+\sqrt5}{2}x}+\frac{b}{1-\frac{1-\sqrt5}{2}x}$</p>
<p>通分，待定系数解得 $\begin{cases}a=\frac 1 {\sqrt5} \b=-\frac1{\sqrt(5)}\end{cases}$</p>
<p>两个分式同时展开，$f_n=[x^n]F(x)=\frac1 {\sqrt5}((\frac{1+\sqrt5}2)^n-(\frac{1-\sqrt5}2)^n)$</p>
<blockquote>
<p>练习：$f<em>n=5f</em>{n-1}-6f_{n-2},n\geq2,f_0=1,f_1=-2$</p>
</blockquote>
<hr>
<ul>
<li>类 Catalan 数列</li>
</ul>
<p>已知 $c<em>n=\begin{cases}1&amp;n=0\\sum</em>{i=0}^{n-1}c<em>ic</em>{n-i-1}&amp;n&gt;0  \end{cases}$</p>
<p>则其生成函数为 $C(x)=c<em>0+\sum</em>{i\geq1}c_ix^i$</p>
<script type="math/tex; mode=display">
C(x)=1+\sum_{i\geq1}(\sum_{j=0}^{i-1}c_jc_{i-j-1})x^i=1+x\sum_{i\geq0}(\sum_{j=0}^{i}c_jc_{i-j})x^i=1+xC^2(x)</script><p>解得 $C(x)=\frac{1\pm \sqrt{1-4x}}{2x}$</p>
<p>$\because C(0)=c_0=1$</p>
<p>考虑 $\begin{cases}\lim<em>{x\rightarrow0}C(x)=\frac{1+\sqrt{1-4x}}{2x}=\infty\ \lim</em>{x\rightarrow0}C(x)=\frac{1-\sqrt{1-4x}}{2x}=1\end{cases}$</p>
<p>得 $C(x)=\frac{1-\sqrt{1-4x}}{2x}$</p>
<p>展开 $\sqrt{1-4x}=\sum_{i\geq0}\binom{\frac12}{i}(-4x)^i$，又有</p>
<script type="math/tex; mode=display">
\begin{align}\binom{\frac12}{i}&=\frac{\frac12*(-\frac12)*(-\frac32)*\ldots*(-\frac{2i-3}2)}{1*2*3*\ldots*i}\\&= (-1)^{i-1}\frac{(2i-3)!!}{2^ii!}\\&=(-1)^{i-1}\frac{(2i-2)!}{2^{2i-1}i!(i-1)!},\quad i\in\N^+    \end{align}</script><p>则 $C(x)=\sum_{i\geq0}\frac{(2n)!}{n!(n+1)!}x^n$</p>
<ul>
<li>例：YZOJ3625</li>
</ul>
<h3 id="五边形数定理"><a href="#五边形数定理" class="headerlink" title="五边形数定理"></a>五边形数定理</h3><script type="math/tex; mode=display">
\prod_{i=1}^{\infty}(1-x^i)=\sum_{i=-\infty}^{\infty}(-1)^ix^{\frac{i(3i-1)}{2}}</script><h3 id="组合数问题的一个式子"><a href="#组合数问题的一个式子" class="headerlink" title="组合数问题的一个式子"></a>组合数问题的一个式子</h3><ul>
<li><script type="math/tex; mode=display">\binom{n}{k}\times k^{\underline{m}}=\binom{n-m}{k-m}\times n^{\underline{m}}</script></li>
</ul>
<h3 id="点值转下降幂系数"><a href="#点值转下降幂系数" class="headerlink" title="点值转下降幂系数"></a>点值转下降幂系数</h3><p>卷一个 $e^{-x}$</p>
<h2 id="组合数学-1"><a href="#组合数学-1" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>其实只有组合，虽然也有排列的存在，但一般来说先选出来然后再全排列可能更容易思考</p>
<p>组合计算中，加法往往比减法简单</p>
<h4 id="经典组合恒等式"><a href="#经典组合恒等式" class="headerlink" title="经典组合恒等式"></a>经典组合恒等式</h4><ol>
<li><p>$\sum_{i=l}^r\binom{i}{x}=\binom{r+1}{x+1}-\binom{l}{x+1}$</p>
<p>可以结合杨辉三角考虑</p>
</li>
<li><p>$\sum<em>{i=1}^n\sum</em>{j=1}^m[i+j=k]\binom ni \binom mj=\binom{n+m}{k}$</p>
<p>考虑有两个大小分别为 $n,m$ 的集合枚举在两个集合中分别选了多少个</p>
</li>
<li><p>$\binom nm=\frac nm \binom{n-1}{m-1}$</p>
<p>这个可以直接结合组合数的计算式理解</p>
</li>
<li><p>$\sum_{i=0}^n \binom ni ^2 =\binom{2n}n$</p>
<p>考虑 $\binom ni=\binom n{n-i}$，那么这条其实就是第 $2$ 条的特殊情况</p>
</li>
<li><p>$\binom nm \binom mk=\binom nk \binom{n-k}{m-k}$</p>
<p>考虑组合意义就是换了一下选取顺序</p>
</li>
</ol>
<h4 id="经典组合问题"><a href="#经典组合问题" class="headerlink" title="经典组合问题"></a>经典组合问题</h4><h5 id="环上邻色不同的染色方案"><a href="#环上邻色不同的染色方案" class="headerlink" title="环上邻色不同的染色方案"></a>环上邻色不同的染色方案</h5><p>两种递推式</p>
<ol>
<li>容斥 $f(n)=m*(m-1)^{n-1}-f(n-1)$</li>
<li>讨论 $a<em>1$ 与 $a</em>{n-1}$ 是否相同 $f(n)=(m-1)f(n-2)+(m-2)f(n-1)$</li>
</ol>
<p>通过第二个递推式线性齐次递推可以得到 $f(n)=(m-1)^n+(m-1)(-1)^n$</p>
<p>这个式子使用的时候注意特判 $f_0=0$</p>
<h5 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h5><p>问题相当于要求计数所以置换环大小都不为 $1$ 的置换数目</p>
<p>那么枚举 $n$ 在置换环上指向的点，然后分类讨论它所在置换环是否为二元环</p>
<p>可得递推式：$f(n)=(n-1)(f(n-1)+f(n-2))$</p>
<h5 id="网格图路径数统计问题"><a href="#网格图路径数统计问题" class="headerlink" title="网格图路径数统计问题"></a>网格图路径数统计问题</h5><ul>
<li><p>$n*m $ 网格图，一条无限制路径：$\binom{n}{n+m}$</p>
</li>
<li><p>$n<em>n$ 网格图，一条不穿过对角线路径：$2</em>\frac{\binom{2n}{n}}{n+1}$</p>
</li>
<li><p>$n*m $ 网格图（$n\leq m$），一条不穿过直线 $y=x$ 路径：$\binom{n+m}{n}-\binom{n+m}{n-1}$</p>
<p>考虑将第一次越过直线 $y=x$ 后的方向反向，变为 $m+1$ 次向右，$n-1$ 次向上，即求到达 $(n-1,m+1)$ 的走法</p>
</li>
<li><p>$n*m$ 网格图，两条不相交路径：$\binom{n+m-2}{n-1}^2-\binom{n+m-2}{n}\binom{n+m-2}{m}$</p>
<p>考虑两条不相交路径的第一步和最后一步都能确定</p>
<p>一定是 $(0,1)$ 走到 $(n-1,m)$ 和 $(1,0)$ 走到 $(n,m-1)$</p>
<p>直接将两种路径的种数乘起来</p>
<p>然后减去 $(1,0)$ 走到 $(n-1,m)$ 和 $(0,1)$ 走到 $(n,m-1)$ 的方案数</p>
<p>减去的显然必然是相交路径，考虑将它们第一次相交前的路径交换就能一一对应一种不合法路径，全部减去即可</p>
<p>当然也可以从 LGV 引理的角度理解</p>
</li>
<li><p>$n*m$ 网格图，一条既不穿过 $y=x-c_0$ 也不穿过 $y=x+c_1$ 两条直线的路径，其中 $c_0,c_1 &gt;0$</p>
<p>同样考虑减去不合法方案</p>
<p>先往上限对称，再往下限对称，再往上对称，符号为 $-1,1,-1\ldots$ 交替变化</p>
<p>它表示的是在不合法方案第一次触上限的时候减掉，在这之后第一次触下限加上，以此类推</p>
<p>类似地做先往下限对称，然后循环</p>
<p>考虑一种不合法方案触上下限的连续变化序列，不管连续段数量的奇偶性，最终都会减去一次</p>
</li>
</ul>
<h5 id="插板法"><a href="#插板法" class="headerlink" title="插板法"></a>插板法</h5><p>将 $n$ 个物品分成 $m$ 组，每组至少一个，答案是 $\binom {n-1}{m-1}$</p>
<hr>
<ul>
<li>不定方程解计数</li>
</ul>
<p>限制 $\sum_{i=1}^n x_i=S$，要求 $x_i\geq R_i$</p>
<p>答案是 $\binom{S-\sum (R_i-1)-1}{n-1}$</p>
<hr>
<ul>
<li>单调不下降序列计数</li>
</ul>
<p>限制 $A\leq x_1 \leq x_2 \leq \cdots \leq x_n \leq B$</p>
<p>考虑研究差分数组，即要求 $\sum_{i=1}^{n+1} y_i=B-A$ 且 $\forall i,y_i\geq 0$</p>
<p>此时转移到不定方程解计数</p>
<hr>
<ul>
<li>不定不等式解计数</li>
</ul>
<p>限制 $\sum_{i=1}^n x_i \leq S$，要求 $x_i\geq 0$</p>
<p>考虑添加一个辅助变量，转移到 $\sum_{i=1}^{n+1} x_i = S$</p>
<p>此时转移到不定方程解计数</p>
<hr>
<ul>
<li>组合意义解决特殊贡献形式</li>
</ul>
<p>组合意义真的是很强的简化问题的办法</p>
<p>举个例子，限制 $\sum<em>{i=1}^n x_i=S$，要求 $x_i\geq 1$，求每种方法 $\prod</em>{i=1}^n x_i$ 的和</p>
<p>考虑 $x_i$ 的贡献是 $x_i$ ，从组合意义上可以理解成非空前缀个数</p>
<p>稍微调整一下，拆成两个变量 $a_i,b_i$ 令 $a_i+b_i=x_i+1\quad a_i,b_i\geq 1$ ，此时把 $x_i$ 拆分成两个数的方案数即为 $x_i$ 的贡献</p>
<p>于是原问题简化成把 $S+n$ 个 $1$ 分到 $2n$ 个不能为空的变量中</p>
<h5 id="冒泡下界问题"><a href="#冒泡下界问题" class="headerlink" title="冒泡下界问题"></a>冒泡下界问题</h5><p>理论上认为对排列 $p$ 做冒泡排序有一个下界 $\frac 12 \sum_{i=1}^n |i-p_i|$</p>
<p>而一个排列能达到这个下界当且仅当这个排列中不存在长度超过二的下降子序列</p>
<p>这个条件还有另一种表达方式，即可以把它划分成不超过两个上升子序列</p>
<p>这一点由 Dilworth 定理可以理解</p>
<p>这个条件另外还有一种更好的简化方式</p>
<p>可以认为一种合法的前缀 $\max$ 序列对应一个这样的排列</p>
<p>构造方式考虑 $\max$ 序列构成若干相同值的段，把段开头的地方的排列值设定为对应值，其他地方上升地填上剩下的数，得到两个上升子序列</p>
<h4 id="Raney-引理"><a href="#Raney-引理" class="headerlink" title="Raney 引理"></a>Raney 引理</h4><p>对于整数数组 $a<em>1,a_2,\ldots,a_n$，若 $\sum</em>{i=1}^n a_i=1$，则其所有循环移位中恰有一种满足所有前缀和都为正数</p>
<hr>
<ul>
<li>卡特兰数通项推导</li>
</ul>
<p>$C_n$ 可表示为长为 $2n$ 的合法括号序列的方案数，将左右括号替换成 $\pm 1$ 要求转化为所有前缀和都为非负数</p>
<p>在最前面加上 $+1$，那么问题就转化为了 Raney 引理的形式</p>
<p>因为所有数之和为 $1$，所以不难发现一种序列的不同循环移位一定互不相同</p>
<p>因此一种本质不同的放法一定会被重复计算 $2n+1$ 次，且这些次数中恰有一种符合条件</p>
<p>那么显然答案就是 $\frac{\binom{2n+1}n}{2n+1}=\frac{\binom{2n}n}{n+1}$</p>
<h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><ol>
<li><p>$F<em>{n-1}F</em>{n+1}-F_n^2=(-1)^n$</p>
<script type="math/tex; mode=display">
\begin{aligned}
F_{n-1}F_{n+1}-F_n^2=F_{n-1}^2+F_n(F_{n-1}-F_n)=-(F_{n-2}F_n-F_{n-1}^2)
\end{aligned}</script><p>不断提出 $-1$，式子最终会化到 $F_1F_3-F_2^2$</p>
</li>
<li><p>$\gcd(F<em>n,F_m)=F</em>{\gcd(n,m)}$</p>
</li>
<li><p>$\sum<em>{i=1}^n F_i=F</em>{n+2}-1$</p>
<p>对 $n$ 的奇偶性分类讨论</p>
<p>$\sum<em>{i=1}^{2n} F_i=\sum</em>{i=1}^nF<em>{2i+1}$，添上 $F_2$ 后可以一直推到 $F</em>{2n+2}$</p>
<p>$\sum<em>{i=1}^{2n+1}=F_1+\sum</em>{i=1}^n F<em>{2i+2}$，同样添上 $F_2$ 后可以一直推到 $F</em>{2n+3}$</p>
</li>
<li><p>在模 $m$ 意义下，类斐波那契数列存在小于等于 $6m$ 的循环节</p>
</li>
</ol>
<hr>
<ul>
<li>$K$ 阶斐波那契数通项</li>
</ul>
<script type="math/tex; mode=display">
\begin{cases}
F_{1,0}=1 \\
F_{k,n}=F_{k,n-1}+F_{k,n-2}+F_{k-1,n}
\end{cases}</script><p>推导生成函数可得</p>
<script type="math/tex; mode=display">
\begin{aligned}
F_{k,n}
&=[x^n]\frac 1{(1-x-x^2)^k} \\
&=[x^n]\frac 1{(1-\lambda_1x)^k(1-\lambda_2x)^k}\quad \lambda_{1,2}=\frac{1\pm \sqrt 5}2 \\
&=\sum_{i=0}^n \binom{i+k-1}{k-1}\binom{n-i+k-1}{k-1}\lambda_1^i\lambda_2^{n-i} \\
&=\frac{\lambda_2^n}{[(k-1)!]^2}\sum_{i=0}^n(i+k-1)^{\underline{k-1}}(n-i+k-1)^{\underline{k-1}}(\frac{\lambda_1}{\lambda_2})^i\\
&=\frac{\lambda_2^n(-1)^{k-1}}{[(k-1)!]^2}\sum_{i=0}^n(i+k-1)^{\underline{k-1}}(i-n-1)^{\underline{k-1}}(\frac{\lambda_1}{\lambda_2})^i\\
&=\frac{\lambda_2^n(-1)^{k-1}}{[(k-1)!]^2}\sum_{i=0}^n(i+k-1)^{\underline{k-1}}(\frac{\lambda_1}{\lambda_2})^i\sum_{j=0}^{k-1}\binom {k-1}ji^{\underline j}(-n-1)^{\underline{k-1-j}} \\
&=\frac{\lambda_2^n(-1)^{k-1}}{[(k-1)!]^2}\sum_{j=0}^{k-1}\binom {k-1}j(-n-1)^{\underline{k-1-j}}\sum_{i=0}^n(i+k-1)^{\underline{k+j-1}}(\frac{\lambda_1}{\lambda_2})^i
\end{aligned}</script><p>不难发现我们只需要快速求解后面一部分就可以了</p>
<script type="math/tex; mode=display">
\begin{aligned}
S_y
&=\sum_{i=0}^n (i+x)^{\underline y}c^i \\
&=\sum_{i=0}^n (i+x-1)^{\underline y}c^i+y*(i+x-1)^{\underline {y-1}}c^i \\
&=cS_{y}-c^{n+1}(n+x)^{\underline y}+(x-1)^{\underline y}\\
&+y*(cS_{y-1}-c^{n+1}(n+x)^{\underline{y-1}}+(x-1)^{\underline{y-1}})
\end{aligned}</script><p>由上，我们只需要 $O(k)$ 预处理就可做完了</p>
<h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><h4 id="代表的一些问题"><a href="#代表的一些问题" class="headerlink" title="代表的一些问题"></a>代表的一些问题</h4><ol>
<li>$n$ 个点的有根区分左右儿子的二叉树的不同形态</li>
<li>圆上 $2n$ 个点匹配使得连边无交点的方案数</li>
<li>$1 \sim n $ 依次入栈对应的不同的出栈序列数</li>
</ol>
<hr>
<h3 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h3><h4 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h4><p>${n \brace m}$ 表示将 $n$ 个不同的元素划分为 $m$ 个互不区分的非空集合的方案</p>
<script type="math/tex; mode=display">
\begin{aligned}
{n \brace m}&={ n-1 \brace m-1}+m*{n-1 \brace m} \\
{n \brace m}&=\frac 1 {m!}\sum_{i=0}^m(-1)^i (m-i)^n\binom{m}{i}  =\sum_{i=0}^m \frac{(-1)^i*(m-i)^{n}}{i!*(m-i)!} \\
n^m&=\sum_{i=0}^n {m \brace i} n^{\underline i}
\end{aligned}</script><p>第一个式子是递推式，枚举元素 $n$ 是单独一组还是加入某个集合</p>
<p>第二个式子首先给 $m$ 个集合强行标号，然后容斥有哪些集合为空</p>
<p>第三个式子表示的是将 $m$ 个不区分的球放入 $n$ 个区分的盒子，允许为空的方案数，等号右边相当于在枚举有几个盒子非空</p>
<h5 id="行计算"><a href="#行计算" class="headerlink" title="行计算"></a>行计算</h5><p>发现通项公式是一个卷积形式，直接 NTT 即可</p>
<h5 id="列计算"><a href="#列计算" class="headerlink" title="列计算"></a>列计算</h5><p>可以写出一个非空集合的 EGF，$F(x)=\sum_{i=1}^\infty \frac{x^i}{i!}$</p>
<p>可以得到 $i \brace m$ 的 EGF 为 $[\frac{x^i}{i!}]\frac{F^k(x)}{k!}$，做一个多项式快速幂即可</p>
<h4 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h4><p>${n \brack m}$ 表示将 $n$ 个不同的元素划分为 $m$ 个互不区分的非空圆排列的方案</p>
<script type="math/tex; mode=display">
\begin{aligned}
{n \brack m}&={n-1 \brack m-1}+(n-1)*{n-1 \brack m} \\
n!&=\sum_{i=0}^n {n \brack i}
\end{aligned}</script><p>第一个递推式的含义就是枚举元素 $n$ 是单独一组还是插在某个圆排列的某个位置</p>
<p>第二个式子右边相当于枚举置换环的个数</p>
<h5 id="行计算-1"><a href="#行计算-1" class="headerlink" title="行计算"></a>行计算</h5><p>由递推式易得第 $n$ 行的 OGF 可写成 $\prod_{i=0}^{n-1}(i+x)$，其实就是 $x^{\overline{n}}$，这个可以用倍增 NTT 法求解</p>
<p>由 $x^{\overline n}$ 到 $x^{\overline {n+1}}$ 显然直接乘一遍就行了</p>
<p>接下来考虑已知 $x^{\overline{n}}$ 求解 $x^{\overline{2n}}$，拆解式子</p>
<script type="math/tex; mode=display">
x^{\overline{2n}}
=x^{\overline{n}}(x+n)^{\overline{n}}</script><p>设 $F(x)=x^{\overline{n}}$，则欲求 $F(x+n)$</p>
<script type="math/tex; mode=display">
\begin{align}
F(x+n)
&=\sum_{i=1}^nf_i(x+n)^i \\
&=\sum_{i=1}^nf_i\sum_{j=0}^i\binom{i}{j}x^jn^{i-j} \\
&=\sum_{j=0}^nx^j\sum_{i=j}^n f_i\binom{i}{j}n^{i-j} \\
&=\sum_{j=0}^nx^j\sum_{i=0}^{n-j} f_{i+j}\frac{(i+j)!}{i!j!}n^i \\
&=\sum_{j=0}^{n-1}\frac{x^j}{j!}\sum_{i=0}^{n-j}f_{i+j}(i+j)!*\frac{n^i}{i!}
\end{align}</script><p>这又是个类似卷积的形式，只需将一个数组反过来做 NTT 就行了</p>
<h5 id="列计算-1"><a href="#列计算-1" class="headerlink" title="列计算"></a>列计算</h5><p>仿照第二类斯特林数的求解方法</p>
<p>写出每个非空圆排列的EGF，$F(x)=\sum<em>{i=1}^\infty \frac{(i-1)!}{i!}x^i=\sum</em>{i=1}^\infty \frac{x^i}{i}$</p>
<p>然后直接得到 ${i \brack m}$ 的 EGF 为 $\frac{F^k(x)}{k!}$</p>
<h4 id="上升幂与下降幂"><a href="#上升幂与下降幂" class="headerlink" title="上升幂与下降幂"></a>上升幂与下降幂</h4><p>首先介绍关于上升幂与下降幂的基本定义与性质</p>
<script type="math/tex; mode=display">
\begin{aligned}
x^{\overline{n}}&=\prod_{i=0}^{n-1}(x+i)=\binom{x+n-1}{n}n! \\
x^{\underline{n}}&=\prod_{i=0}^{n-1}(x-i)=\binom{x}{n}n! \\
x^{\underline{n}}&=(-1)^n(-x)^{\overline{n}} \\
x^{\overline{n}}&=(-1)^n(-x)^{\underline{n}} \\
(x+y)^{\overline{n}}&=\sum_{i=0}^n \binom ni x^{\overline i}y^{\overline {n-i}}\\
(x+y)^{\underline{n}}&=\sum_{i=0}^n \binom ni x^{\underline i}y^{\underline {n-i}}
\end{aligned}</script><p>其中最后两个式子还比较显然，是切换上升幂与下降幂的重要恒等式</p>
<script type="math/tex; mode=display">
\begin{aligned}
x^{\overline{n}}&=\sum_{i=0}^n{n \brack i}x^i \\
x^{\underline{n}}&=\sum_{i=0}^n{n \brack i}(-1)^{n-i}x^i \\
x^n&=\sum_{i=0}^n{n \brace i}x^{\underline{i}} \\
x^n&=\sum_{i=0}^n{n \brace i}(-1)^{n-i}x^{\overline{i}}
\end{aligned}</script><p>第一个很容易理解，因为我们已经知道了第一类斯特林数的行计算就是上升幂</p>
<p>第二个就可以根据之前的恒等式由第一个直接推过来</p>
<p>第三个式子是由第二类斯特林数的性质推导来的</p>
<p>第四个式子是根据恒等式由第三个式子推导来的</p>
<h3 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h3><p>用于求解一个 $n$ 的排列在所有排列中的排名</p>
<script type="math/tex; mode=display">
rank=1+\sum_{i=1}^n\sum_{j=i}^n [a_j<a_i](n-i)!</script><p>其实就是计算当前缀相同时，有多少排列会比它小</p>
<p>搭配树状数组可以做到 $O(n\log n)$</p>
<hr>
<ul>
<li>逆康托展开</li>
</ul>
<p>第 $i$ 位的贡献最多为 $(n-i)*(n-i)!&lt;(n-i+1)!$，所以从前往后一位位地考虑显然对的</p>
<h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h4><p>一个矩阵可以理解为多个向量拼起来，那么消元后最多的线性无关的向量数即为矩阵的秩</p>
<p>也可以简化思考，令 $k$ 阶余子式表示选 $k$ 行 $k$ 列交出的矩阵的行列式</p>
<p>那么矩阵的秩就是最大非零余子式的阶数</p>
<p>给出定理，对称矩阵的秩等于最大非零对称余子式的阶数，这里的对称指的是关于某条斜对角线对称</p>
<h4 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h4><p>矩阵 $A$ 的行列式定义为 $|A|=\sum<em>{\sigma}(-1)^{sgn(\sigma)}\prod A</em>{i,\sigma_i}$，$\sigma$ 为枚举一个排列，$sgn(\sigma)$ 为逆序对数</p>
<p>给出一些性质</p>
<ol>
<li><p>$\det(A\times B)=\det(A)\det(B)$</p>
</li>
<li><p>$A$ 有逆矩阵 $\iff \det(A)\neq0 \iff A$ 矩阵满秩</p>
<p>这个比较好理解，从空间变换的角度来说</p>
<p>非满秩矩阵相当于将空间压缩到更低维度</p>
<p>从更低维度自然无法找到回到高纬度的逆矩阵</p>
</li>
</ol>
<p>求解方式考虑高斯消元</p>
<ol>
<li>行列式某行或某列全为 $0$，行列式为 $0$</li>
<li>交换行列，行列式取负</li>
<li>行或列同乘 $k$ ，行列式乘以 $k$</li>
<li>一行加减另外一行，行列式不变</li>
<li>上三角行列式为对角线之积</li>
</ol>
<h5 id="LGV-引理"><a href="#LGV-引理" class="headerlink" title="LGV 引理"></a>LGV 引理</h5><p>对一个 DAG 计数</p>
<p>定义 $\omega(P)$ 表示 $P$ 这条路径上的边权之积，$e(u,v)$ 表示 $u$ 到 $v$ 的所有路径 $P$ 的 $\omega(P)$ 之和</p>
<p>定义起点集合 $A$ 和终点集合 $B$​，两个集合的大小都为 $n$</p>
<p>$S$ 表示一组 $A\rightarrow B$​ 的 $n$ 条路径且路径两两没有相交点</p>
<p>建立矩阵</p>
<script type="math/tex; mode=display">
M=
\begin{bmatrix}
e(A_1,B_1)&e(A_1,B_2)&\cdots&e(A_1,B_n) \\
e(A_2,B_1)&e(A_2,B_2)&\cdots&e(A_2,B_n) \\
\vdots&\vdots&\ddots&\vdots \\
e(A_n,B_1)&e(A_n,B_2)&\cdots&e(A_n,B_n)
\end{bmatrix}</script><p>则其行列式为所有 $S$ 的 $\omega(P)$ 之积的和</p>
<p>根据行列式定义有 $det(M)=\sum<em>{S} (-1)^{sgn(\sigma)}\prod</em>{i=1}^n \omega(S_i)$</p>
<p>其中 $\sigma$ 表示每个起点对于的终点构成的排列的逆序对数，$S_i$ 表示 $S$ 这种不交路径方案中的第 $i$​ 条路径</p>
<p>对比行列式的定义，无交路径方案显然是正常贡献上去了</p>
<p>对于有交路径方案，把第一个交点后的两条路径交换后，对应 $\sigma$ 的奇偶性发生变化，所以所有有交路径方案全部可以一一对应抵消</p>
<h5 id="特殊矩阵行列式"><a href="#特殊矩阵行列式" class="headerlink" title="特殊矩阵行列式"></a>特殊矩阵行列式</h5><ul>
<li>范德蒙德矩阵的行列式</li>
</ul>
<p>对于如下形式的矩阵</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1&1&1&\cdots&1 \\
x_1&x_2&x_3&\cdots&x_n \\
x_1^2&x_2^2&x_3^2&\cdots&x_n^2 \\
\vdots&\vdots&\vdots&\ddots&\vdots \\
x_1^{n-1}&x_2^{n-1}&x_3^{n-1}&\cdots&x_n^{n-1} \\
\end{bmatrix}</script><p>它的行列式即为 $\prod_{i&lt;j} (x_i-x_j)$</p>
<hr>
<ul>
<li>循环矩阵的行列式</li>
</ul>
<p>对于矩阵</p>
<script type="math/tex; mode=display">
A=\begin{bmatrix}
a_0&a_1&a_2&\cdots&a_{n-1} \\
a_{n-1}&a_0&a_1&\cdots&a_{n-2} \\
a_{n-2}&a_{n-1}&a_0&\cdots&a_{n-3} \\
\vdots&\vdots&\vdots&\ddots&\vdots \\
a_1&a_2&a_3&\cdots&a_0 \\
\end{bmatrix}</script><p>求解它的行列式时可以给它右乘一个范德蒙德矩阵</p>
<script type="math/tex; mode=display">
V=\begin{bmatrix}
1&1&1&\cdots&1 \\
\omega_n^0&\omega_n^1&\omega_n^2&\cdots&\omega_n^{n-1} \\
\omega_n^0&\omega_n^2&\omega_n^4&\cdots&\omega_n^{(n-1)2} \\
\vdots&\vdots&\vdots&\ddots&\vdots \\
\omega_{n}^0&\omega_n^{n-1}&\omega_n^{2(n-1)}&\cdots&\omega_n^{(n-1)(n-1)} \\
\end{bmatrix}</script><p>定义 $f(x)=\sum_{i=0}^{n-1}a_i x^i$</p>
<p>那么两个矩阵相乘后得到的就是</p>
<script type="math/tex; mode=display">
AV=\begin{bmatrix}
f(\omega_n^0)&f(\omega_n^1)&f(\omega_n^2)&\cdots&f(\omega_n^{n-1}) \\
\omega_n^0f(\omega_n^0)&\omega_n^1f(\omega_n^1)&\omega_n^2f(\omega_n^2)&\cdots&\omega_n^{n-1}f(\omega_n^{n-1}) \\
\omega_n^0f(\omega_n^0)&\omega_n^2f(\omega_n^1)&\omega_n^4f(\omega_n^2)&\cdots&\omega_n^{(n-1)2}f(\omega_n^{n-1}) \\
\vdots&\vdots&\vdots&\ddots&\vdots \\
\omega_n^0f(\omega_n^0)&\omega_n^{n-1}f(\omega_n^1)&\omega_n^{2(n-1)}f(\omega_n^2)&\cdots&\omega_n^{(n-1)(n-1)}f(\omega_n^{n-1}) \\
\end{bmatrix}</script><p>对两边同时求行列式得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\det(A)\det(V)=\det(AV)\\
&\iff\det(A)\det(V)=\prod_{i=0}^{n-1}f(\omega_n^i)\det(V) \\
&\iff\det(A)=\prod_{i=0}^{n-1}f(\omega_n^i)
\end{aligned}</script><h4 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h4><p>形式化地考虑，我们是要求一个矩阵 $A^{-1}$ 使得 $AA^{-1}=A^{-1}A=I$</p>
<p>也就是 $\sum<em>{i,j,k} A</em>{i,j} A^{-1}<em>{j,k}=I</em>{i,k}$</p>
<p>定义初等行变换为</p>
<ol>
<li>在模意义下给一行乘上一个非 $0$ 数</li>
<li>把一行加到另一行</li>
<li>交换两行</li>
</ol>
<p>发现对矩阵 $A$ 的初等行变换会在相同位置以相同形式和值作用在矩阵 $I$ 上</p>
<p>那么我们直接将 $A_{i,j}$ 通过初等行变换消成 $I$，同时对 $I$ 做同样的事情，那么式子就变成了 $IA^{-1}=B$</p>
<p>这个 $B$ 就是我们要求的逆矩阵</p>
<h3 id="矩阵树定理"><a href="#矩阵树定理" class="headerlink" title="矩阵树定理"></a>矩阵树定理</h3><h4 id="无向图生成树计数"><a href="#无向图生成树计数" class="headerlink" title="无向图生成树计数"></a>无向图生成树计数</h4><p>设一条边 $(x,y)$ 表示为向量，如 $(2,4)$ 表示为 $\left[ \begin{matrix}0 \ +1 \0 \ -1\end{matrix}\right]$ 或 $\left[\begin{matrix}0 \ -1 \0\+1\end{matrix}\right]$</p>
<p>考虑<strong>一些边无法组成环</strong>用线性代数的形式描述，则是<strong>这些边代表的向量线性无关</strong></p>
<p>将 $m$ 个向量相接得到一个 $n*m$ 的矩阵，考虑这个矩阵的秩为 $n-1$，所以可抹去最后一行</p>
<p>则问题转换为了从 $m$ 个向量中选 $n-1$ 个使它们线性无关的方案数</p>
<p>考虑这 $n-1$ 个向量组成的 $(n-1)*(n-1)$ 的矩阵</p>
<p>当它们线性相关时，这个矩阵的行列式值为 $0$</p>
<p>当它们线性无关时，这个矩阵的行列式值为 $+1$ 或 $-1$</p>
<p>所以可求，每个这样的矩阵的行列式的值的平方之和</p>
<p>设图矩阵为 $D$，它的置换 $D^T$，可知我们所求为 $\sum_{S\subseteq T,|S|=n-1}\det(D_S)\det({D^T}_S)$</p>
<blockquote>
<p>Binet-Cauthy公式</p>
<p>对于 $n<em>m$ 的矩阵 $A$ 和 $m</em>n$ 的矩阵 $B$</p>
<p>$\det(AB)=\sum_{S\subseteq U,|S|=n}\det(A_S)\det(B_S)$</p>
<p>其中 $U={1,2,\ldots,m}$</p>
<p>$A_S$ 表示 $A$ 中行标号集合为 $S$ 的列组成的矩阵</p>
<p>$B_S$ 表示 $B$ 中列标号集合为 $S$ 的行组成的矩阵</p>
</blockquote>
<p>根据 Binet-Cauthy 公式转换为求 $\det(DD^T)$</p>
<p>此时复杂度为 $O(n^2m)$，需要消去复杂度中的 $m$</p>
<p>考虑 $DD^T$ 矩阵的现实意义</p>
<ul>
<li>${DD^T}_{i,i}$：点 $i$ 的度数</li>
<li>${DD^T}_{i,j}$：$i$ 与 $j$ 之间的边数的相反数</li>
</ul>
<p>此时复杂度为 $O(n^3)$</p>
<p>将重边数抽象成边权，则可理解为对角线上对应点加上所连边边权减去邻接矩阵</p>
<h4 id="有向图生成树计数"><a href="#有向图生成树计数" class="headerlink" title="有向图生成树计数"></a>有向图生成树计数</h4><p>消去的一行一列为根，处理对角线后减去邻接矩阵</p>
<ul>
<li>内向树：起点对应位置加值</li>
<li>外向树：终点对应位置加值</li>
</ul>
<h4 id="多项式拓展"><a href="#多项式拓展" class="headerlink" title="多项式拓展"></a>多项式拓展</h4><ul>
<li>化乘为加</li>
</ul>
<p>将矩阵的元素换成多项式即可</p>
<p>例：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6624">[省选联考 2020 A 卷] 作业题</a></p>
<hr>
<ul>
<li>控制边权 $1$</li>
</ul>
<p>边权分 $01$，控制 $0$ 权边的数目恰好为 $K$</p>
<p>将 $0$ 权边边权设为 $x$，$1$ 权边边权设为 $1$</p>
<p>维护求出的多项式的第 $K$ 次方的系数即可</p>
<p>多项式不太好处理，但是它最多为 $n-1$ 次，那么可以直接插值</p>
<hr>
<ul>
<li>控制边权 $2$</li>
</ul>
<p>边权分 $a,b,c,d$，要求 $a$ 的数目不少于 $b$，$c$ 的数目不少于 $d$</p>
<p>令 $a$ 为 $x$，$b$ 为 $x^{-1}$，$c$ 为 $y$，$d$ 为 $y^{-1}$，计算最后所有 $x^iy^j,i,j\geq 0$</p>
<p>二阶插值即可</p>
<h4 id="Best-定理"><a href="#Best-定理" class="headerlink" title="Best 定理"></a>Best 定理</h4><p>用于求解含有欧拉回路的有向图的不同欧拉回路个数</p>
<script type="math/tex; mode=display">
ans=tree_s \prod_{i=1}^n (deg_i-1)!</script><p>其中 $tree_s$ 表示以 $s$ 为根的有向生成树个数，内外向都可以，$s$ 也可以任选</p>
<p>这里以内向生成树证明，外向显然一样</p>
<p>考虑当一个点上所有边都被经过以后可以理解为这个点被删掉了，令 $s$ 最后被删</p>
<p>那么根据每一个点最后走的出边可以建出一棵树，不同的树的个数也就是 $tree_s$</p>
<p>剩下的边任意选择走的顺序都可对应一种方案，这里不详细证明</p>
<p>另外虽然 $s$ 没有树边，剩下的出边应该有 $deg_s$ 个，但是因为出现循环同构，所以只用乘 $(deg_s-1)!$</p>
<p>要注意的是，Best 定理只适用于至少包含一条边的有欧拉回路的图</p>
<p>只有一个点没有边和不存在欧拉回路的情况都要特判</p>
<h2 id="概率与期望"><a href="#概率与期望" class="headerlink" title="概率与期望"></a>概率与期望</h2><h3 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h3><p><strong>概率的基本计算公式</strong>：$P(A)=\frac{n(A)}{n(all)}$</p>
<ul>
<li><p>对于互不相容的事件 $x<em>1,x_2\ldots x_n$，发生其中任意一个的概率为 $\sum</em>{i=1}^n p_i$</p>
</li>
<li><p>对于互相独立的事件 $x<em>1,x_2\ldots x_n$，这些事件全部发生的概率为 $\prod</em>{i=1}^n p_i$</p>
</li>
</ul>
<blockquote>
<p>互不相容指两件事不能同时发生，互相独立指是否发生一件事不会影响另一件事发生的概率</p>
</blockquote>
<ul>
<li><p>$P(A\cup B)=P(A)+P(B)-P(A\cap B)$ （可根据融斥原理推至多个事件求并的概率）</p>
</li>
<li><p>$P(A-B)=P(A)-P(A\cap B)$</p>
</li>
<li><p>全概率公式：若 $\sum_i P(A_i)=1$，且 $A_i$ 互不相容，则 $P(B)=\sum_i P(A_i)*P(B|A_i)$</p>
</li>
<li><p>条件概率：$P(A|B)=\frac {P(A\cap B)}{P(B)}$</p>
<p>考虑恒等式 $P(A\cap B)=P(A|B)P(B)$</p>
<p>移项即可</p>
</li>
<li><p>贝叶斯公式：若 $\sum_i P(C_i)=1$，且 $C_i$ 互不相容，$P(A\mid B)=\frac{P(A\cap B)}{\sum_i P(B|C_i)}$</p>
<p>考虑把条件概率的分母用全概率公式替换即可</p>
</li>
</ul>
<h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>期望表示各种情况下的加权平均</p>
<p><strong>期望的基本计算公式：$E(X)=\sum_i P(x_i)*E(x_i)$</strong></p>
<ul>
<li><p>全期望公式：$E(X)=E(E(X\mid Y))$</p>
<p>$E(E(X\mid Y))=\sum_{i} E(X\mid Y_i)P(Y_i)=\sum_i\sum_j X_jP(Y_i)P(X_j\mid Y_i)=\sum_i\sum_j X_j P(X_j\cap Y_i)=\sum_j X_j P(X_j)=E(X)$</p>
</li>
</ul>
<h4 id="期望方程"><a href="#期望方程" class="headerlink" title="期望方程"></a>期望方程</h4><ul>
<li>抛硬币 $1$</li>
</ul>
<blockquote>
<p>一枚硬币，抛到正面的概率为 $p$，问期望几次得到一个正面</p>
</blockquote>
<p>设抛到正面的期望为 $E$</p>
<p>则可得方程</p>
<script type="math/tex; mode=display">
\begin{align}
&E=p*1+(1-p)*(E+1) \\
&\iff E=\frac1p
\end{align}</script><hr>
<ul>
<li>抛硬币 $2$</li>
</ul>
<blockquote>
<p>不断抛一枚均匀的硬币，知道连续两次正面朝上，求期望抛的次数</p>
</blockquote>
<p>设已连续抛到 $0$ 个正面的期望为 $E_0$，已连续抛到 $1$ 个正面的期望为 $E_1$</p>
<p>则可得方程组</p>
<script type="math/tex; mode=display">
\begin{align}
&\begin{cases} E_0=\frac12*(E_1+1)+\frac12*(E_0+1) \\ E_1=\frac12*1+\frac12*(E_0+1) \end{cases} \\
&\iff \begin{cases} E_0=6 \\ E_1=4 \end{cases}
\end{align}</script><h4 id="期望-dp"><a href="#期望-dp" class="headerlink" title="期望 dp"></a>期望 dp</h4><p>当期望方程中值的转移是无环的时，可直接 dp</p>
<h4 id="循环转移"><a href="#循环转移" class="headerlink" title="循环转移"></a>循环转移</h4><p>列出方程，直接高斯消元</p>
<p>另外当方程中的环只受少量（通常是一个）特定未知数的影响时，可直接维护每个未知数用特定未知数表示时的系数，此时复杂度为 $O(n)$</p>
<h1 id="command-block-博客-（技巧）"><a href="#command-block-博客-（技巧）" class="headerlink" title="command_block 博客 （技巧）"></a>command_block 博客 （技巧）</h1><ul>
<li>多项式计数杂谈</li>
<li>炫酷反演魔术</li>
</ul>
<h1 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h1><ul>
<li>PAM高级玩法</li>
<li>一类数论函数的筛法</li>
<li>线性基全家桶</li>
<li>博弈论结论</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">wrpwrp</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/16/template/">http://example.com/2023/08/16/template/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">wrpwrpのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A8%A1%E6%9D%BF/">模板</a></div><div class="post_share"><div class="social-share" data-image="https://ts1.cn.mm.bing.net/th/id/R-C.c4c52f16cc67c7409eff60a4fce2d152?rik=qBwdq1iz39HyPA&amp;riu=http%3a%2f%2fwww.kutoo8.com%2fupload%2fimage%2f95093231%2f13.jpg&amp;ehk=%2flbRri2PpwfxcQiqdvwcgv76NPhmuhxXUC9lhcyITcw%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://bpic.588ku.com/element_pic/20/07/01/4347f2eea4eebb9a4708ea61636893a7.jpg!/fw/253/quality/90/unsharp/true/compress/true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">wrpwrp</div><div class="author-info__description">QQ:2167306203 退役OIER, HUST 在读</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">常用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99"><span class="toc-number">1.1.</span> <span class="toc-text">快读快写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%BC%BA%E7%9C%81%E6%BA%90"><span class="toc-number">1.2.</span> <span class="toc-text">常用缺省源</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">2.1.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gp-hash-table"><span class="toc-number">2.1.1.</span> <span class="toc-text">gp_hash_table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">朴素实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="toc-number">2.2.</span> <span class="toc-text">字符串哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%93%88%E5%B8%8C"><span class="toc-number">2.2.1.</span> <span class="toc-text">单哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E6%BA%A2%E5%87%BA"><span class="toc-number">2.2.2.</span> <span class="toc-text">自然溢出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%8E%86%E5%8F%B2%E6%9C%80%E5%80%BC%EF%BC%8C-%E5%8C%BA%E9%97%B4%E5%8F%96min"><span class="toc-number">2.3.1.</span> <span class="toc-text">区间历史最值， 区间取min</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%81%8F%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">左偏树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">2.5.</span> <span class="toc-text">平衡树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KDT"><span class="toc-number">2.6.</span> <span class="toc-text">KDT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LCT"><span class="toc-number">2.7.</span> <span class="toc-text">LCT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%8E%E8%B6%85%E6%A0%91"><span class="toc-number">2.8.</span> <span class="toc-text">李超树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">2.9.</span> <span class="toc-text">树链剖分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LCA"><span class="toc-number">2.10.</span> <span class="toc-text">LCA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ST%E8%A1%A8%E6%B1%82LCA"><span class="toc-number">2.10.1.</span> <span class="toc-text">ST表求LCA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%A0%91"><span class="toc-number">2.11.</span> <span class="toc-text">虚树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">3.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">3.1.</span> <span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dijskra-%E5%A0%86%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.1.</span> <span class="toc-text">dijskra 堆优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Johnson-%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">3.1.2.</span> <span class="toc-text">Johnson 全源最短路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF-%E6%AC%A7%E6%8B%89%E8%B7%AF"><span class="toc-number">3.2.</span> <span class="toc-text">欧拉回路&#x2F;欧拉路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E6%AC%A7%E6%8B%89%E8%B7%AF"><span class="toc-number">3.2.1.</span> <span class="toc-text">有向图字典序最小欧拉路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF"><span class="toc-number">3.2.2.</span> <span class="toc-text">欧拉回路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#K%E7%9F%AD%E8%B7%AF-%EF%BC%88%E5%8F%AF%E5%B9%B6%E5%A0%86%E4%BC%98%E5%8C%96%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">K短路 （可并堆优化）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">3.4.</span> <span class="toc-text">连通分量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%8F%8C"><span class="toc-number">3.4.1.</span> <span class="toc-text">点双</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E5%8F%8C"><span class="toc-number">3.4.2.</span> <span class="toc-text">边双</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">3.4.3.</span> <span class="toc-text">强连通分量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tarjan"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">tarjan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kosoraju"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">kosoraju</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91"><span class="toc-number">3.5.</span> <span class="toc-text">最小割树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91"><span class="toc-number">3.6.</span> <span class="toc-text">斯坦纳树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%9E%E8%B5%9B%E5%9B%BE%E7%9B%B8%E5%85%B3"><span class="toc-number">3.7.</span> <span class="toc-text">竞赛图相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%9E%E8%B5%9B%E5%9B%BE%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%9E%E8%B7%AF"><span class="toc-number">3.7.1.</span> <span class="toc-text">竞赛图哈密顿回路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%9E%E8%B5%9B%E5%9B%BE%E5%93%88%E5%AF%86%E9%A1%BF%E8%B7%AF"><span class="toc-number">3.7.1.1.</span> <span class="toc-text">竞赛图哈密顿路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%9E%E8%B5%9B%E5%9B%BE%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%9E%E8%B7%AF-1"><span class="toc-number">3.7.1.2.</span> <span class="toc-text">竞赛图哈密顿回路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">3.7.1.3.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E9%85%8D%E6%A0%91"><span class="toc-number">3.8.</span> <span class="toc-text">支配树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-SAT"><span class="toc-number">3.9.</span> <span class="toc-text">2-SAT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.10.</span> <span class="toc-text">差分约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="toc-number">3.11.</span> <span class="toc-text">网络流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-number">3.11.1.</span> <span class="toc-text">最大流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-number">3.11.2.</span> <span class="toc-text">最小费用最大流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%BA%90%E6%B1%87%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E5%8F%AF%E8%A1%8C%E6%B5%81"><span class="toc-number">3.11.3.</span> <span class="toc-text">无源汇有上下界可行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%BA%90%E6%B1%87%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-number">3.11.4.</span> <span class="toc-text">有源汇有上下界最大流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%BA%90%E6%B1%87%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E6%9C%80%E5%B0%8F%E6%B5%81"><span class="toc-number">3.11.5.</span> <span class="toc-text">有源汇有上下界最小流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE"><span class="toc-number">3.12.</span> <span class="toc-text">最小树形图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D-%E5%B8%A6%E8%8A%B1%E6%A0%91"><span class="toc-number">3.13.</span> <span class="toc-text">一般图最大匹配(带花树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%9D%83%E5%AE%8C%E7%BE%8E%E5%8C%B9%E9%85%8D%EF%BC%88KM%EF%BC%89"><span class="toc-number">3.14.</span> <span class="toc-text">二分图最大权完美匹配（KM）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E7%BB%9D%E5%AF%B9%E4%B8%AD%E5%BF%83%EF%BC%88%E6%9C%80%E5%B0%8F%E7%9B%B4%E5%BE%84%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89"><span class="toc-number">3.15.</span> <span class="toc-text">图的绝对中心（最小直径生成树）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA"><span class="toc-number">4.</span> <span class="toc-text">数论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EXCRT"><span class="toc-number">4.1.</span> <span class="toc-text">EXCRT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95lulas"><span class="toc-number">4.2.</span> <span class="toc-text">扩展lulas</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%9C%E6%95%99%E7%AD%9B"><span class="toc-number">4.3.</span> <span class="toc-text">杜教筛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E5%B7%A7"><span class="toc-number">4.3.1.</span> <span class="toc-text">技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Min25"><span class="toc-number">4.4.</span> <span class="toc-text">Min25</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83"><span class="toc-number">4.5.</span> <span class="toc-text">高斯消元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86"><span class="toc-number">4.6.</span> <span class="toc-text">矩阵求逆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BSGS"><span class="toc-number">4.7.</span> <span class="toc-text">BSGS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exbsgs"><span class="toc-number">4.8.</span> <span class="toc-text">exbsgs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B6"><span class="toc-number">4.9.</span> <span class="toc-text">阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E6%A0%B9"><span class="toc-number">4.10.</span> <span class="toc-text">原根</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%8E%9F%E6%A0%B9"><span class="toc-number">4.10.1.</span> <span class="toc-text">求原根</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Miller-Rabin-amp-amp-Pollard-Rho"><span class="toc-number">4.11.</span> <span class="toc-text">Miller_Rabin &amp;&amp; Pollard_Rho</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exgcd-%EF%BC%88%E6%94%BE%E4%BA%86%E4%B8%80%E4%B8%AA%E6%B4%9B%E8%B0%B7%E6%9D%BF%E5%AD%90%EF%BC%8C-%E8%AE%B0%E5%BE%97%E9%80%A0%E4%B8%80%E4%B8%AA%E6%9C%89%E8%AF%B4%E6%98%8E%E7%9A%84%EF%BC%89"><span class="toc-number">4.12.</span> <span class="toc-text">exgcd （放了一个洛谷板子， 记得造一个有说明的）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#O-1-gcd"><span class="toc-number">4.13.</span> <span class="toc-text">O(1) gcd</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6"><span class="toc-number">5.</span> <span class="toc-text">组合数学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#fwt"><span class="toc-number">5.1.</span> <span class="toc-text">fwt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF"><span class="toc-number">5.2.</span> <span class="toc-text">子集卷积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0%E6%8A%80%E5%B7%A7"><span class="toc-number">5.3.</span> <span class="toc-text">集合幂级数技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E6%8A%80%E5%B7%A7%EF%BC%88%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">各种技巧（待补充）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%A8%E5%AE%B6%E6%A1%B6"><span class="toc-number">5.5.</span> <span class="toc-text">多项式全家桶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95-%E6%B1%82%E9%80%86%EF%BC%88%E4%BD%BF%E7%94%A8MTT%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">5.6.</span> <span class="toc-text">任意模数多项式乘法&#x2F;求逆（使用MTT实现）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%A8%A1NTT"><span class="toc-number">5.7.</span> <span class="toc-text">三模NTT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8-amp-BM%E7%AE%97%E6%B3%95"><span class="toc-number">5.8.</span> <span class="toc-text">常系数齐次线性递推 &amp; BM算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP"><span class="toc-number">6.1.</span> <span class="toc-text">KMP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">最小表示法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9B%B8%E5%85%B3"><span class="toc-number">6.3.</span> <span class="toc-text">自动机相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AC-%E8%87%AA%E5%8A%A8%E6%9C%BA-ACAM"><span class="toc-number">6.3.1.</span> <span class="toc-text">AC 自动机 ACAM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">1.1 算法详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-fail-%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">6.3.1.2.</span> <span class="toc-text">1.2 fail 树的性质与应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%BA%94%E7%94%A8"><span class="toc-number">6.3.1.3.</span> <span class="toc-text">1.3 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-1-%E7%BB%93%E5%90%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">6.3.1.3.1.</span> <span class="toc-text">1.3.1 结合动态规划</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">6.3.1.4.</span> <span class="toc-text">1.4 注意点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E4%BE%8B%E9%A2%98"><span class="toc-number">6.3.1.5.</span> <span class="toc-text">1.5 例题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#I-P3808-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91AC-%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89"><span class="toc-number">6.3.1.5.1.</span> <span class="toc-text">I. P3808 【模板】AC 自动机（简单版）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM"><span class="toc-number">6.3.2.</span> <span class="toc-text">后缀自动机 SAM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BC%95%E7%90%86"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">2.1 基本定义与引理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%85%B3%E9%94%AE%E7%BB%93%E8%AE%BA"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">2.2 关键结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%9E%84%E5%BB%BA-SAM"><span class="toc-number">6.3.2.3.</span> <span class="toc-text">2.3 构建 SAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%81%E6%98%8E"><span class="toc-number">6.3.2.4.</span> <span class="toc-text">2.4 时间复杂度证明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-1-%E7%8A%B6%E6%80%81%E6%95%B0%E4%B8%8A%E7%95%8C"><span class="toc-number">6.3.2.4.1.</span> <span class="toc-text">2.4.1 状态数上界</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-2-%E8%BD%AC%E7%A7%BB%E6%95%B0%E4%B8%8A%E7%95%8C"><span class="toc-number">6.3.2.4.2.</span> <span class="toc-text">2.4.2 转移数上界</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E5%BA%94%E7%94%A8"><span class="toc-number">6.3.2.5.</span> <span class="toc-text">2.5 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-1-%E6%B1%82%E6%9C%AC%E8%B4%A8%E4%B8%8D%E5%90%8C%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0"><span class="toc-number">6.3.2.5.1.</span> <span class="toc-text">2.5.1 求本质不同子串个数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D"><span class="toc-number">6.3.2.5.2.</span> <span class="toc-text">2.5.2 字符串匹配</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E5%B9%BF%E4%B9%89-SAM"><span class="toc-number">6.3.2.6.</span> <span class="toc-text">2.6 广义 SAM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E7%BB%93%E8%AE%BA"><span class="toc-number">6.3.3.</span> <span class="toc-text">2.7 常用技巧与结论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6%E7%BB%B4%E6%8A%A4-mathrm-endpos-%E9%9B%86%E5%90%88"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">2.7.1 线段树合并维护 $\mathrm{endpos}$ 集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-%E6%A1%B6%E6%8E%92%E7%A1%AE%E5%AE%9A-dfs-%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">2.7.2 桶排确定 dfs 顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-3-%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E5%AD%90%E4%B8%B2"><span class="toc-number">6.3.3.3.</span> <span class="toc-text">2.7.3 快速定位子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-4-%E5%85%B6%E5%AE%83%E7%BB%93%E8%AE%BA"><span class="toc-number">6.3.3.4.</span> <span class="toc-text">2.7.4 其它结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E6%B3%A8%E6%84%8F%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">6.3.4.</span> <span class="toc-text">2.8 注意点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">6.4.</span> <span class="toc-text">后缀平衡树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%96%87"><span class="toc-number">6.5.</span> <span class="toc-text">回文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#manacher"><span class="toc-number">6.5.1.</span> <span class="toc-text">manacher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PAM"><span class="toc-number">6.5.2.</span> <span class="toc-text">PAM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exkmp"><span class="toc-number">6.6.</span> <span class="toc-text">exkmp</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95"><span class="toc-number">7.</span> <span class="toc-text">计算几何</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%B8%E5%8C%85"><span class="toc-number">7.1.</span> <span class="toc-text">凸包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%B8%E5%8C%85%E7%9B%B4%E5%BE%84"><span class="toc-number">7.2.</span> <span class="toc-text">凸包直径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E7%BA%BF%E4%BA%A4%E7%82%B9"><span class="toc-number">7.3.</span> <span class="toc-text">直线交点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4"><span class="toc-number">7.4.</span> <span class="toc-text">半平面交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C"><span class="toc-number">7.5.</span> <span class="toc-text">闵可夫斯基和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%9B%E6%99%AE%E6%A3%AE%E7%A7%AF%E5%88%86"><span class="toc-number">7.6.</span> <span class="toc-text">辛普森积分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%86%E5%9C%86%E4%BA%A4%E7%82%B9"><span class="toc-number">7.7.</span> <span class="toc-text">圆圆交点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E5%9B%BE%E8%BD%AC%E5%AF%B9%E5%81%B6%E5%9B%BE"><span class="toc-number">7.8.</span> <span class="toc-text">平面图转对偶图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%85%A8%E5%AE%B6%E6%A1%B6"><span class="toc-number">7.9.</span> <span class="toc-text">常用操作全家桶</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%82%E6%8A%80"><span class="toc-number">8.</span> <span class="toc-text">杂技</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%9F%BA"><span class="toc-number">8.1.</span> <span class="toc-text">线性基</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-number">8.1.1.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%BC%82%E6%88%96%E5%87%BA%E6%9D%A5"><span class="toc-number">8.1.2.</span> <span class="toc-text">查询一个元素是否可以被异或出来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%BC%82%E6%88%96%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">8.1.3.</span> <span class="toc-text">查询异或最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%BC%82%E6%88%96%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">8.1.4.</span> <span class="toc-text">查询异或最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%BC%82%E6%88%96%E7%AC%AC-k-%E5%B0%8F"><span class="toc-number">8.1.5.</span> <span class="toc-text">查询异或第$k$小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%8E%92%E5%90%8D"><span class="toc-number">8.1.6.</span> <span class="toc-text">查询排名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E7%BB%93%E8%AE%BA-amp-%E5%AE%9A%E7%90%86-amp-%E6%8A%80%E5%B7%A7"><span class="toc-number">9.</span> <span class="toc-text">部分结论 &amp; 定理 &amp; 技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Prufer-%E5%BA%8F%E5%88%97"><span class="toc-number">9.1.</span> <span class="toc-text">Prufer 序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E8%BD%AC-Prufer"><span class="toc-number">9.1.1.</span> <span class="toc-text">树转 Prufer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prufer-%E8%BD%AC%E6%A0%91"><span class="toc-number">9.1.2.</span> <span class="toc-text">Prufer 转树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%8E%A8%E8%AE%BA%E6%88%96%E5%BA%94%E7%94%A8"><span class="toc-number">9.1.3.</span> <span class="toc-text">一些推论或应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%EF%BC%9A%E5%9B%BE%E8%81%94%E9%80%9A%E8%AE%A1%E6%95%B0"><span class="toc-number">9.1.4.</span> <span class="toc-text">拓展：图联通计数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%8E%AF%E8%AE%A1%E6%95%B0"><span class="toc-number">9.2.</span> <span class="toc-text">无向图环计数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0"><span class="toc-number">9.2.1.</span> <span class="toc-text">三元环计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0"><span class="toc-number">9.2.2.</span> <span class="toc-text">四元环计数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%9E%E8%B5%9B%E5%9B%BE"><span class="toc-number">9.3.</span> <span class="toc-text">竞赛图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%AF%86%E9%A1%BF%E8%B7%AF%E5%BE%84"><span class="toc-number">9.3.1.</span> <span class="toc-text">哈密顿路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%9E%E8%B7%AF"><span class="toc-number">9.3.2.</span> <span class="toc-text">哈密顿回路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B0%E9%81%93%E5%AE%9A%E7%90%86"><span class="toc-number">9.3.3.</span> <span class="toc-text">兰道定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Erdos%E2%80%93Gallai-%E5%AE%9A%E7%90%86"><span class="toc-number">9.3.4.</span> <span class="toc-text">Erdős–Gallai 定理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F"><span class="toc-number">9.4.</span> <span class="toc-text">欧拉公式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%B9%B3%E9%9D%A2%E5%9B%BE%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="toc-number">9.5.</span> <span class="toc-text">非平面图的判定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA-1"><span class="toc-number">9.6.</span> <span class="toc-text">数论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86"><span class="toc-number">9.6.1.</span> <span class="toc-text">费马小定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86"><span class="toc-number">9.6.2.</span> <span class="toc-text">欧拉定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86"><span class="toc-number">9.6.3.</span> <span class="toc-text">拓展欧拉定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-1-%E5%BF%AB%E9%80%9F%E4%B9%98"><span class="toc-number">9.6.4.</span> <span class="toc-text">O(1) 快速乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exgcd"><span class="toc-number">9.6.5.</span> <span class="toc-text">Exgcd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86"><span class="toc-number">9.6.6.</span> <span class="toc-text">中国剩余定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Excrt"><span class="toc-number">9.6.7.</span> <span class="toc-text">Excrt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lucas-%E5%AE%9A%E7%90%86"><span class="toc-number">9.6.8.</span> <span class="toc-text">Lucas 定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E9%BB%98%E5%B0%94%E5%AE%9A%E7%90%86"><span class="toc-number">9.6.9.</span> <span class="toc-text">库默尔定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86"><span class="toc-number">9.6.10.</span> <span class="toc-text">威尔逊定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83"><span class="toc-number">9.6.11.</span> <span class="toc-text">乘法逆元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E6%A0%B9%E4%B8%8E%E4%B9%98%E6%B3%95%E7%BE%A4"><span class="toc-number">9.6.12.</span> <span class="toc-text">原根与乘法群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E6%A0%B9%E5%9F%BA%E7%A1%80"><span class="toc-number">9.6.13.</span> <span class="toc-text">原根基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0"><span class="toc-number">9.6.14.</span> <span class="toc-text">离散对数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6-1"><span class="toc-number">9.6.15.</span> <span class="toc-text">阶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99"><span class="toc-number">9.6.16.</span> <span class="toc-text">二次剩余</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Baby-Step-Giant-Step-BSGS"><span class="toc-number">9.6.17.</span> <span class="toc-text">Baby Step Giant Step(BSGS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">9.6.18.</span> <span class="toc-text">类欧几里得算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">9.6.19.</span> <span class="toc-text">万能欧几里得算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stern-Brocot-%E6%A0%91"><span class="toc-number">9.6.20.</span> <span class="toc-text">Stern-Brocot 树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E6%96%A5%E4%B8%8E%E5%8F%8D%E6%BC%94"><span class="toc-number">9.7.</span> <span class="toc-text">容斥与反演</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94"><span class="toc-number">9.7.1.</span> <span class="toc-text">莫比乌斯反演</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%A7%AF%E6%80%A7-%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0"><span class="toc-number">9.7.1.1.</span> <span class="toc-text">常见积性&#x2F;数论函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9D%E5%B0%94%E7%BA%A7%E6%95%B0"><span class="toc-number">9.7.1.2.</span> <span class="toc-text">贝尔级数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E6%A0%B8%E5%BF%83%E5%BC%8F"><span class="toc-number">9.7.1.3.</span> <span class="toc-text">莫比乌斯反演核心式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A8%E8%AE%BA%E5%BC%8F"><span class="toc-number">9.7.1.4.</span> <span class="toc-text">一些常用的推论式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%9C%E6%95%99%E7%AD%9B-1"><span class="toc-number">9.7.1.5.</span> <span class="toc-text">杜教筛</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94"><span class="toc-number">9.7.2.</span> <span class="toc-text">单位根反演</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%8F%8D%E6%BC%94"><span class="toc-number">9.7.3.</span> <span class="toc-text">拉格朗日反演</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E5%8F%8D%E6%BC%94"><span class="toc-number">9.7.4.</span> <span class="toc-text">子集反演</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94"><span class="toc-number">9.7.4.1.</span> <span class="toc-text">二项式反演</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%AD%90%E9%9B%86%E5%8F%8D%E6%BC%94"><span class="toc-number">9.7.5.</span> <span class="toc-text">多重子集反演</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%A6%E6%81%A9%E5%9B%BE%E5%BC%8F%E5%AE%B9%E6%96%A5"><span class="toc-number">9.7.6.</span> <span class="toc-text">韦恩图式容斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#min-max-%E5%AE%B9%E6%96%A5"><span class="toc-number">9.7.7.</span> <span class="toc-text">min-max 容斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%92%E5%88%86%E5%AE%B9%E6%96%A5"><span class="toc-number">9.7.8.</span> <span class="toc-text">条件划分容斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AF%E7%89%B9%E6%9E%97%E5%8F%8D%E6%BC%94"><span class="toc-number">9.7.9.</span> <span class="toc-text">斯特林反演</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E9%99%90%E5%88%B6%E7%9A%84%E5%AE%B9%E6%96%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">9.7.10.</span> <span class="toc-text">一些经典限制的容斥方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="toc-number">9.8.</span> <span class="toc-text">多项式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC"><span class="toc-number">9.8.1.</span> <span class="toc-text">拉格朗日插值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%B9%82%E5%92%8C"><span class="toc-number">9.8.1.1.</span> <span class="toc-text">整数幂和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8D%B7%E7%A7%AF"><span class="toc-number">9.8.2.</span> <span class="toc-text">循环卷积</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bluestein-%E7%AE%97%E6%B3%95"><span class="toc-number">9.8.2.1.</span> <span class="toc-text">bluestein 算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E6%8E%A8%E5%AF%BC%E7%9B%B8%E5%85%B3"><span class="toc-number">9.8.3.</span> <span class="toc-text">生成函数推导相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80"><span class="toc-number">9.8.3.1.</span> <span class="toc-text">泰勒展开</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86"><span class="toc-number">9.8.3.2.</span> <span class="toc-text">广义二项式定理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-number">9.8.3.3.</span> <span class="toc-text">常用生成函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%95%E5%BC%80%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-number">9.8.3.4.</span> <span class="toc-text">展开生成函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0%E5%AE%9A%E7%90%86"><span class="toc-number">9.8.4.</span> <span class="toc-text">五边形数定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BC%8F%E5%AD%90"><span class="toc-number">9.8.5.</span> <span class="toc-text">组合数问题的一个式子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%80%BC%E8%BD%AC%E4%B8%8B%E9%99%8D%E5%B9%82%E7%B3%BB%E6%95%B0"><span class="toc-number">9.8.6.</span> <span class="toc-text">点值转下降幂系数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6-1"><span class="toc-number">9.9.</span> <span class="toc-text">组合数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="toc-number">9.9.1.</span> <span class="toc-text">排列组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88%E6%81%92%E7%AD%89%E5%BC%8F"><span class="toc-number">9.9.1.1.</span> <span class="toc-text">经典组合恒等式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">9.9.1.2.</span> <span class="toc-text">经典组合问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%AF%E4%B8%8A%E9%82%BB%E8%89%B2%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9F%93%E8%89%B2%E6%96%B9%E6%A1%88"><span class="toc-number">9.9.1.2.1.</span> <span class="toc-text">环上邻色不同的染色方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98"><span class="toc-number">9.9.1.2.2.</span> <span class="toc-text">错排问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E5%9B%BE%E8%B7%AF%E5%BE%84%E6%95%B0%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98"><span class="toc-number">9.9.1.2.3.</span> <span class="toc-text">网格图路径数统计问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E6%9D%BF%E6%B3%95"><span class="toc-number">9.9.1.2.4.</span> <span class="toc-text">插板法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E4%B8%8B%E7%95%8C%E9%97%AE%E9%A2%98"><span class="toc-number">9.9.1.2.5.</span> <span class="toc-text">冒泡下界问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raney-%E5%BC%95%E7%90%86"><span class="toc-number">9.9.1.3.</span> <span class="toc-text">Raney 引理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-number">9.9.2.</span> <span class="toc-text">斐波那契数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0"><span class="toc-number">9.9.3.</span> <span class="toc-text">卡特兰数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">9.9.3.1.</span> <span class="toc-text">代表的一些问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0"><span class="toc-number">9.9.4.</span> <span class="toc-text">斯特林数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0"><span class="toc-number">9.9.4.1.</span> <span class="toc-text">第二类斯特林数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">9.9.4.1.1.</span> <span class="toc-text">行计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E8%AE%A1%E7%AE%97"><span class="toc-number">9.9.4.1.2.</span> <span class="toc-text">列计算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0"><span class="toc-number">9.9.4.2.</span> <span class="toc-text">第一类斯特林数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8C%E8%AE%A1%E7%AE%97-1"><span class="toc-number">9.9.4.2.1.</span> <span class="toc-text">行计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E8%AE%A1%E7%AE%97-1"><span class="toc-number">9.9.4.2.2.</span> <span class="toc-text">列计算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E5%8D%87%E5%B9%82%E4%B8%8E%E4%B8%8B%E9%99%8D%E5%B9%82"><span class="toc-number">9.9.4.3.</span> <span class="toc-text">上升幂与下降幂</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80"><span class="toc-number">9.9.5.</span> <span class="toc-text">康托展开</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0"><span class="toc-number">9.10.</span> <span class="toc-text">线性代数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-number">9.10.1.</span> <span class="toc-text">矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9"><span class="toc-number">9.10.1.1.</span> <span class="toc-text">矩阵的秩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E5%88%97%E5%BC%8F"><span class="toc-number">9.10.1.2.</span> <span class="toc-text">行列式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LGV-%E5%BC%95%E7%90%86"><span class="toc-number">9.10.1.2.1.</span> <span class="toc-text">LGV 引理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%88%97%E5%BC%8F"><span class="toc-number">9.10.1.2.2.</span> <span class="toc-text">特殊矩阵行列式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E9%80%86"><span class="toc-number">9.10.1.3.</span> <span class="toc-text">矩阵的逆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86"><span class="toc-number">9.10.2.</span> <span class="toc-text">矩阵树定理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0"><span class="toc-number">9.10.2.1.</span> <span class="toc-text">无向图生成树计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0"><span class="toc-number">9.10.2.2.</span> <span class="toc-text">有向图生成树计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8B%93%E5%B1%95"><span class="toc-number">9.10.2.3.</span> <span class="toc-text">多项式拓展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Best-%E5%AE%9A%E7%90%86"><span class="toc-number">9.10.2.4.</span> <span class="toc-text">Best 定理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B"><span class="toc-number">9.11.</span> <span class="toc-text">概率与期望</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E7%8E%87"><span class="toc-number">9.11.1.</span> <span class="toc-text">概率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%9F%E6%9C%9B"><span class="toc-number">9.11.2.</span> <span class="toc-text">期望</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%9F%E6%9C%9B%E6%96%B9%E7%A8%8B"><span class="toc-number">9.11.2.1.</span> <span class="toc-text">期望方程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%9F%E6%9C%9B-dp"><span class="toc-number">9.11.2.2.</span> <span class="toc-text">期望 dp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%BD%AC%E7%A7%BB"><span class="toc-number">9.11.2.3.</span> <span class="toc-text">循环转移</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#command-block-%E5%8D%9A%E5%AE%A2-%EF%BC%88%E6%8A%80%E5%B7%A7%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">command_block 博客 （技巧）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%85%E8%A1%A5%E5%85%85"><span class="toc-number">11.</span> <span class="toc-text">待补充</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/20/Codeforces%20Round%20916%20(Div.%203)/" title="Codeforces Round 916 (Div. 3)"><img src="https://pic1.zhimg.com/50/v2-84d384e689f0e43f36671c662875c454_720w.jpg?source=1940ef5c" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Codeforces Round 916 (Div. 3)"/></a><div class="content"><a class="title" href="/2023/12/20/Codeforces%20Round%20916%20(Div.%203)/" title="Codeforces Round 916 (Div. 3)">Codeforces Round 916 (Div. 3)</a><time datetime="2023-12-19T16:00:00.000Z" title="发表于 2023-12-20 00:00:00">2023-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/19/Codeforces%20Round%20914%20(Div.%202)/" title="Codeforces Round 914 (Div. 2)"><img src="https://pic1.zhimg.com/50/v2-5ab6cc501297c3b1bcb6b889f29ca303_720w.jpg?source=1940ef5c" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Codeforces Round 914 (Div. 2)"/></a><div class="content"><a class="title" href="/2023/12/19/Codeforces%20Round%20914%20(Div.%202)/" title="Codeforces Round 914 (Div. 2)">Codeforces Round 914 (Div. 2)</a><time datetime="2023-12-18T16:00:00.000Z" title="发表于 2023-12-19 00:00:00">2023-12-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/19/Educational%20Codeforces%20Round%20160%20(Rated%20for%20Div.%202)/" title="Educational Codeforces Round 160 (Rated for Div. 2)"><img src="https://pic4.zhimg.com/v2-d7426a1316bfae99769453b51e11a7c7_b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Educational Codeforces Round 160 (Rated for Div. 2)"/></a><div class="content"><a class="title" href="/2023/12/19/Educational%20Codeforces%20Round%20160%20(Rated%20for%20Div.%202)/" title="Educational Codeforces Round 160 (Rated for Div. 2)">Educational Codeforces Round 160 (Rated for Div. 2)</a><time datetime="2023-12-18T16:00:00.000Z" title="发表于 2023-12-19 00:00:00">2023-12-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/18/The%202022%20ICPC%20Asia-East%20Continent%20Final%20Contest%20(EC-Final%202022)/" title="The 2022 ICPC Asia-East Continent Final Contest (EC-Final 2022)"><img src="https://pic1.zhimg.com/v2-511b534ef6da4b7b3a3113abd5ef29f0_b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="The 2022 ICPC Asia-East Continent Final Contest (EC-Final 2022)"/></a><div class="content"><a class="title" href="/2023/12/18/The%202022%20ICPC%20Asia-East%20Continent%20Final%20Contest%20(EC-Final%202022)/" title="The 2022 ICPC Asia-East Continent Final Contest (EC-Final 2022)">The 2022 ICPC Asia-East Continent Final Contest (EC-Final 2022)</a><time datetime="2023-12-17T16:00:00.000Z" title="发表于 2023-12-18 00:00:00">2023-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/17/Codeforces%20Round%20915%20(Div.%202)/" title="Codeforces Round 915 (Div. 2)"><img src="https://pic3.zhimg.com/v2-7beb5d2b4e100a4b8eda1001f9c2f81e_b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Codeforces Round 915 (Div. 2)"/></a><div class="content"><a class="title" href="/2023/12/17/Codeforces%20Round%20915%20(Div.%202)/" title="Codeforces Round 915 (Div. 2)">Codeforces Round 915 (Div. 2)</a><time datetime="2023-12-16T16:00:00.000Z" title="发表于 2023-12-17 00:00:00">2023-12-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://ts1.cn.mm.bing.net/th/id/R-C.c4c52f16cc67c7409eff60a4fce2d152?rik=qBwdq1iz39HyPA&amp;riu=http%3a%2f%2fwww.kutoo8.com%2fupload%2fimage%2f95093231%2f13.jpg&amp;ehk=%2flbRri2PpwfxcQiqdvwcgv76NPhmuhxXUC9lhcyITcw%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wrpwrp</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>